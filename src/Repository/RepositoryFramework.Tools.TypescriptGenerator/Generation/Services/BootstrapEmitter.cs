using System.Text;
using RepositoryFramework.Tools.TypescriptGenerator.Domain;

namespace RepositoryFramework.Tools.TypescriptGenerator.Generation.Services;

/// <summary>
/// Emits the bootstrap/repositorySetup.ts file that configures RepositoryServices
/// using the rystem.repository.client library with transformers.
/// </summary>
public static class BootstrapEmitter
{
    /// <summary>
    /// Emits the complete bootstrap file with RepositoryServices configuration.
    /// </summary>
    public static string Emit(
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        var sb = new StringBuilder();
        var repoList = repositories.ToList();

        // Header comment
        sb.AppendLine("// ============================================");
        sb.AppendLine("// Repository Framework Configuration");
        sb.AppendLine("// Auto-generated by rystem-ts - do not edit manually");
        sb.AppendLine("// ============================================");
        sb.AppendLine();

        // Import RepositoryServices and RepositoryEndpoint
        sb.AppendLine("import { RepositoryServices } from 'rystem.repository.client';");
        sb.AppendLine("import type { RepositoryEndpoint } from 'rystem.repository.client';");
        sb.AppendLine();

        // Emit imports for transformers
        EmitTransformerImports(sb, repoList, models, keys);

        // Emit the config interface
        EmitConfigInterface(sb);

        // Emit the setup function
        EmitSetupFunction(sb, repoList, models, keys);

        return sb.ToString();
    }

    private static void EmitTransformerImports(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        var transformers = new HashSet<string>();
        var typeImports = new Dictionary<string, HashSet<string>>(); // file -> types

        foreach (var repo in repositories)
        {
            var modelSimpleName = GetSimpleName(repo.ModelName);
            var keySimpleName = GetSimpleName(repo.KeyName);

            // Add model transformer and type
            ModelDescriptor? model = null;
            if (models.TryGetValue(modelSimpleName, out model))
            {
                // Found direct match
            }
            else
            {
                // Try to find open generic for closed generic type
                model = TypeScriptGenerator.FindOpenGenericForClosedGeneric(modelSimpleName, models.Values);
            }

            if (model != null)
            {
                var transformerName = $"{model.GetBaseTypeName()}Transformer";
                transformers.Add(transformerName);

                // Also need to import the clean type for generics
                var fileName = model.GetFileName().Replace(".ts", "");
                if (!typeImports.TryGetValue(fileName, out var list))
                {
                    list = [];
                    typeImports[fileName] = list;
                }
                list.Add(model.GetBaseTypeName());
            }

            // Add key transformer and type (if not primitive)
            if (!repo.IsPrimitiveKey)
            {
                ModelDescriptor? key = null;
                if (keys.TryGetValue(keySimpleName, out key))
                {
                    // Found direct match
                }
                else
                {
                    // Try to find open generic
                    key = TypeScriptGenerator.FindOpenGenericForClosedGeneric(keySimpleName, keys.Values);
                }

                if (key != null)
                {
                    var transformerName = $"{key.GetBaseTypeName()}Transformer";
                    transformers.Add(transformerName);

                    // Also need to import the clean key type for generics
                    var fileName = key.GetFileName().Replace(".ts", "");
                    if (!typeImports.TryGetValue(fileName, out var list))
                    {
                        list = [];
                        typeImports[fileName] = list;
                    }
                    list.Add(key.GetBaseTypeName());
                }
            }
        }

        // Emit type imports (with import type)
        foreach (var (fileName, types) in typeImports.OrderBy(x => x.Key))
        {
            var typesJoined = string.Join(", ", types.OrderBy(x => x));
            sb.AppendLine($"import type {{ {typesJoined} }} from '../types/{fileName}';");
        }
        if (typeImports.Count > 0)
            sb.AppendLine();

        // Emit transformer imports
        foreach (var transformer in transformers.OrderBy(x => x))
        {
            var typeName = transformer.Replace("Transformer", "");
            sb.AppendLine($"import {{ {transformer} }} from '../transformers/{typeName}Transformer';");
        }

        if (transformers.Count > 0)
            sb.AppendLine();
    }

    private static void EmitConfigInterface(StringBuilder sb)
    {
        sb.AppendLine("/**");
        sb.AppendLine(" * Configuration options for repository services setup.");
        sb.AppendLine(" */");
        sb.AppendLine("export interface RepositoryConfig {");
        sb.AppendLine("  /** Base URL for the API (e.g., 'https://api.example.com/api/') */");
        sb.AppendLine("  baseUrl: string;");
        sb.AppendLine();
        sb.AppendLine("  /**");
        sb.AppendLine("   * Optional header enricher function called before each request.");
        sb.AppendLine("   * Use this to add authentication headers, etc.");
        sb.AppendLine("   */");
        sb.AppendLine("  headersEnricher?: (");
        sb.AppendLine("    endpoint: RepositoryEndpoint,");
        sb.AppendLine("    uri: string,");
        sb.AppendLine("    method: string,");
        sb.AppendLine("    headers: HeadersInit,");
        sb.AppendLine("    body: any");
        sb.AppendLine("  ) => Promise<HeadersInit>;");
        sb.AppendLine();
        sb.AppendLine("  /**");
        sb.AppendLine("   * Optional error handler called when a request fails.");
        sb.AppendLine("   * Return true to retry the request, false otherwise.");
        sb.AppendLine("   */");
        sb.AppendLine("  errorHandler?: (");
        sb.AppendLine("    endpoint: RepositoryEndpoint,");
        sb.AppendLine("    uri: string,");
        sb.AppendLine("    method: string,");
        sb.AppendLine("    headers: HeadersInit,");
        sb.AppendLine("    body: any,");
        sb.AppendLine("    err: any");
        sb.AppendLine("  ) => Promise<boolean>;");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitSetupFunction(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        sb.AppendLine("/**");
        sb.AppendLine(" * Sets up all repository services with the provided configuration.");
        sb.AppendLine(" * Call this once at application startup.");
        sb.AppendLine(" *");
        sb.AppendLine(" * @example");
        sb.AppendLine(" * ```typescript");
        sb.AppendLine(" * setupRepositoryServices({");
        sb.AppendLine(" *   baseUrl: 'https://api.example.com/api/',");
        sb.AppendLine(" *   headersEnricher: async () => ({");
        sb.AppendLine(" *     'Authorization': `Bearer ${getToken()}`");
        sb.AppendLine(" *   }),");
        sb.AppendLine(" *   errorHandler: async (endpoint, uri, method, headers, body, err) => {");
        sb.AppendLine(" *     if (err?.status === 401) {");
        sb.AppendLine(" *       await refreshToken();");
        sb.AppendLine(" *       return true; // retry");
        sb.AppendLine(" *     }");
        sb.AppendLine(" *     return false;");
        sb.AppendLine(" *   }");
        sb.AppendLine(" * });");
        sb.AppendLine(" * ```");
        sb.AppendLine(" */");
        sb.AppendLine("export const setupRepositoryServices = (config: RepositoryConfig): void => {");
        sb.AppendLine("  const services = RepositoryServices.Create(config.baseUrl);");
        sb.AppendLine();

        var repoList = repositories.ToList();
        for (var i = 0; i < repoList.Count; i++)
        {
            var repo = repoList[i];
            EmitRepositoryRegistration(sb, repo, models, keys, i == repoList.Count - 1);
        }

        sb.AppendLine("};");
    }

    private static void EmitRepositoryRegistration(
        StringBuilder sb,
        RepositoryDescriptor repo,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys,
        bool isLast)
    {
        var modelSimpleName = GetSimpleName(repo.ModelName);
        var keySimpleName = GetSimpleName(repo.KeyName);

        // For RepositoryServices we use clean types (T, TKey) not Raw
        // The transformers handle the conversion
        var modelType = modelSimpleName;
        var keyType = GetKeyType(repo);

        // Determine method based on repository kind
        var method = repo.Kind switch
        {
            RepositoryKind.Repository => "addRepository",
            RepositoryKind.Query => "addQuery",
            RepositoryKind.Command => "addCommand",
            _ => "addRepository"
        };

        // Use factory name as the client-side name
        // Use ApiPath for the actual API endpoint path
        var clientName = repo.FactoryName;
        var apiPath = repo.ApiPath;

        sb.AppendLine($"  // {modelSimpleName} ({repo.Kind})");
        sb.AppendLine($"  services.{method}<{modelType}, {keyType}>(x => {{");
        sb.AppendLine($"    x.name = '{clientName}';");
        sb.AppendLine($"    x.path = '{apiPath}';");

        // Add transformer for model
        if (models.ContainsKey(modelSimpleName))
        {
            sb.AppendLine($"    x.transformer = {modelSimpleName}Transformer;");
        }

        // Add key transformer if not primitive
        if (!repo.IsPrimitiveKey && keys.ContainsKey(keySimpleName))
        {
            sb.AppendLine($"    x.keyTransformer = {keySimpleName}Transformer;");
            sb.AppendLine("    x.complexKey = true;");
        }

        sb.AppendLine("    if (config.headersEnricher) x.addHeadersEnricher(config.headersEnricher);");
        sb.AppendLine("    if (config.errorHandler) x.addErrorHandler(config.errorHandler);");
        sb.AppendLine("  });");

        if (!isLast)
            sb.AppendLine();
    }

    private static string GetKeyType(RepositoryDescriptor repo)
    {
        if (repo.IsPrimitiveKey)
        {
            return repo.KeyName.ToLowerInvariant() switch
            {
                "string" => "string",
                "guid" => "string",
                "int" or "int32" => "number",
                "long" or "int64" => "number",
                "double" => "number",
                "float" => "number",
                "decimal" => "number",
                "bool" or "boolean" => "boolean",
                _ => "string"
            };
        }

        return GetSimpleName(repo.KeyName);
    }

    private static string GetSimpleName(string fullName)
    {
        var lastDot = fullName.LastIndexOf('.');
        return lastDot >= 0 ? fullName[(lastDot + 1)..] : fullName;
    }
}
