using System.Text;
using RepositoryFramework.Tools.TypescriptGenerator.Domain;

namespace RepositoryFramework.Tools.TypescriptGenerator.Generation.Services;

/// <summary>
/// Emits the bootstrap/repositorySetup.ts file that configures RepositoryServices
/// using the rystem.repository.client library.
/// </summary>
public static class BootstrapEmitter
{
    /// <summary>
    /// Emits the complete bootstrap file with RepositoryServices configuration.
    /// </summary>
    public static string Emit(
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        var sb = new StringBuilder();

        // Header comment
        sb.AppendLine("// Repository Framework Configuration");
        sb.AppendLine("// Auto-generated by rystem-ts - do not edit manually");
        sb.AppendLine();

        // Import RepositoryServices
        sb.AppendLine("import { RepositoryServices, RepositorySettings, RepositoryEndpoint } from 'rystem.repository.client';");
        sb.AppendLine();

        // Emit imports for all models and keys
        EmitTypeImports(sb, repositories, models, keys);

        // Emit the config interface
        EmitConfigInterface(sb);

        // Emit the setup function
        EmitSetupFunction(sb, repositories, models, keys);

        return sb.ToString();
    }

    private static void EmitTypeImports(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        // Group imports by file (model name)
        var typesByFile = new Dictionary<string, List<string>>();

        foreach (var repo in repositories)
        {
            var modelSimpleName = GetSimpleName(repo.ModelName);
            var keySimpleName = GetSimpleName(repo.KeyName);

            // Add model Raw type
            if (models.ContainsKey(modelSimpleName))
            {
                if (!typesByFile.TryGetValue(modelSimpleName, out var list))
                {
                    list = [];
                    typesByFile[modelSimpleName] = list;
                }
                if (!list.Contains($"{modelSimpleName}Raw"))
                    list.Add($"{modelSimpleName}Raw");
            }

            // Add key Raw type (if not primitive)
            if (!repo.IsPrimitiveKey && keys.ContainsKey(keySimpleName))
            {
                // Key might be in its own file or with the model
                if (!typesByFile.TryGetValue(keySimpleName, out var list))
                {
                    list = [];
                    typesByFile[keySimpleName] = list;
                }
                if (!list.Contains($"{keySimpleName}Raw"))
                    list.Add($"{keySimpleName}Raw");
            }
        }

        // Emit imports
        foreach (var (fileName, types) in typesByFile.OrderBy(x => x.Key))
        {
            var typesJoined = string.Join(", ", types.OrderBy(x => x));
            sb.AppendLine($"import {{ {typesJoined} }} from '../types/{fileName}';");
        }

        if (typesByFile.Count > 0)
            sb.AppendLine();
    }

    private static void EmitConfigInterface(StringBuilder sb)
    {
        sb.AppendLine("/**");
        sb.AppendLine(" * Configuration options for repository services setup.");
        sb.AppendLine(" */");
        sb.AppendLine("export interface RepositoryConfig {");
        sb.AppendLine("  /** Base URL for the API (e.g., 'https://api.example.com/api/') */");
        sb.AppendLine("  baseUrl: string;");
        sb.AppendLine();
        sb.AppendLine("  /**");
        sb.AppendLine("   * Optional header enricher function called before each request.");
        sb.AppendLine("   * Use this to add authentication headers, etc.");
        sb.AppendLine("   */");
        sb.AppendLine("  headersEnricher?: (");
        sb.AppendLine("    endpoint: RepositoryEndpoint,");
        sb.AppendLine("    uri: string,");
        sb.AppendLine("    method: string,");
        sb.AppendLine("    headers: HeadersInit,");
        sb.AppendLine("    body: any");
        sb.AppendLine("  ) => Promise<HeadersInit>;");
        sb.AppendLine();
        sb.AppendLine("  /**");
        sb.AppendLine("   * Optional error handler called when a request fails.");
        sb.AppendLine("   * Return true to retry the request, false otherwise.");
        sb.AppendLine("   */");
        sb.AppendLine("  errorHandler?: (");
        sb.AppendLine("    endpoint: RepositoryEndpoint,");
        sb.AppendLine("    uri: string,");
        sb.AppendLine("    method: string,");
        sb.AppendLine("    headers: HeadersInit,");
        sb.AppendLine("    body: any,");
        sb.AppendLine("    err: any");
        sb.AppendLine("  ) => Promise<boolean>;");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitSetupFunction(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        sb.AppendLine("/**");
        sb.AppendLine(" * Sets up all repository services with the provided configuration.");
        sb.AppendLine(" * Call this once at application startup.");
        sb.AppendLine(" *");
        sb.AppendLine(" * @example");
        sb.AppendLine(" * ```typescript");
        sb.AppendLine(" * setupRepositoryServices({");
        sb.AppendLine(" *   baseUrl: 'https://api.example.com/api/',");
        sb.AppendLine(" *   headersEnricher: async () => ({");
        sb.AppendLine(" *     'Authorization': `Bearer ${getToken()}`");
        sb.AppendLine(" *   }),");
        sb.AppendLine(" *   errorHandler: async (endpoint, uri, method, headers, body, err) => {");
        sb.AppendLine(" *     if (err?.status === 401) {");
        sb.AppendLine(" *       await refreshToken();");
        sb.AppendLine(" *       return true; // retry");
        sb.AppendLine(" *     }");
        sb.AppendLine(" *     return false;");
        sb.AppendLine(" *   }");
        sb.AppendLine(" * });");
        sb.AppendLine(" * ```");
        sb.AppendLine(" */");
        sb.AppendLine("export const setupRepositoryServices = (config: RepositoryConfig): void => {");
        sb.AppendLine("  const services = RepositoryServices.Create(config.baseUrl);");
        sb.AppendLine();

        var repoList = repositories.ToList();
        for (var i = 0; i < repoList.Count; i++)
        {
            var repo = repoList[i];
            EmitRepositoryRegistration(sb, repo, models, keys, i == repoList.Count - 1);
        }

        sb.AppendLine("};");
    }

    private static void EmitRepositoryRegistration(
        StringBuilder sb,
        RepositoryDescriptor repo,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys,
        bool isLast)
    {
        var modelSimpleName = GetSimpleName(repo.ModelName);
        var keySimpleName = GetSimpleName(repo.KeyName);

        // Determine TypeScript types
        var modelType = models.ContainsKey(modelSimpleName) ? $"{modelSimpleName}Raw" : modelSimpleName;
        var keyType = GetKeyType(repo, keys);

        // Determine method based on repository kind
        var method = repo.Kind switch
        {
            RepositoryKind.Repository => "addRepository",
            RepositoryKind.Query => "addQuery",
            RepositoryKind.Command => "addCommand",
            _ => "addRepository"
        };

        // Use factory name as path (it's the API endpoint name)
        var pathName = repo.FactoryName;

        sb.AppendLine($"  // {modelSimpleName} ({repo.Kind})");
        sb.AppendLine($"  services.{method}<{modelType}, {keyType}>(x => {{");
        sb.AppendLine($"    x.name = '{pathName}';");
        sb.AppendLine($"    x.path = '{pathName}';");

        // Check if key is complex (not primitive)
        if (!repo.IsPrimitiveKey)
        {
            sb.AppendLine("    x.complexKey = true;");
        }

        sb.AppendLine("    if (config.headersEnricher) x.addHeadersEnricher(config.headersEnricher);");
        sb.AppendLine("    if (config.errorHandler) x.addErrorHandler(config.errorHandler);");
        sb.AppendLine("  });");

        if (!isLast)
            sb.AppendLine();
    }

    private static string GetKeyType(RepositoryDescriptor repo, IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        if (repo.IsPrimitiveKey)
        {
            return repo.KeyName.ToLowerInvariant() switch
            {
                "string" => "string",
                "guid" => "string",
                "int" or "int32" => "number",
                "long" or "int64" => "number",
                "double" => "number",
                "float" => "number",
                "decimal" => "number",
                "bool" or "boolean" => "boolean",
                _ => "string"
            };
        }

        var keySimpleName = GetSimpleName(repo.KeyName);
        return keys.ContainsKey(keySimpleName) ? $"{keySimpleName}Raw" : keySimpleName;
    }

    private static string GetSimpleName(string fullName)
    {
        // Extract simple name from fully qualified name (e.g., "Fantacalcio.Domain.Calendar" -> "Calendar")
        var lastDot = fullName.LastIndexOf('.');
        return lastDot >= 0 ? fullName[(lastDot + 1)..] : fullName;
    }
}
