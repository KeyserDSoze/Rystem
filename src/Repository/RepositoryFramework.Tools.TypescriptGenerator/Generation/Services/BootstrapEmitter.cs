using System.Text;
using RepositoryFramework.Tools.TypescriptGenerator.Domain;
using RepositoryFramework.Tools.TypescriptGenerator.Utils;

namespace RepositoryFramework.Tools.TypescriptGenerator.Generation.Services;

/// <summary>
/// Emits the bootstrap/repositorySetup.ts file that configures RepositoryServices
/// using the rystem.repository.client library with transformers.
/// </summary>
public static class BootstrapEmitter
{
    /// <summary>
    /// Emits the complete bootstrap file with RepositoryServices configuration.
    /// </summary>
    public static string Emit(
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        var sb = new StringBuilder();
        var repoList = repositories.ToList();

        // Header comment
        sb.AppendLine("// ============================================");
        sb.AppendLine("// Repository Framework Configuration");
        sb.AppendLine("// Auto-generated by rystem-ts - do not edit manually");
        sb.AppendLine("// ============================================");
        sb.AppendLine();

        // Import RepositoryServices and RepositoryEndpoint
        sb.AppendLine("import { RepositoryServices } from 'rystem.repository.client';");
        sb.AppendLine("import type { RepositoryEndpoint } from 'rystem.repository.client';");
        sb.AppendLine();

        // Emit imports for transformers
        EmitTransformerImports(sb, repoList, models, keys);

        // Emit the config interface
        EmitConfigInterface(sb);

        // Emit the setup function
        EmitSetupFunction(sb, repoList, models, keys);

        return sb.ToString();
    }

    private static void EmitTransformerImports(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        // Track transformer imports: baseName -> isGeneric
        var transformerInfos = new Dictionary<string, bool>();
        var typeImports = new Dictionary<string, HashSet<string>>(); // file -> types

        foreach (var repo in repositories)
        {
            var modelSimpleName = GetSimpleName(repo.ModelName);
            var keySimpleName = GetSimpleName(repo.KeyName);

            // Add model transformer and type
            ModelDescriptor? model = null;
            if (models.TryGetValue(modelSimpleName, out model))
            {
                // If it's a closed generic, find the open generic instead
                if (model.GenericBaseTypeName != null)
                {
                    model = TypeScriptGenerator.FindOpenGenericForClosedGeneric(modelSimpleName, models.Values) ?? model;
                }
            }
            else
            {
                // Try to find open generic for closed generic type
                model = TypeScriptGenerator.FindOpenGenericForClosedGeneric(modelSimpleName, models.Values);
            }

            if (model != null)
            {
                var modelBaseName = model.GetBaseTypeName();
                transformerInfos.TryAdd(modelBaseName, model.GenericTypeParameters.Count > 0);

                // Also need to import the clean type for generics
                var fileName = model.GetFileName().Replace(".ts", "");
                if (!typeImports.TryGetValue(fileName, out var list))
                {
                    list = [];
                    typeImports[fileName] = list;
                }
                list.Add(modelBaseName);
            }

            // Add key transformer and type (if not primitive)
            if (!repo.IsPrimitiveKey)
            {
                ModelDescriptor? key = null;
                if (keys.TryGetValue(keySimpleName, out key))
                {
                    // If it's a closed generic, find the open generic instead
                    if (key.GenericBaseTypeName != null)
                    {
                        key = TypeScriptGenerator.FindOpenGenericForClosedGeneric(keySimpleName, keys.Values) ?? key;
                    }
                }
                else
                {
                    // Try to find open generic
                    key = TypeScriptGenerator.FindOpenGenericForClosedGeneric(keySimpleName, keys.Values);
                }

                if (key != null)
                {
                    var keyBaseName = key.GetBaseTypeName();
                    transformerInfos.TryAdd(keyBaseName, key.GenericTypeParameters.Count > 0);

                    // Also need to import the clean key type for generics
                    var fileName = key.GetFileName().Replace(".ts", "");
                    if (!typeImports.TryGetValue(fileName, out var list))
                    {
                        list = [];
                        typeImports[fileName] = list;
                    }
                    list.Add(keyBaseName);
                }
            }
        }

        // Emit type imports (with import type)
        foreach (var (fileName, types) in typeImports.OrderBy(x => x.Key))
        {
            var typesJoined = string.Join(", ", types.OrderBy(x => x));
            sb.AppendLine($"import type {{ {typesJoined} }} from '../types/{fileName}';");
        }
        if (typeImports.Count > 0)
            sb.AppendLine();

        // Emit transformer imports
        // Non-generic: import { BookTransformer } from '../transformers/BookTransformer';
        // Generic: import { createEntityVersionsTransformer } from '../transformers/EntityVersionsTransformer';
        foreach (var (baseName, isGeneric) in transformerInfos.OrderBy(x => x.Key))
        {
            var importName = isGeneric ? $"create{baseName}Transformer" : $"{baseName}Transformer";
            sb.AppendLine($"import {{ {importName} }} from '../transformers/{baseName}Transformer';");
        }

        if (transformerInfos.Count > 0)
            sb.AppendLine();
    }

    private static void EmitConfigInterface(StringBuilder sb)
    {
        sb.AppendLine("/**");
        sb.AppendLine(" * Configuration options for repository services setup.");
        sb.AppendLine(" */");
        sb.AppendLine("export interface RepositoryConfig {");
        sb.AppendLine("  /** Base URL for the API (e.g., 'https://api.example.com/api/') */");
        sb.AppendLine("  baseUrl: string;");
        sb.AppendLine();
        sb.AppendLine("  /**");
        sb.AppendLine("   * Optional header enricher function called before each request.");
        sb.AppendLine("   * Use this to add authentication headers, etc.");
        sb.AppendLine("   */");
        sb.AppendLine("  headersEnricher?: (");
        sb.AppendLine("    endpoint: RepositoryEndpoint,");
        sb.AppendLine("    uri: string,");
        sb.AppendLine("    method: string,");
        sb.AppendLine("    headers: HeadersInit,");
        sb.AppendLine("    body: any");
        sb.AppendLine("  ) => Promise<HeadersInit>;");
        sb.AppendLine();
        sb.AppendLine("  /**");
        sb.AppendLine("   * Optional error handler called when a request fails.");
        sb.AppendLine("   * Return true to retry the request, false otherwise.");
        sb.AppendLine("   */");
        sb.AppendLine("  errorHandler?: (");
        sb.AppendLine("    endpoint: RepositoryEndpoint,");
        sb.AppendLine("    uri: string,");
        sb.AppendLine("    method: string,");
        sb.AppendLine("    headers: HeadersInit,");
        sb.AppendLine("    body: any,");
        sb.AppendLine("    err: any");
        sb.AppendLine("  ) => Promise<boolean>;");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitSetupFunction(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        sb.AppendLine("/**");
        sb.AppendLine(" * Sets up all repository services with the provided configuration.");
        sb.AppendLine(" * Call this once at application startup.");
        sb.AppendLine(" *");
        sb.AppendLine(" * @example");
        sb.AppendLine(" * ```typescript");
        sb.AppendLine(" * setupRepositoryServices({");
        sb.AppendLine(" *   baseUrl: 'https://api.example.com/api/',");
        sb.AppendLine(" *   headersEnricher: async () => ({");
        sb.AppendLine(" *     'Authorization': `Bearer ${getToken()}`");
        sb.AppendLine(" *   }),");
        sb.AppendLine(" *   errorHandler: async (endpoint, uri, method, headers, body, err) => {");
        sb.AppendLine(" *     if (err?.status === 401) {");
        sb.AppendLine(" *       await refreshToken();");
        sb.AppendLine(" *       return true; // retry");
        sb.AppendLine(" *     }");
        sb.AppendLine(" *     return false;");
        sb.AppendLine(" *   }");
        sb.AppendLine(" * });");
        sb.AppendLine(" * ```");
        sb.AppendLine(" */");
        sb.AppendLine("export const setupRepositoryServices = (config: RepositoryConfig): void => {");
        sb.AppendLine("  const services = RepositoryServices.Create(config.baseUrl);");
        sb.AppendLine();

        var repoList = repositories.ToList();
        for (var i = 0; i < repoList.Count; i++)
        {
            var repo = repoList[i];
            EmitRepositoryRegistration(sb, repo, models, keys, i == repoList.Count - 1);
        }

        sb.AppendLine("};");
    }

    private static void EmitRepositoryRegistration(
        StringBuilder sb,
        RepositoryDescriptor repo,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys,
        bool isLast)
    {
        var modelSimpleName = GetSimpleName(repo.ModelName);
        var keySimpleName = GetSimpleName(repo.KeyName);

        // For RepositoryServices we use clean types (T, TKey) not Raw
        // The transformers handle the conversion
        var modelType = modelSimpleName;
        var keyType = GetKeyType(repo);

        // Determine method based on repository kind
        var method = repo.Kind switch
        {
            RepositoryKind.Repository => "addRepository",
            RepositoryKind.Query => "addQuery",
            RepositoryKind.Command => "addCommand",
            _ => "addRepository"
        };

        // Use factory name as the client-side name
        // Use ApiPath for the actual API endpoint path
        var clientName = repo.FactoryName;
        var apiPath = repo.ApiPath;

        sb.AppendLine($"  // {modelSimpleName} ({repo.Kind})");
        sb.AppendLine($"  services.{method}<{modelType}, {keyType}>(x => {{");
        sb.AppendLine($"    x.name = '{clientName}';");
        sb.AppendLine($"    x.path = '{apiPath}';");

        // Add transformer for model
        ModelDescriptor? model = null;
        if (models.TryGetValue(modelSimpleName, out model))
        {
            // If it's a closed generic, find the open generic instead
            if (model.GenericBaseTypeName != null)
            {
                model = TypeScriptGenerator.FindOpenGenericForClosedGeneric(modelSimpleName, models.Values) ?? model;
            }
        }
        else
        {
            model = TypeScriptGenerator.FindOpenGenericForClosedGeneric(modelSimpleName, models.Values);
        }

        if (model != null)
        {
            var modelBaseName = model.GetBaseTypeName();
            if (model.GenericTypeParameters.Count > 0)
            {
                // Generic: use factory function with concrete type args
                // Extract type args from the closed generic name (e.g., EntityVersions<Book> -> Book)
                var typeArgs = ExtractTypeArgs(modelSimpleName);
                sb.AppendLine($"    x.transformer = create{modelBaseName}Transformer<{typeArgs}>();");
            }
            else
            {
                sb.AppendLine($"    x.transformer = {modelBaseName}Transformer;");
            }
        }

        // Add key transformer if not primitive
        ModelDescriptor? key = null;
        if (!repo.IsPrimitiveKey)
        {
            if (keys.TryGetValue(keySimpleName, out key))
            {
                if (key.GenericBaseTypeName != null)
                {
                    key = TypeScriptGenerator.FindOpenGenericForClosedGeneric(keySimpleName, keys.Values) ?? key;
                }
            }
            else
            {
                key = TypeScriptGenerator.FindOpenGenericForClosedGeneric(keySimpleName, keys.Values);
            }

            if (key != null)
            {
                var keyBaseName = key.GetBaseTypeName();
                if (key.GenericTypeParameters.Count > 0)
                {
                    var typeArgs = ExtractTypeArgs(keySimpleName);
                    sb.AppendLine($"    x.keyTransformer = create{keyBaseName}Transformer<{typeArgs}>();");
                }
                else
                {
                    sb.AppendLine($"    x.keyTransformer = {keyBaseName}Transformer;");
                }
                sb.AppendLine("    x.complexKey = true;");
            }
        }

        sb.AppendLine("    if (config.headersEnricher) x.addHeadersEnricher(config.headersEnricher);");
        sb.AppendLine("    if (config.errorHandler) x.addErrorHandler(config.errorHandler);");
        sb.AppendLine("  });");

        if (!isLast)
            sb.AppendLine();
    }

    /// <summary>
    /// Extracts type arguments from a closed generic name.
    /// E.g., "EntityVersions&lt;Book&gt;" -> "Book"
    /// E.g., "Entity&lt;Book, Chapter&gt;" -> "Book, Chapter"
    /// </summary>
    private static string ExtractTypeArgs(string genericName)
    {
        var ltIndex = genericName.IndexOf('<');
        var gtIndex = genericName.LastIndexOf('>');
        if (ltIndex >= 0 && gtIndex > ltIndex)
        {
            return genericName[(ltIndex + 1)..gtIndex];
        }
        return "any";
    }

    private static string GetKeyType(RepositoryDescriptor repo)
    {
        if (repo.IsPrimitiveKey)
        {
            return repo.KeyName.ToLowerInvariant() switch
            {
                "string" => "string",
                "guid" => "string",
                "int" or "int32" => "number",
                "long" or "int64" => "number",
                "double" => "number",
                "float" => "number",
                "decimal" => "number",
                "bool" or "boolean" => "boolean",
                _ => "string"
            };
        }

        return GetSimpleName(repo.KeyName);
    }

    private static string GetSimpleName(string fullName)
        => fullName.GetSimpleTypeName();
}
