using System.Text;
using RepositoryFramework.Tools.TypescriptGenerator.Domain;

namespace RepositoryFramework.Tools.TypescriptGenerator.Generation.Services;

/// <summary>
/// Emits the repositoryLocator.ts file that provides typed access to repositories.
/// Usage: RepositoryLocator.{FactoryName} returns IRepository/IQuery/ICommand
/// </summary>
public static class RepositoryLocatorEmitter
{
    /// <summary>
    /// Emits the complete RepositoryLocator file.
    /// </summary>
    public static string Emit(
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        var sb = new StringBuilder();
        var repoList = repositories.ToList();

        // Header
        sb.AppendLine("// ============================================");
        sb.AppendLine("// Repository Locator");
        sb.AppendLine("// Auto-generated by Rystem TypeScript Generator");
        sb.AppendLine("// ============================================");
        sb.AppendLine();

        // Determine which interface types are actually used
        var usedInterfaces = GetUsedInterfaces(repoList);

        // Imports from rystem.repository.client
        sb.AppendLine("import { RepositoryServices } from 'rystem.repository.client';");
        if (usedInterfaces.Count > 0)
        {
            var interfacesImport = string.Join(", ", usedInterfaces.OrderBy(x => x));
            sb.AppendLine($"import type {{ {interfacesImport} }} from 'rystem.repository.client';");
        }
        sb.AppendLine();

        // Import types for each repository
        EmitTypeImports(sb, repoList, models, keys);

        // Emit the RepositoryLocator object
        sb.AppendLine("/**");
        sb.AppendLine(" * Provides typed access to all configured repositories.");
        sb.AppendLine(" * Each property returns a strongly-typed repository instance.");
        sb.AppendLine(" *");
        sb.AppendLine(" * @example");
        sb.AppendLine(" * ```typescript");
        sb.AppendLine(" * const rank = await RepositoryLocator.ranks.get({ leagueId: 'serie-a' });");
        sb.AppendLine(" * const allRanks = await RepositoryLocator.ranks.query().toListAsync();");
        sb.AppendLine(" * ```");
        sb.AppendLine(" */");
        sb.AppendLine("export const RepositoryLocator = {");

        // Emit getter for each repository
        for (var i = 0; i < repoList.Count; i++)
        {
            var repo = repoList[i];
            var isLast = i == repoList.Count - 1;
            EmitRepositoryGetter(sb, repo, models, keys, isLast);
        }

        sb.AppendLine("} as const;");
        sb.AppendLine();

        // Export type for the locator
        sb.AppendLine("export type RepositoryLocatorType = typeof RepositoryLocator;");

        return sb.ToString();
    }

    /// <summary>
    /// Determines which interface types (IRepository, IQuery, ICommand) are actually used.
    /// </summary>
    private static HashSet<string> GetUsedInterfaces(IEnumerable<RepositoryDescriptor> repositories)
    {
        var interfaces = new HashSet<string>();

        foreach (var repo in repositories)
        {
            var interfaceType = repo.Kind switch
            {
                RepositoryKind.Query => "IQuery",
                RepositoryKind.Command => "ICommand",
                _ => "IRepository"
            };
            interfaces.Add(interfaceType);
        }

        return interfaces;
    }

    private static void EmitTypeImports(
        StringBuilder sb,
        IEnumerable<RepositoryDescriptor> repositories,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys)
    {
        var typesByFile = new Dictionary<string, HashSet<string>>();

        foreach (var repo in repositories)
        {
            var modelSimpleName = GetSimpleName(repo.ModelName);
            var keySimpleName = GetSimpleName(repo.KeyName);

            // Add model Clean type
            ModelDescriptor? model = null;
            if (models.TryGetValue(modelSimpleName, out model))
            {
                // Found direct match
            }
            else
            {
                // Try to find open generic
                model = TypeScriptGenerator.FindOpenGenericForClosedGeneric(modelSimpleName, models.Values);
            }

            if (model != null)
            {
                var fileName = model.GetFileName().Replace(".ts", "");
                var typeName = model.GetBaseTypeName();

                if (!typesByFile.TryGetValue(fileName, out var list))
                {
                    list = [];
                    typesByFile[fileName] = list;
                }
                if (!list.Contains(typeName))
                    list.Add(typeName);
            }

            // Add key Clean type (if not primitive)
            if (!repo.IsPrimitiveKey)
            {
                ModelDescriptor? key = null;
                if (keys.TryGetValue(keySimpleName, out key))
                {
                    // Found direct match
                }
                else
                {
                    // Try to find open generic
                    key = TypeScriptGenerator.FindOpenGenericForClosedGeneric(keySimpleName, keys.Values);
                }

                if (key != null)
                {
                    var fileName = key.GetFileName().Replace(".ts", "");
                    var typeName = key.GetBaseTypeName();

                    if (!typesByFile.TryGetValue(fileName, out var list))
                    {
                        list = [];
                        typesByFile[fileName] = list;
                    }
                    if (!list.Contains(typeName))
                        list.Add(typeName);
                }
            }
        }

        // Emit type imports
        foreach (var (fileName, types) in typesByFile.OrderBy(x => x.Key))
        {
            var typesJoined = string.Join(", ", types.OrderBy(x => x));
            sb.AppendLine($"import type {{ {typesJoined} }} from '../types/{fileName.ToLowerInvariant()}';");
        }

        if (typesByFile.Count > 0)
            sb.AppendLine();
    }

    private static void EmitRepositoryGetter(
        StringBuilder sb,
        RepositoryDescriptor repo,
        IReadOnlyDictionary<string, ModelDescriptor> models,
        IReadOnlyDictionary<string, ModelDescriptor> keys,
        bool isLast)
    {
        var modelSimpleName = GetSimpleName(repo.ModelName);
        var keySimpleName = GetSimpleName(repo.KeyName);

        // Determine key type
        var keyType = repo.IsPrimitiveKey
            ? GetPrimitiveKeyType(repo.KeyName)
            : keySimpleName;

        // Determine interface type based on RepositoryKind
        var interfaceType = repo.Kind switch
        {
            RepositoryKind.Query => "IQuery",
            RepositoryKind.Command => "ICommand",
            _ => "IRepository"
        };

        // Determine the method to call
        var methodName = repo.Kind switch
        {
            RepositoryKind.Query => "Query",
            RepositoryKind.Command => "Command",
            _ => "Repository"
        };

        var comma = isLast ? "" : ",";

        sb.AppendLine($"  /**");
        sb.AppendLine($"   * Gets the {repo.FactoryName} repository ({repo.Kind}).");
        sb.AppendLine($"   * @returns {interfaceType}<{modelSimpleName}, {keyType}>");
        sb.AppendLine($"   */");
        sb.AppendLine($"  get {repo.FactoryName}(): {interfaceType}<{modelSimpleName}, {keyType}> {{");
        sb.AppendLine($"    return RepositoryServices.{methodName}<{modelSimpleName}, {keyType}>('{repo.FactoryName}');");
        sb.AppendLine($"  }}{comma}");
        sb.AppendLine();
    }

    private static string GetPrimitiveKeyType(string keyName)
    {
        return keyName.ToLowerInvariant() switch
        {
            "int" or "int32" or "int64" or "long" or "short" or "byte" 
                or "float" or "double" or "decimal" => "number",
            "string" => "string",
            "guid" => "string",
            "bool" or "boolean" => "boolean",
            _ => "string"
        };
    }

    private static string GetSimpleName(string fullName)
    {
        var lastDot = fullName.LastIndexOf('.');
        return lastDot >= 0 ? fullName[(lastDot + 1)..] : fullName;
    }

    /// <summary>
    /// Gets the file name for the repository locator.
    /// </summary>
    public static string GetFileName() => "repositoryLocator.ts";

    /// <summary>
    /// Gets the folder where the repository locator should be placed.
    /// </summary>
    public static string GetFolder() => "services";
}
