using System.Text;
using RepositoryFramework.Tools.TypescriptGenerator.Domain;

namespace RepositoryFramework.Tools.TypescriptGenerator.Generation.Transformers;

/// <summary>
/// Emits ITransformer implementations for models and keys.
/// These transformers are used by RepositorySettings to convert between Raw and Clean types.
/// </summary>
public static class TransformerEmitter
{
    /// <summary>
    /// Emits a transformer file for a model or key type.
    /// </summary>
    public static string Emit(ModelDescriptor model, bool isKey = false)
    {
        if (model.IsEnum)
            return string.Empty;

        var sb = new StringBuilder();
        var baseName = model.GetBaseTypeName();
        var isGeneric = model.GenericTypeParameters.Count > 0;
        var genericParams = isGeneric 
            ? $"<{string.Join(", ", model.GenericTypeParameters)}>" 
            : "";
        var typeName = $"{baseName}{genericParams}";
        var typeNameRaw = $"{baseName}Raw{genericParams}";
        var fileNameWithoutExt = model.GetFileName().Replace(".ts", "");
        var suffix = isKey ? "Key" : "";

        // Header
        sb.AppendLine("// ============================================");
        sb.AppendLine($"// {baseName} Transformer");
        sb.AppendLine("// Auto-generated by Rystem TypeScript Generator");
        sb.AppendLine("// ============================================");
        sb.AppendLine();

        // Imports
        sb.AppendLine("import type { ITransformer } from 'rystem.repository.client';");
        if (isGeneric)
        {
            // For generics, import without type params (the interfaces are generic)
            sb.AppendLine($"import type {{ {baseName}, {baseName}Raw }} from '../types/{fileNameWithoutExt}';");
            sb.AppendLine($"import {{ mapRaw{baseName}To{baseName}, map{baseName}ToRaw{baseName} }} from '../types/{fileNameWithoutExt}';");
        }
        else
        {
            sb.AppendLine($"import type {{ {baseName}, {baseName}Raw }} from '../types/{fileNameWithoutExt}';");
            sb.AppendLine($"import {{ mapRaw{baseName}To{baseName}, map{baseName}ToRaw{baseName} }} from '../types/{fileNameWithoutExt}';");
        }
        sb.AppendLine();

        if (isGeneric)
        {
            // Generic types: use a factory function since const can't have type params
            sb.AppendLine("/**");
            sb.AppendLine($" * Creates a transformer for {baseName}<T> type.");
            sb.AppendLine(" * Converts between Raw (JSON) and Clean (TypeScript) representations.");
            sb.AppendLine(" */");
            sb.AppendLine($"export function create{baseName}Transformer{genericParams}(): ITransformer<{typeName}> {{");
            sb.AppendLine("  return {");
            sb.AppendLine($"    fromPlain: (plain: {typeNameRaw}): {typeName} => mapRaw{baseName}To{baseName}{genericParams}(plain),");
            sb.AppendLine($"    toPlain: (instance: {typeName}): {typeNameRaw} => map{baseName}ToRaw{baseName}{genericParams}(instance),");
            sb.AppendLine("  };");
            sb.AppendLine("}");
        }
        else
        {
            // Non-generic: const is fine
            sb.AppendLine("/**");
            sb.AppendLine($" * Transformer for {baseName} type.");
            sb.AppendLine(" * Converts between Raw (JSON) and Clean (TypeScript) representations.");
            sb.AppendLine(" */");
            sb.AppendLine($"export const {baseName}Transformer: ITransformer<{baseName}> = {{");
            sb.AppendLine($"  fromPlain: (plain: {baseName}Raw): {baseName} => mapRaw{baseName}To{baseName}(plain),");
            sb.AppendLine($"  toPlain: (instance: {baseName}): {baseName}Raw => map{baseName}ToRaw{baseName}(instance),");
            sb.AppendLine("};");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Gets the file name for a transformer.
    /// </summary>
    public static string GetFileName(ModelDescriptor model)
    {
        return $"{model.GetBaseTypeName()}Transformer.ts";
    }
}
