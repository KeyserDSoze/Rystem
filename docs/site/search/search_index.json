{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rystem Rystem is a open-source framework to improve .Net Help the project Reach out us on Discord Contribute Rystem (core library) You may find the code at this link Rystem.DependencyInjection (core library) You may find the code at this link Rystem.DependencyInjection.Web (core library) You may find the code at this link Concurrency (Deal with async Lock and Race Condition) You may find the code at this link Background job You may find the code at this link Queue You may find the code at this link Repository Framework (for Repository pattern or CQRS) You may find the code at this link Content Repository (Upload/Download files) You may find the code at this link Social Authentication (Blazor/Typescript) You may find the code at this link Api You may find the code at this link XUnitTest helper (Startup and helper for web integration tests) You may find the code at this link","title":"Home"},{"location":"#rystem","text":"Rystem is a open-source framework to improve .Net","title":"Rystem"},{"location":"#help-the-project","text":"Reach out us on Discord","title":"Help the project"},{"location":"#contribute","text":"","title":"Contribute"},{"location":"#rystem-core-library","text":"You may find the code at this link","title":"Rystem (core library)"},{"location":"#rystemdependencyinjection-core-library","text":"You may find the code at this link","title":"Rystem.DependencyInjection (core library)"},{"location":"#rystemdependencyinjectionweb-core-library","text":"You may find the code at this link","title":"Rystem.DependencyInjection.Web (core library)"},{"location":"#concurrency-deal-with-async-lock-and-race-condition","text":"You may find the code at this link","title":"Concurrency (Deal with async Lock and Race Condition)"},{"location":"#background-job","text":"You may find the code at this link","title":"Background job"},{"location":"#queue","text":"You may find the code at this link","title":"Queue"},{"location":"#repository-framework-for-repository-pattern-or-cqrs","text":"You may find the code at this link","title":"Repository Framework (for Repository pattern or CQRS)"},{"location":"#content-repository-uploaddownload-files","text":"You may find the code at this link","title":"Content Repository (Upload/Download files)"},{"location":"#social-authentication-blazortypescript","text":"You may find the code at this link","title":"Social Authentication (Blazor/Typescript)"},{"location":"#api","text":"You may find the code at this link","title":"Api"},{"location":"#xunittest-helper-startup-and-helper-for-web-integration-tests","text":"You may find the code at this link","title":"XUnitTest helper (Startup and helper for web integration tests)"},{"location":"Rystem.Api.Client.Authentication.BlazorServer/","text":"Services extensions HttpClient to use your API (example) You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); Default interceptor for Authentication with JWT You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); }); Remember to add builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme) .AddMicrosoftIdentityWebApp(builder.Configuration.GetSection(\"AzureAdB2C or AzureAd\")) .EnableTokenAcquisitionToCallDownstreamApi(new string[] { \"your_scope/access_as_user\" }) .AddInMemoryTokenCaches(); builder.Services.AddServerSideBlazor() .AddMicrosoftIdentityConsentHandler(); builder.Services.AddControllersWithViews() .AddMicrosoftIdentityUI();","title":"Rystem.Api.Client.Authentication.BlazorServer"},{"location":"Rystem.Api.Client.Authentication.BlazorServer/#services-extensions","text":"","title":"Services extensions"},{"location":"Rystem.Api.Client.Authentication.BlazorServer/#httpclient-to-use-your-api-example","text":"You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); });","title":"HttpClient to use your API (example)"},{"location":"Rystem.Api.Client.Authentication.BlazorServer/#default-interceptor-for-authentication-with-jwt","text":"You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); }); Remember to add builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme) .AddMicrosoftIdentityWebApp(builder.Configuration.GetSection(\"AzureAdB2C or AzureAd\")) .EnableTokenAcquisitionToCallDownstreamApi(new string[] { \"your_scope/access_as_user\" }) .AddInMemoryTokenCaches(); builder.Services.AddServerSideBlazor() .AddMicrosoftIdentityConsentHandler(); builder.Services.AddControllersWithViews() .AddMicrosoftIdentityUI();","title":"Default interceptor for Authentication with JWT"},{"location":"Rystem.Api.Client.Authentication.BlazorWasm/","text":"Services extensions HttpClient to use your API (example) You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); Default interceptor for Authentication with JWT You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); });","title":"Rystem.Api.Client.Authentication.BlazorWasm"},{"location":"Rystem.Api.Client.Authentication.BlazorWasm/#services-extensions","text":"","title":"Services extensions"},{"location":"Rystem.Api.Client.Authentication.BlazorWasm/#httpclient-to-use-your-api-example","text":"You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); });","title":"HttpClient to use your API (example)"},{"location":"Rystem.Api.Client.Authentication.BlazorWasm/#default-interceptor-for-authentication-with-jwt","text":"You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); });","title":"Default interceptor for Authentication with JWT"},{"location":"Rystem.Api.Client/","text":"","title":"Rystem.Api.Client"},{"location":"Rystem.Api.Server/","text":"","title":"Rystem.Api.Server"},{"location":"Rystem.Api/","text":"Rystem.Api This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection. How to use it","title":"Rystem.Api"},{"location":"Rystem.Api/#rystemapi","text":"This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection.","title":"Rystem.Api"},{"location":"Rystem.Api/#how-to-use-it","text":"","title":"How to use it"},{"location":"Rystem.Authentication.Social.Abstractions/","text":"Rystem.Authentication.Social This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection. How to use it You need to configure the social information and token settings, for instance the duration of your token. builder.Services.AddSocialLogin(x => { x.Google.ClientId = builder.Configuration[\"SocialLogin:Google:ClientId\"]; x.Google.ClientSecret = builder.Configuration[\"SocialLogin:Google:ClientSecret\"]; x.Google.RedirectDomain = builder.Configuration[\"SocialLogin:Google:RedirectDomain\"]; x.Microsoft.ClientId = builder.Configuration[\"SocialLogin:Microsoft:ClientId\"]; x.Microsoft.ClientSecret = builder.Configuration[\"SocialLogin:Microsoft:ClientSecret\"]; x.Microsoft.RedirectDomain = builder.Configuration[\"SocialLogin:Microsoft:RedirectDomain\"]; x.Facebook.ClientId = builder.Configuration[\"SocialLogin:Facebook:ClientId\"]; x.Facebook.ClientSecret = builder.Configuration[\"SocialLogin:Facebook:ClientSecret\"]; x.Facebook.RedirectDomain = builder.Configuration[\"SocialLogin:Facebook:RedirectDomain\"]; }, x => { x.BearerTokenExpiration = TimeSpan.FromHours(1); x.RefreshTokenExpiration = TimeSpan.FromDays(10); }); You need to add in the app builder section the endpoints app.UseSocialLoginEndpoints(); You can add your provider for user builder.Services.AddSocialUserProvider<SocialUserProvider>(); SocialUserProvider is a ISocialUserProvider, to call for instance a database or storage to fetch the information about the user with social username/email. internal sealed class SocialUserProvider : ISocialUserProvider { public Task<SocialUser> GetAsync(string username, IEnumerable<Claim> claims, CancellationToken cancellationToken) { return Task.FromResult(new SuperSocialUser { Username = $\"a {username}\", Email = username } as SocialUser); } public async IAsyncEnumerable<Claim> GetClaimsAsync(string? username, CancellationToken cancellationToken) { await Task.CompletedTask; yield return new Claim(ClaimTypes.Name, username!); yield return new Claim(ClaimTypes.Upn, \"something\"); } } public sealed class SuperSocialUser : SocialUser { public string Email { get; set; } }","title":"Rystem.Authentication.Social.Abstractions"},{"location":"Rystem.Authentication.Social.Abstractions/#rystemauthenticationsocial","text":"This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection.","title":"Rystem.Authentication.Social"},{"location":"Rystem.Authentication.Social.Abstractions/#how-to-use-it","text":"You need to configure the social information and token settings, for instance the duration of your token. builder.Services.AddSocialLogin(x => { x.Google.ClientId = builder.Configuration[\"SocialLogin:Google:ClientId\"]; x.Google.ClientSecret = builder.Configuration[\"SocialLogin:Google:ClientSecret\"]; x.Google.RedirectDomain = builder.Configuration[\"SocialLogin:Google:RedirectDomain\"]; x.Microsoft.ClientId = builder.Configuration[\"SocialLogin:Microsoft:ClientId\"]; x.Microsoft.ClientSecret = builder.Configuration[\"SocialLogin:Microsoft:ClientSecret\"]; x.Microsoft.RedirectDomain = builder.Configuration[\"SocialLogin:Microsoft:RedirectDomain\"]; x.Facebook.ClientId = builder.Configuration[\"SocialLogin:Facebook:ClientId\"]; x.Facebook.ClientSecret = builder.Configuration[\"SocialLogin:Facebook:ClientSecret\"]; x.Facebook.RedirectDomain = builder.Configuration[\"SocialLogin:Facebook:RedirectDomain\"]; }, x => { x.BearerTokenExpiration = TimeSpan.FromHours(1); x.RefreshTokenExpiration = TimeSpan.FromDays(10); }); You need to add in the app builder section the endpoints app.UseSocialLoginEndpoints(); You can add your provider for user builder.Services.AddSocialUserProvider<SocialUserProvider>(); SocialUserProvider is a ISocialUserProvider, to call for instance a database or storage to fetch the information about the user with social username/email. internal sealed class SocialUserProvider : ISocialUserProvider { public Task<SocialUser> GetAsync(string username, IEnumerable<Claim> claims, CancellationToken cancellationToken) { return Task.FromResult(new SuperSocialUser { Username = $\"a {username}\", Email = username } as SocialUser); } public async IAsyncEnumerable<Claim> GetClaimsAsync(string? username, CancellationToken cancellationToken) { await Task.CompletedTask; yield return new Claim(ClaimTypes.Name, username!); yield return new Claim(ClaimTypes.Upn, \"something\"); } } public sealed class SuperSocialUser : SocialUser { public string Email { get; set; } }","title":"How to use it"},{"location":"Rystem.Authentication.Social.Blazor/","text":"Rystem.Authentication.Social.Blazor This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection. Install javascript Setup js in app.razor in head or at the end <script src=\"_content/Rystem.Authentication.Social.Blazor/socialauthentications.js\"></script> DI - Example var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddRazorComponents() .AddInteractiveServerComponents(); builder.Services.AddSocialLoginUI(x => { x.ApiUrl = \"https://localhost:7017\"; x.Google.ClientId = builder.Configuration[\"SocialLogin:Google:ClientId\"]; x.Microsoft.ClientId = builder.Configuration[\"SocialLogin:Microsoft:ClientId\"]; }); builder.Services.AddRepository<SocialRole, string>(repositoryBuilder => { repositoryBuilder.WithApiClient(apiBuilder => { apiBuilder.WithHttpClient(\"https://localhost:7017\").WithDefaultRetryPolicy(); }); }); builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(\"/Error\", createScopeForErrors: true); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseAntiforgery(); app .MapRazorComponents<App>() .AddInteractiveServerRenderMode(); app.Run(); Example for Routes.razor <SocialAuthenticationRouter AppAssembly=\"typeof(Program).Assembly\" DefaultLayout=\"typeof(Layout.MainLayout)\"> </SocialAuthenticationRouter> Example for logout You may use the logout button <SocialLogout></SocialLogout> or create your custom logout through the SocialUser cascade parameter [CascadingParameter(Name = \"SocialUser\")] public SocialUserWrapper? SocialUser { get; set; } private async ValueTask LogoutAsync() { if (SocialUser != null) await SocialUser.LogoutAsync(false); }","title":"Rystem.Authentication.Social.Blazor"},{"location":"Rystem.Authentication.Social.Blazor/#rystemauthenticationsocialblazor","text":"This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection.","title":"Rystem.Authentication.Social.Blazor"},{"location":"Rystem.Authentication.Social.Blazor/#install-javascript","text":"Setup js in app.razor in head or at the end <script src=\"_content/Rystem.Authentication.Social.Blazor/socialauthentications.js\"></script>","title":"Install javascript"},{"location":"Rystem.Authentication.Social.Blazor/#di-example","text":"var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddRazorComponents() .AddInteractiveServerComponents(); builder.Services.AddSocialLoginUI(x => { x.ApiUrl = \"https://localhost:7017\"; x.Google.ClientId = builder.Configuration[\"SocialLogin:Google:ClientId\"]; x.Microsoft.ClientId = builder.Configuration[\"SocialLogin:Microsoft:ClientId\"]; }); builder.Services.AddRepository<SocialRole, string>(repositoryBuilder => { repositoryBuilder.WithApiClient(apiBuilder => { apiBuilder.WithHttpClient(\"https://localhost:7017\").WithDefaultRetryPolicy(); }); }); builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(\"/Error\", createScopeForErrors: true); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseAntiforgery(); app .MapRazorComponents<App>() .AddInteractiveServerRenderMode(); app.Run();","title":"DI - Example"},{"location":"Rystem.Authentication.Social.Blazor/#example-for-routesrazor","text":"<SocialAuthenticationRouter AppAssembly=\"typeof(Program).Assembly\" DefaultLayout=\"typeof(Layout.MainLayout)\"> </SocialAuthenticationRouter>","title":"Example for Routes.razor"},{"location":"Rystem.Authentication.Social.Blazor/#example-for-logout","text":"You may use the logout button <SocialLogout></SocialLogout> or create your custom logout through the SocialUser cascade parameter [CascadingParameter(Name = \"SocialUser\")] public SocialUserWrapper? SocialUser { get; set; } private async ValueTask LogoutAsync() { if (SocialUser != null) await SocialUser.LogoutAsync(false); }","title":"Example for logout"},{"location":"Rystem.Authentication.Social/","text":"Rystem.Authentication.Social This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection. How to use it You need to configure the social information and token settings, for instance the duration of your token. builder.Services.AddSocialLogin(x => { x.Google.ClientId = builder.Configuration[\"SocialLogin:Google:ClientId\"]; x.Google.ClientSecret = builder.Configuration[\"SocialLogin:Google:ClientSecret\"]; x.Google.RedirectDomain = builder.Configuration[\"SocialLogin:Google:RedirectDomain\"]; x.Microsoft.ClientId = builder.Configuration[\"SocialLogin:Microsoft:ClientId\"]; x.Microsoft.ClientSecret = builder.Configuration[\"SocialLogin:Microsoft:ClientSecret\"]; x.Microsoft.RedirectDomain = builder.Configuration[\"SocialLogin:Microsoft:RedirectDomain\"]; x.Facebook.ClientId = builder.Configuration[\"SocialLogin:Facebook:ClientId\"]; x.Facebook.ClientSecret = builder.Configuration[\"SocialLogin:Facebook:ClientSecret\"]; x.Facebook.RedirectDomain = builder.Configuration[\"SocialLogin:Facebook:RedirectDomain\"]; }, x => { x.BearerTokenExpiration = TimeSpan.FromHours(1); x.RefreshTokenExpiration = TimeSpan.FromDays(10); }); You need to add in the app builder section the endpoints app.UseSocialLoginEndpoints(); You can add your provider for user builder.Services.AddSocialUserProvider<SocialUserProvider>(); SocialUserProvider is a ISocialUserProvider, to call for instance a database or storage to fetch the information about the user with social username/email. internal sealed class SocialUserProvider : ISocialUserProvider { public Task<SocialUser> GetAsync(string username, IEnumerable<Claim> claims, CancellationToken cancellationToken) { return Task.FromResult(new SuperSocialUser { Username = $\"a {username}\", Email = username } as SocialUser); } public async IAsyncEnumerable<Claim> GetClaimsAsync(string? username, CancellationToken cancellationToken) { await Task.CompletedTask; yield return new Claim(ClaimTypes.Name, username!); yield return new Claim(ClaimTypes.Upn, \"something\"); } } public sealed class SuperSocialUser : SocialUser { public string Email { get; set; } }","title":"Rystem.Authentication.Social"},{"location":"Rystem.Authentication.Social/#rystemauthenticationsocial","text":"This project would be a super project to help the api creator to have fast api behind business interfaces and services dispatched through dependency injection.","title":"Rystem.Authentication.Social"},{"location":"Rystem.Authentication.Social/#how-to-use-it","text":"You need to configure the social information and token settings, for instance the duration of your token. builder.Services.AddSocialLogin(x => { x.Google.ClientId = builder.Configuration[\"SocialLogin:Google:ClientId\"]; x.Google.ClientSecret = builder.Configuration[\"SocialLogin:Google:ClientSecret\"]; x.Google.RedirectDomain = builder.Configuration[\"SocialLogin:Google:RedirectDomain\"]; x.Microsoft.ClientId = builder.Configuration[\"SocialLogin:Microsoft:ClientId\"]; x.Microsoft.ClientSecret = builder.Configuration[\"SocialLogin:Microsoft:ClientSecret\"]; x.Microsoft.RedirectDomain = builder.Configuration[\"SocialLogin:Microsoft:RedirectDomain\"]; x.Facebook.ClientId = builder.Configuration[\"SocialLogin:Facebook:ClientId\"]; x.Facebook.ClientSecret = builder.Configuration[\"SocialLogin:Facebook:ClientSecret\"]; x.Facebook.RedirectDomain = builder.Configuration[\"SocialLogin:Facebook:RedirectDomain\"]; }, x => { x.BearerTokenExpiration = TimeSpan.FromHours(1); x.RefreshTokenExpiration = TimeSpan.FromDays(10); }); You need to add in the app builder section the endpoints app.UseSocialLoginEndpoints(); You can add your provider for user builder.Services.AddSocialUserProvider<SocialUserProvider>(); SocialUserProvider is a ISocialUserProvider, to call for instance a database or storage to fetch the information about the user with social username/email. internal sealed class SocialUserProvider : ISocialUserProvider { public Task<SocialUser> GetAsync(string username, IEnumerable<Claim> claims, CancellationToken cancellationToken) { return Task.FromResult(new SuperSocialUser { Username = $\"a {username}\", Email = username } as SocialUser); } public async IAsyncEnumerable<Claim> GetClaimsAsync(string? username, CancellationToken cancellationToken) { await Task.CompletedTask; yield return new Claim(ClaimTypes.Name, username!); yield return new Claim(ClaimTypes.Upn, \"something\"); } } public sealed class SuperSocialUser : SocialUser { public string Email { get; set; } }","title":"How to use it"},{"location":"Rystem.BackgroundJob/","text":"Background job Background job is a library that helps to create a background thread in your application (webapp or similar). With the dependency injection pattern, you may set che CRON value (when your job has to run), link to create CRON . You may set to true the RunImmediately if you want to run one time during your bootstrap. You may set the Key to allow the possibility to have more than one job with the same class on the same instance. builder.Services.AddBackgroundJob<BackgroundJob>( x => { x.Cron = \"*/1 * * * *\"; x.RunImmediately = true; x.Key = \"alzo\"; }); Your class BackgroundJob has to extend IBackgrounJob and you may warm up it during the bootstrap. var app = builder.Build(); await app.Services.WarmUpAsync(); In IBackgroundJob you have ActionToDoAsync, it's the main method, called when the cron is fired; and OnException to catch the possibile exception during the main method run.","title":"Rystem.BackgroundJob"},{"location":"Rystem.BackgroundJob/#background-job","text":"Background job is a library that helps to create a background thread in your application (webapp or similar). With the dependency injection pattern, you may set che CRON value (when your job has to run), link to create CRON . You may set to true the RunImmediately if you want to run one time during your bootstrap. You may set the Key to allow the possibility to have more than one job with the same class on the same instance. builder.Services.AddBackgroundJob<BackgroundJob>( x => { x.Cron = \"*/1 * * * *\"; x.RunImmediately = true; x.Key = \"alzo\"; }); Your class BackgroundJob has to extend IBackgrounJob and you may warm up it during the bootstrap. var app = builder.Build(); await app.Services.WarmUpAsync(); In IBackgroundJob you have ActionToDoAsync, it's the main method, called when the cron is fired; and OnException to catch the possibile exception during the main method run.","title":"Background job"},{"location":"Rystem.Concurrency.Redis/","text":"Concurrency Async Lock A lock keyword is used in C# to lock a memory address to have a sort of execution queue. But, unfortunately, you cannot use async methods in the lock statement. With async lock you also may have the lock behavior for your async methods. In DI you have to add the lock service services.AddRedisLock(x => { x.ConnectionString = configuration[\"ConnectionString:Redis\"]!; }); Inject ILock and use it ILock locking = _serviceProvider.CreateScope().ServiceProvider.GetService<ILock>(); await locking!.ExecuteAsync(() => CountAsync(2), \"SampleKey\"); You have the method to execute, a key for more than one concurrent lock. Race condition First of all, you have to understand the race condition here In DI you have to add the lock service services.AddRaceConditionWithRedis(x => { x.ConnectionString = configuration[\"ConnectionString:Redis\"]!; }); Inject IRaceCodition and use it var raceCondition = _serviceProvider.CreateScope().ServiceProvider.GetService<IRaceCodition>(); raceCondition!.ExecuteAsync(() => CountAsync(2), (i % 2).ToString(), TimeSpan.FromSeconds(2)); You have the method to execute, a key for more than one concurrent race, and a time span for time window, if you put 2 seconds, you block the execution of further methods for 2 seconds from when first method started.","title":"Rystem.Concurrency.Redis"},{"location":"Rystem.Concurrency.Redis/#concurrency","text":"","title":"Concurrency"},{"location":"Rystem.Concurrency.Redis/#async-lock","text":"A lock keyword is used in C# to lock a memory address to have a sort of execution queue. But, unfortunately, you cannot use async methods in the lock statement. With async lock you also may have the lock behavior for your async methods. In DI you have to add the lock service services.AddRedisLock(x => { x.ConnectionString = configuration[\"ConnectionString:Redis\"]!; }); Inject ILock and use it ILock locking = _serviceProvider.CreateScope().ServiceProvider.GetService<ILock>(); await locking!.ExecuteAsync(() => CountAsync(2), \"SampleKey\"); You have the method to execute, a key for more than one concurrent lock.","title":"Async Lock"},{"location":"Rystem.Concurrency.Redis/#race-condition","text":"First of all, you have to understand the race condition here In DI you have to add the lock service services.AddRaceConditionWithRedis(x => { x.ConnectionString = configuration[\"ConnectionString:Redis\"]!; }); Inject IRaceCodition and use it var raceCondition = _serviceProvider.CreateScope().ServiceProvider.GetService<IRaceCodition>(); raceCondition!.ExecuteAsync(() => CountAsync(2), (i % 2).ToString(), TimeSpan.FromSeconds(2)); You have the method to execute, a key for more than one concurrent race, and a time span for time window, if you put 2 seconds, you block the execution of further methods for 2 seconds from when first method started.","title":"Race condition"},{"location":"Rystem.Concurrency/","text":"Concurrency Async Lock A lock keyword is used in C# to lock a memory address to have a sort of execution queue. But, unfortunately, you cannot use async methods in the lock statement. With async lock you also may have the lock behavior for your async methods. In DI you have to add the lock service services.AddLock(); Inject ILock and use it ILock locking = _serviceProvider.CreateScope().ServiceProvider.GetService<ILock>(); await locking!.ExecuteAsync(() => CountAsync(2), \"SampleKey\"); You have the method to execute, a key for more than one concurrent lock. Race condition First of all, you have to understand the race condition here In DI you have to add the lock service services.AddRaceCondition(); Inject IRaceCodition and use it var raceCondition = _serviceProvider.CreateScope().ServiceProvider.GetService<IRaceCodition>(); raceCondition!.ExecuteAsync(() => CountAsync(2), (i % 2).ToString(), TimeSpan.FromSeconds(2)); You have the method to execute, a key for more than one concurrent race, and a time span for time window, if you put 2 seconds, you block the execution of further methods for 2 seconds from when first method started. ILockable You can inject the ILockable interface for your purpose, like a distributed lock with Blob storage, or redis cache for instance. services.AddLockableIntegration<BlobLockIntegration>();","title":"Rystem.Concurrency"},{"location":"Rystem.Concurrency/#concurrency","text":"","title":"Concurrency"},{"location":"Rystem.Concurrency/#async-lock","text":"A lock keyword is used in C# to lock a memory address to have a sort of execution queue. But, unfortunately, you cannot use async methods in the lock statement. With async lock you also may have the lock behavior for your async methods. In DI you have to add the lock service services.AddLock(); Inject ILock and use it ILock locking = _serviceProvider.CreateScope().ServiceProvider.GetService<ILock>(); await locking!.ExecuteAsync(() => CountAsync(2), \"SampleKey\"); You have the method to execute, a key for more than one concurrent lock.","title":"Async Lock"},{"location":"Rystem.Concurrency/#race-condition","text":"First of all, you have to understand the race condition here In DI you have to add the lock service services.AddRaceCondition(); Inject IRaceCodition and use it var raceCondition = _serviceProvider.CreateScope().ServiceProvider.GetService<IRaceCodition>(); raceCondition!.ExecuteAsync(() => CountAsync(2), (i % 2).ToString(), TimeSpan.FromSeconds(2)); You have the method to execute, a key for more than one concurrent race, and a time span for time window, if you put 2 seconds, you block the execution of further methods for 2 seconds from when first method started.","title":"Race condition"},{"location":"Rystem.Concurrency/#ilockable","text":"You can inject the ILockable interface for your purpose, like a distributed lock with Blob storage, or redis cache for instance. services.AddLockableIntegration<BlobLockIntegration>();","title":"ILockable"},{"location":"Rystem.Content.Abstractions/","text":"Content Repository Abstractions You may use this library to help the integration with your business and your several storage repositories. Dependency injection services .AddContentRepository() .WithIntegration<SimpleIntegration>(\"example\", ServiceLifetime.Singleton); with integration class internal sealed class SimpleIntegration : IContentRepository { public ValueTask<bool> DeleteAsync(string path, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public Task<ContentRepositoryDownloadResult?> DownloadAsync(string path, ContentInformationType informationRetrieve = ContentInformationType.None, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public ValueTask<bool> ExistAsync(string path, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public Task<ContentRepositoryResult?> GetPropertiesAsync(string path, ContentInformationType informationRetrieve = ContentInformationType.All, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public IAsyncEnumerable<ContentRepositoryDownloadResult> ListAsync(string? prefix = null, bool downloadContent = false, ContentInformationType informationRetrieve = ContentInformationType.None, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public void SetName(string name) { throw new NotImplementedException(); } public ValueTask<bool> SetPropertiesAsync(string path, ContentRepositoryOptions? options = null, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public ValueTask<bool> UploadAsync(string path, byte[] data, ContentRepositoryOptions? options = null, bool overwrite = true, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } } How to use If you have only one integration installed at once, you may inject directly public sealed class SimpleBusiness { private readonly IContentRepository _contentRepository; public SimpleBusiness(IContentRepository contentRepository) { _contentRepository = contentRepository; } } In case of multiple integrations you have to use the factory service DI services .AddContentRepository() .WithIntegration<SimpleIntegration>(\"example\", ServiceLifetime.Singleton); .WithIntegration<SimpleIntegration2>(\"example2\", ServiceLifetime.Singleton); in Business class to use the first integration public sealed class SimpleBusiness { private readonly IContentRepository _contentRepository; public SimpleBusiness(IContentRepositoryFactory contentRepositoryFactory) { _contentRepository = contentRepositoryFactory.Create(\"example\"); } } in Business class to use the second integration public sealed class SimpleBusiness { private readonly IContentRepository _contentRepository; public SimpleBusiness(IContentRepositoryFactory contentRepositoryFactory) { _contentRepository = contentRepositoryFactory.Create(\"example2\"); } } Migration tool You can migrate from two different sources. For instance from a blob storage to a sharepoint site document library. Setup in DI services .AddSingleton<Utility>() .AddContentRepository() .WithBlobStorageIntegrationAsync(x => { x.ContainerName = \"supertest\"; x.Prefix = \"site/\"; x.ConnectionString = configuration[\"ConnectionString:Storage\"]; }, \"blobstorage\") .ToResult() .WithInMemoryIntegration(\"inmemory\") .WithSharepointIntegrationAsync(x => { x.TenantId = configuration[\"Sharepoint:TenantId\"]; x.ClientId = configuration[\"Sharepoint:ClientId\"]; x.ClientSecret = configuration[\"Sharepoint:ClientSecret\"]; x.MapWithSiteNameAndDocumentLibraryName(\"TestNumberOne\", \"Foglione\"); }, \"sharepoint\") .ToResult(); Usage var result = await _contentMigration.MigrateAsync(\"blobstorage\", \"sharepoint\", settings => { settings.OverwriteIfExists = true; settings.Prefix = prefix; settings.Predicate = (x) => { return x.Path?.Contains(\"fileName6\") != true; }; settings.ModifyDestinationPath = x => { return x.Replace(\"Folder2\", \"Folder3\"); }; }).NoContext();","title":"Rystem.Content.Abstractions"},{"location":"Rystem.Content.Abstractions/#content-repository-abstractions","text":"You may use this library to help the integration with your business and your several storage repositories.","title":"Content Repository Abstractions"},{"location":"Rystem.Content.Abstractions/#dependency-injection","text":"services .AddContentRepository() .WithIntegration<SimpleIntegration>(\"example\", ServiceLifetime.Singleton); with integration class internal sealed class SimpleIntegration : IContentRepository { public ValueTask<bool> DeleteAsync(string path, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public Task<ContentRepositoryDownloadResult?> DownloadAsync(string path, ContentInformationType informationRetrieve = ContentInformationType.None, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public ValueTask<bool> ExistAsync(string path, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public Task<ContentRepositoryResult?> GetPropertiesAsync(string path, ContentInformationType informationRetrieve = ContentInformationType.All, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public IAsyncEnumerable<ContentRepositoryDownloadResult> ListAsync(string? prefix = null, bool downloadContent = false, ContentInformationType informationRetrieve = ContentInformationType.None, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public void SetName(string name) { throw new NotImplementedException(); } public ValueTask<bool> SetPropertiesAsync(string path, ContentRepositoryOptions? options = null, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } public ValueTask<bool> UploadAsync(string path, byte[] data, ContentRepositoryOptions? options = null, bool overwrite = true, CancellationToken cancellationToken = default) { throw new NotImplementedException(); } }","title":"Dependency injection"},{"location":"Rystem.Content.Abstractions/#how-to-use","text":"If you have only one integration installed at once, you may inject directly public sealed class SimpleBusiness { private readonly IContentRepository _contentRepository; public SimpleBusiness(IContentRepository contentRepository) { _contentRepository = contentRepository; } }","title":"How to use"},{"location":"Rystem.Content.Abstractions/#in-case-of-multiple-integrations-you-have-to-use-the-factory-service","text":"DI services .AddContentRepository() .WithIntegration<SimpleIntegration>(\"example\", ServiceLifetime.Singleton); .WithIntegration<SimpleIntegration2>(\"example2\", ServiceLifetime.Singleton); in Business class to use the first integration public sealed class SimpleBusiness { private readonly IContentRepository _contentRepository; public SimpleBusiness(IContentRepositoryFactory contentRepositoryFactory) { _contentRepository = contentRepositoryFactory.Create(\"example\"); } } in Business class to use the second integration public sealed class SimpleBusiness { private readonly IContentRepository _contentRepository; public SimpleBusiness(IContentRepositoryFactory contentRepositoryFactory) { _contentRepository = contentRepositoryFactory.Create(\"example2\"); } }","title":"In case of multiple integrations you have to use the factory service"},{"location":"Rystem.Content.Abstractions/#migration-tool","text":"You can migrate from two different sources. For instance from a blob storage to a sharepoint site document library. Setup in DI services .AddSingleton<Utility>() .AddContentRepository() .WithBlobStorageIntegrationAsync(x => { x.ContainerName = \"supertest\"; x.Prefix = \"site/\"; x.ConnectionString = configuration[\"ConnectionString:Storage\"]; }, \"blobstorage\") .ToResult() .WithInMemoryIntegration(\"inmemory\") .WithSharepointIntegrationAsync(x => { x.TenantId = configuration[\"Sharepoint:TenantId\"]; x.ClientId = configuration[\"Sharepoint:ClientId\"]; x.ClientSecret = configuration[\"Sharepoint:ClientSecret\"]; x.MapWithSiteNameAndDocumentLibraryName(\"TestNumberOne\", \"Foglione\"); }, \"sharepoint\") .ToResult(); Usage var result = await _contentMigration.MigrateAsync(\"blobstorage\", \"sharepoint\", settings => { settings.OverwriteIfExists = true; settings.Prefix = prefix; settings.Predicate = (x) => { return x.Path?.Contains(\"fileName6\") != true; }; settings.ModifyDestinationPath = x => { return x.Replace(\"Folder2\", \"Folder3\"); }; }).NoContext();","title":"Migration tool"},{"location":"Rystem.Content.Infrastructure.InMemory/","text":"Integration with In Memory and Content Repository services .AddContentRepository() .WithInMemoryIntegration(\"inmemory\"); How to use in a business class public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"inmemory\"); var file = await _utility.GetFileAsync(); var name = \"file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"Rystem.Content.Infrastructure.InMemory"},{"location":"Rystem.Content.Infrastructure.InMemory/#integration-with-in-memory-and-content-repository","text":"services .AddContentRepository() .WithInMemoryIntegration(\"inmemory\");","title":"Integration with In Memory and Content Repository"},{"location":"Rystem.Content.Infrastructure.InMemory/#how-to-use-in-a-business-class","text":"public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"inmemory\"); var file = await _utility.GetFileAsync(); var name = \"file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"How to use in a business class"},{"location":"Rystem.Content.Infrastructure.M365.Sharepoint/","text":"Get information https:// .sharepoint.com/sites/ /_api/site/id Integration with Sharepoint online and Content Repository await services .AddContentRepository() .WithSharepointIntegrationAsync(x => { x.TenantId = configuration[\"Sharepoint:TenantId\"]; x.ClientId = configuration[\"Sharepoint:ClientId\"]; x.ClientSecret = configuration[\"Sharepoint:ClientSecret\"]; x.MapWithSiteNameAndDocumentLibraryName(\"TestNumberOne\", \"Foglione\"); //x.MapWithRootSiteAndDocumentLibraryName(\"Foglione\"); //x.MapWithSiteIdAndDocumentLibraryId(configuration[\"Sharepoint:SiteId\"], // configuration[\"Sharepoint:DocumentLibraryId\"]); }, \"sharepoint\") .NoContext(); How to use in a business class public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"sharepoint\"); var file = await _utility.GetFileAsync(); var name = \"folder/file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"Rystem.Content.Infrastructure.M365.Sharepoint"},{"location":"Rystem.Content.Infrastructure.M365.Sharepoint/#get-information","text":"https:// .sharepoint.com/sites/ /_api/site/id","title":"Get information"},{"location":"Rystem.Content.Infrastructure.M365.Sharepoint/#integration-with-sharepoint-online-and-content-repository","text":"await services .AddContentRepository() .WithSharepointIntegrationAsync(x => { x.TenantId = configuration[\"Sharepoint:TenantId\"]; x.ClientId = configuration[\"Sharepoint:ClientId\"]; x.ClientSecret = configuration[\"Sharepoint:ClientSecret\"]; x.MapWithSiteNameAndDocumentLibraryName(\"TestNumberOne\", \"Foglione\"); //x.MapWithRootSiteAndDocumentLibraryName(\"Foglione\"); //x.MapWithSiteIdAndDocumentLibraryId(configuration[\"Sharepoint:SiteId\"], // configuration[\"Sharepoint:DocumentLibraryId\"]); }, \"sharepoint\") .NoContext();","title":"Integration with Sharepoint online and Content Repository"},{"location":"Rystem.Content.Infrastructure.M365.Sharepoint/#how-to-use-in-a-business-class","text":"public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"sharepoint\"); var file = await _utility.GetFileAsync(); var name = \"folder/file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"How to use in a business class"},{"location":"Rystem.Content.Infrastructure.Storage.Blob/","text":"Integration with Azure BlobStorage and Content Repository await services .AddContentRepository() .WithBlobStorageIntegrationAsync(x => { x.ContainerName = \"supertest\"; x.Prefix = \"site/\"; x.ConnectionString = configuration[\"ConnectionString:Storage\"]; }, \"blobstorage\") .NoContext(); How to use in a business class public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"blobstorage\"); var file = await _utility.GetFileAsync(); var name = \"folder/file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"Rystem.Content.Infrastructure.Storage.Blob"},{"location":"Rystem.Content.Infrastructure.Storage.Blob/#integration-with-azure-blobstorage-and-content-repository","text":"await services .AddContentRepository() .WithBlobStorageIntegrationAsync(x => { x.ContainerName = \"supertest\"; x.Prefix = \"site/\"; x.ConnectionString = configuration[\"ConnectionString:Storage\"]; }, \"blobstorage\") .NoContext();","title":"Integration with Azure BlobStorage and Content Repository"},{"location":"Rystem.Content.Infrastructure.Storage.Blob/#how-to-use-in-a-business-class","text":"public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"blobstorage\"); var file = await _utility.GetFileAsync(); var name = \"folder/file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"How to use in a business class"},{"location":"Rystem.Content.Infrastructure.Storage.File/","text":"Integration with Azure File Storage and Content Repository await services .AddContentRepository() .WithFileStorageIntegrationAsync(x => { x.ShareName = \"supertest\"; x.Prefix = \"site/\"; x.ConnectionString = configuration[\"ConnectionString:Storage\"]; }, \"filestorage\") .NoContext(); How to use in a business class public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"filestorage\"); var file = await _utility.GetFileAsync(); var name = \"folder/file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"Rystem.Content.Infrastructure.Storage.File"},{"location":"Rystem.Content.Infrastructure.Storage.File/#integration-with-azure-file-storage-and-content-repository","text":"await services .AddContentRepository() .WithFileStorageIntegrationAsync(x => { x.ShareName = \"supertest\"; x.Prefix = \"site/\"; x.ConnectionString = configuration[\"ConnectionString:Storage\"]; }, \"filestorage\") .NoContext();","title":"Integration with Azure File Storage and Content Repository"},{"location":"Rystem.Content.Infrastructure.Storage.File/#how-to-use-in-a-business-class","text":"public class AllStorageTest { private readonly IContentRepositoryFactory _contentRepositoryFactory; private readonly Utility _utility; public AllStorageTest(IContentRepositoryFactory contentRepositoryFactory, Utility utility) { _contentRepositoryFactory = contentRepositoryFactory; _utility = utility; } public async Task ExecuteAsync() { var _contentRepository = _contentRepositoryFactory.Create(\"filestorage\"); var file = await _utility.GetFileAsync(); var name = \"folder/file.png\"; var contentType = \"images/png\"; var metadata = new Dictionary<string, string>() { { \"name\", \"ale\" } }; var tags = new Dictionary<string, string>() { { \"version\", \"1\" } }; var response = await _contentRepository.ExistAsync(name).NoContext(); if (response) { await _contentRepository.DeleteAsync(name).NoContext(); response = await _contentRepository.ExistAsync(name).NoContext(); } Assert.False(response); response = await _contentRepository.UploadAsync(name, file.ToArray(), new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }, true).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.True(response); var options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.NotNull(options.Uri); foreach (var x in metadata) { Assert.Equal(x.Value, options.Options.Metadata[x.Key]); } foreach (var x in tags) { Assert.Equal(x.Value, options.Options.Tags[x.Key]); } Assert.Equal(contentType, options.Options.HttpHeaders.ContentType); metadata.Add(\"ale2\", \"single\"); response = await _contentRepository.SetPropertiesAsync(name, new ContentRepositoryOptions { HttpHeaders = new ContentRepositoryHttpHeaders { ContentType = contentType }, Metadata = metadata, Tags = tags }).NoContext(); Assert.True(response); options = await _contentRepository.GetPropertiesAsync(name, ContentInformationType.All).NoContext(); Assert.Equal(\"single\", options.Options.Metadata[\"ale2\"]); response = await _contentRepository.DeleteAsync(name).NoContext(); Assert.True(response); response = await _contentRepository.ExistAsync(name).NoContext(); Assert.False(response); } }","title":"How to use in a business class"},{"location":"Rystem.DependencyInjection.Web/","text":"Adding runtime provider builder.Services.AddRuntimeServiceProvider(); and after the build use the runtime provider var app = builder.Build(); app.UseRuntimeServiceProvider(); Add service at runtime await RuntimeServiceProvider.GetServiceCollection() .AddSingleton<Service2>() .RebuildAsync(); Add service at runtime with lock await RuntimeServiceProvider .AddServicesToServiceCollectionWithLock(configureFurtherServices => { configureFurtherServices.AddSingleton(service); }) .RebuildAsync(); Add fallback for Factory and automatic rebuild of service collection In this example Factorized is a simple class with a few parameters. services.AddFactory<Factorized>(\"1\"); services.AddActionAsFallbackWithServiceCollectionRebuilding<Factorized>(async x => { //example of retrievieng something await Task.Delay(1); //example of ServiceProvider usage during new service addition var singletonService = x.ServiceProvider.GetService<SingletonService>(); if (singletonService != null) { //example of adding a new service as factory to the service collection. You need to pass a delegate. x.ServiceColletionBuilder = (serviceCollection => serviceCollection.AddFactory<Factorized>(x.Name)); } });","title":"Rystem.DependencyInjection.Web"},{"location":"Rystem.DependencyInjection.Web/#adding-runtime-provider","text":"builder.Services.AddRuntimeServiceProvider(); and after the build use the runtime provider var app = builder.Build(); app.UseRuntimeServiceProvider();","title":"Adding runtime provider"},{"location":"Rystem.DependencyInjection.Web/#add-service-at-runtime","text":"await RuntimeServiceProvider.GetServiceCollection() .AddSingleton<Service2>() .RebuildAsync();","title":"Add service at runtime"},{"location":"Rystem.DependencyInjection.Web/#add-service-at-runtime-with-lock","text":"await RuntimeServiceProvider .AddServicesToServiceCollectionWithLock(configureFurtherServices => { configureFurtherServices.AddSingleton(service); }) .RebuildAsync();","title":"Add service at runtime with lock"},{"location":"Rystem.DependencyInjection.Web/#add-fallback-for-factory-and-automatic-rebuild-of-service-collection","text":"In this example Factorized is a simple class with a few parameters. services.AddFactory<Factorized>(\"1\"); services.AddActionAsFallbackWithServiceCollectionRebuilding<Factorized>(async x => { //example of retrievieng something await Task.Delay(1); //example of ServiceProvider usage during new service addition var singletonService = x.ServiceProvider.GetService<SingletonService>(); if (singletonService != null) { //example of adding a new service as factory to the service collection. You need to pass a delegate. x.ServiceColletionBuilder = (serviceCollection => serviceCollection.AddFactory<Factorized>(x.Name)); } });","title":"Add fallback for Factory and automatic rebuild of service collection"},{"location":"Rystem.DependencyInjection/","text":"Dependency injection extensions Warm up When you use the DI pattern in your .Net application you could need a warm up after the build of your services. And with Rystem you can simply do it. builder.Services.AddWarmUp(() => somethingToDo()); and after the build use the warm up var app = builder.Build(); await app.Services.WarmUpAsync(); Population service You can use the population service to create a list of random value of a specific Type. An example from unit test explains how to use the service. IServiceCollection services = new ServiceCollection(); services.AddPopulationService(); var serviceProvider = services.BuildServiceProvider().CreateScope().ServiceProvider; var populatedModel = serviceProvider.GetService<IPopulation<PopulationModelTest>>(); IPopulation<PopulationModelTest> allPrepopulation = populatedModel! .Setup() .WithPattern(x => x.J!.First().A, \"[a-z]{4,5}\") .WithPattern(x => x.Y!.First().Value.A, \"[a-z]{4,5}\") .WithImplementation(x => x.I, typeof(MyInnerInterfaceImplementation)) .WithPattern(x => x.I!.A!, \"[a-z]{4,5}\") .WithPattern(x => x.II!.A!, \"[a-z]{4,5}\") .WithImplementation<IInnerInterface, MyInnerInterfaceImplementation>(x => x.I!); var all = allPrepopulation.Populate(); Abstract factory You can use this abstract factory solution when you need to setup more than one service of the same kind and you need to distinguish them by a name. I have an interface public interface IMyService { string GetName(); } Some options for every service public class SingletonOption { public string ServiceName { get; set; } } public class TransientOption { public string ServiceName { get; set; } } public class ScopedOption { public string ServiceName { get; set; } } with built options which is a IServiceOptions, a options class that ends up with another class. Used for example when you have to add a settings like a connection string but you want to use a service like a client that uses that connection string. public class BuiltScopedOptions : IServiceOptions<ScopedOption> { public string ServiceName { get; set; } public Task<Func<ScopedOption>> BuildAsync() { return Task.FromResult(() => new ScopedOption { ServiceName = ServiceName }); } } And six different services public class SingletonService : IMyService, IServiceWithOptions<SingletonOption> { public SingletonOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class TransientService : IMyService, IServiceWithOptions<TransientOption> { public TransientOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService2 : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService3 : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService4 : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } I can setup them in this way var services = new ServiceCollection(); services.AddFactory<IMyService, SingletonService, SingletonOption>(x => { x.ServiceName = \"singleton\"; }, \"singleton\", ServiceLifetime.Singleton); services.AddFactory<IMyService, TransientService, TransientOption>(x => { x.ServiceName = \"transient\"; }, \"transient\", ServiceLifetime.Transient); services.AddFactory<IMyService, ScopedService, ScopedOption>(x => { x.ServiceName = \"scoped\"; }, \"scoped\", ServiceLifetime.Scoped); services.AddFactory<IMyService, ScopedService2, ScopedOption>(x => { x.ServiceName = \"scoped2\"; }, \"scoped2\", ServiceLifetime.Scoped); await services.AddFactoryAsync<IMyService, ScopedService3, BuiltScopedOptions, ScopedOption>( x => { x.ServiceName = \"scoped3\"; }, \"scoped3\" ); await services.AddFactoryAsync<IMyService, ScopedService3, BuiltScopedOptions, ScopedOption>( x => { x.ServiceName = \"scoped3_2\"; }, \"scoped3_2\" ); await services.AddFactoryAsync<IMyService, ScopedService4, BuiltScopedOptions, ScopedOption>( x => { x.ServiceName = \"scoped4\"; }, \"scoped4\" ); and use them in this way var serviceProvider = services.BuildServiceProvider().CreateScope().ServiceProvider; var factory = serviceProvider.GetService<IFactory<IMyService>>()!; var factory2 = serviceProvider.GetService<IFactory<IMyService>>()!; var singletonFromFactory = factory.Create(\"singleton\").Id; var singletonFromFactory2 = factory2.Create(\"singleton\").Id; var transientFromFactory = factory.Create(\"transient\").Id; var transientFromFactory2 = factory2.Create(\"transient\").Id; var scopedFromFactory = factory.Create(\"scoped\").Id; var scopedFromFactory2 = factory2.Create(\"scoped\").Id; var scoped2FromFactory = factory.Create(\"scoped2\").Id; var scoped2FromFactory2 = factory2.Create(\"scoped2\").Id; var scoped3FromFactory = factory.Create(\"scoped3\").Id; var scoped3FromFactory2 = factory2.Create(\"scoped3\").Id; var scoped3_2FromFactory = factory.Create(\"scoped3_2\").Id; var scoped3_2FromFactory2 = factory2.Create(\"scoped3_2\").Id; var scoped4FromFactory = factory.Create(\"scoped4\").Id; var scoped4FromFactory2 = factory2.Create(\"scoped4\").Id; Assert.Equal(singletonFromFactory, singletonFromFactory2); Assert.NotEqual(transientFromFactory, transientFromFactory2); Assert.Equal(scopedFromFactory, scopedFromFactory2); Assert.Equal(scoped2FromFactory, scoped2FromFactory2); Assert.NotEqual(scoped3FromFactory, scoped3FromFactory2); Assert.NotEqual(scoped3_2FromFactory, scoped3_2FromFactory2); Assert.NotEqual(scoped4FromFactory, scoped4FromFactory2); Decorator You may add a decoration for your services, based on the abstract factory integration. The decorator service replaces the previous version and receives it during the injection. Setup services .AddService<ITestWithoutFactoryService, TestWithoutFactoryService>(lifetime); services .AddDecoration<ITestWithoutFactoryService, TestWithoutFactoryServiceDecorator>(null, lifetime); Usage var decorator = provider.GetRequiredService<ITestWithoutFactoryService>(); var previousService = provider.GetRequiredService<IDecoratedService<ITestWithoutFactoryService>>(); In decorator you may find the previousService in the method SetDecoratedService which runs in injection public class TestWithoutFactoryServiceDecorator : ITestWithoutFactoryService, IDecoratorService<ITestWithoutFactoryService> { public string Id { get; } = Guid.NewGuid().ToString(); public ITestWithoutFactoryService Test { get; private set; } public void SetDecoratedService(ITestWithoutFactoryService service) { Test = service; } public void SetFactoryName(string name) { return; } } Decorator with Abstract Factory integration You may add a decoration only for one service of your factory integration. Setup services.AddFactory<ITestService, TestService, TestOptions>(x => { x.ClassicName = classicName; }, factoryName, lifetime); services .AddDecoration<ITestService, DecoratorTestService>(factoryName, lifetime); Usage var decoratorFactory = provider.GetRequiredService<IFactory<ITestService>>(); var decorator = decoratorFactory.Create(factoryName); var previousService = decoratorFactory.CreateWithoutDecoration(factoryName); Factory Fallback You may add a fallback for your factory integration. The fallback service is called when the factory service key is not found. services.AddFactoryFallback<TService, TFactoryFallback>(); where TFactoryFallback is class and an IFactoryFallback You may add a fallback with an action fallback too. services.AddActionAsFallbackWithServiceProvider<TService>(Func<FallbackBuilderForServiceProvider, TService> fallbackBuilder); Scan dependency injection You may scan your assemblies in search of types you need to add to dependency injection. For instance I have an interface IAnything and I need to add all classes which implements it. public interface IAnything { } internal class ScanModels : IAnything { } and in service collection I can add it. serviceCollection .Scan<IAnything>(ServiceLifetime.Scoped, typeof(IAnything).Assembly); I can add to my class the interface IScannable of T to scan automatically. For instance. public interface IAnything { } internal class ScanModels : IAnything, IScannable<IAnything> { } and in service collection I could add it in this way serviceCollection .Scan(ServiceLifetime.Scoped, typeof(IAnything).Assembly); Furthermore with ISingletonScannable, IScopedScannable and ITransientScannable I can override the service lifetime. For instance. public interface IAnything { } internal class ScanModels : IAnything, IScannable<IAnything>, ISingletonScannable { } serviceCollection .Scan(ServiceLifetime.Scoped, typeof(IAnything).Assembly); ScanModels will be installed as a Singleton service, overwriting the service lifetime from Scan method. You also automatically use different assembly sources. serviceCollection .ScanDependencyContext(ServiceLifetime.Scoped); or serviceCollection .ScanCallingAssembly(ServiceLifetime.Scoped); or serviceCollection .ScanCurrentDomain(ServiceLifetime.Scoped); or serviceCollection .ScanEntryAssembly(ServiceLifetime.Scoped); or serviceCollection .ScanExecutingAssembly(ServiceLifetime.Scoped); or serviceCollection .ScanFromType<T>(ServiceLifetime.Scoped); or serviceCollection .ScanFromTypes<T1, T2>(ServiceLifetime.Scoped); Finally with ScanWithReferences you may call all the assemblies you want plus all referenced assemblies by them.","title":"Rystem.DependencyInjection"},{"location":"Rystem.DependencyInjection/#dependency-injection-extensions","text":"","title":"Dependency injection extensions"},{"location":"Rystem.DependencyInjection/#warm-up","text":"When you use the DI pattern in your .Net application you could need a warm up after the build of your services. And with Rystem you can simply do it. builder.Services.AddWarmUp(() => somethingToDo()); and after the build use the warm up var app = builder.Build(); await app.Services.WarmUpAsync();","title":"Warm up"},{"location":"Rystem.DependencyInjection/#population-service","text":"You can use the population service to create a list of random value of a specific Type. An example from unit test explains how to use the service. IServiceCollection services = new ServiceCollection(); services.AddPopulationService(); var serviceProvider = services.BuildServiceProvider().CreateScope().ServiceProvider; var populatedModel = serviceProvider.GetService<IPopulation<PopulationModelTest>>(); IPopulation<PopulationModelTest> allPrepopulation = populatedModel! .Setup() .WithPattern(x => x.J!.First().A, \"[a-z]{4,5}\") .WithPattern(x => x.Y!.First().Value.A, \"[a-z]{4,5}\") .WithImplementation(x => x.I, typeof(MyInnerInterfaceImplementation)) .WithPattern(x => x.I!.A!, \"[a-z]{4,5}\") .WithPattern(x => x.II!.A!, \"[a-z]{4,5}\") .WithImplementation<IInnerInterface, MyInnerInterfaceImplementation>(x => x.I!); var all = allPrepopulation.Populate();","title":"Population service"},{"location":"Rystem.DependencyInjection/#abstract-factory","text":"You can use this abstract factory solution when you need to setup more than one service of the same kind and you need to distinguish them by a name. I have an interface public interface IMyService { string GetName(); } Some options for every service public class SingletonOption { public string ServiceName { get; set; } } public class TransientOption { public string ServiceName { get; set; } } public class ScopedOption { public string ServiceName { get; set; } } with built options which is a IServiceOptions, a options class that ends up with another class. Used for example when you have to add a settings like a connection string but you want to use a service like a client that uses that connection string. public class BuiltScopedOptions : IServiceOptions<ScopedOption> { public string ServiceName { get; set; } public Task<Func<ScopedOption>> BuildAsync() { return Task.FromResult(() => new ScopedOption { ServiceName = ServiceName }); } } And six different services public class SingletonService : IMyService, IServiceWithOptions<SingletonOption> { public SingletonOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class TransientService : IMyService, IServiceWithOptions<TransientOption> { public TransientOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService2 : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService3 : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } public class ScopedService4 : IMyService, IServiceWithOptions<ScopedOption> { public ScopedOption Options { get; set; } public string Id { get; } = Guid.NewGuid().ToString(); public string GetName() { return $\"{Options.ServiceName} with id {Id}\"; } } I can setup them in this way var services = new ServiceCollection(); services.AddFactory<IMyService, SingletonService, SingletonOption>(x => { x.ServiceName = \"singleton\"; }, \"singleton\", ServiceLifetime.Singleton); services.AddFactory<IMyService, TransientService, TransientOption>(x => { x.ServiceName = \"transient\"; }, \"transient\", ServiceLifetime.Transient); services.AddFactory<IMyService, ScopedService, ScopedOption>(x => { x.ServiceName = \"scoped\"; }, \"scoped\", ServiceLifetime.Scoped); services.AddFactory<IMyService, ScopedService2, ScopedOption>(x => { x.ServiceName = \"scoped2\"; }, \"scoped2\", ServiceLifetime.Scoped); await services.AddFactoryAsync<IMyService, ScopedService3, BuiltScopedOptions, ScopedOption>( x => { x.ServiceName = \"scoped3\"; }, \"scoped3\" ); await services.AddFactoryAsync<IMyService, ScopedService3, BuiltScopedOptions, ScopedOption>( x => { x.ServiceName = \"scoped3_2\"; }, \"scoped3_2\" ); await services.AddFactoryAsync<IMyService, ScopedService4, BuiltScopedOptions, ScopedOption>( x => { x.ServiceName = \"scoped4\"; }, \"scoped4\" ); and use them in this way var serviceProvider = services.BuildServiceProvider().CreateScope().ServiceProvider; var factory = serviceProvider.GetService<IFactory<IMyService>>()!; var factory2 = serviceProvider.GetService<IFactory<IMyService>>()!; var singletonFromFactory = factory.Create(\"singleton\").Id; var singletonFromFactory2 = factory2.Create(\"singleton\").Id; var transientFromFactory = factory.Create(\"transient\").Id; var transientFromFactory2 = factory2.Create(\"transient\").Id; var scopedFromFactory = factory.Create(\"scoped\").Id; var scopedFromFactory2 = factory2.Create(\"scoped\").Id; var scoped2FromFactory = factory.Create(\"scoped2\").Id; var scoped2FromFactory2 = factory2.Create(\"scoped2\").Id; var scoped3FromFactory = factory.Create(\"scoped3\").Id; var scoped3FromFactory2 = factory2.Create(\"scoped3\").Id; var scoped3_2FromFactory = factory.Create(\"scoped3_2\").Id; var scoped3_2FromFactory2 = factory2.Create(\"scoped3_2\").Id; var scoped4FromFactory = factory.Create(\"scoped4\").Id; var scoped4FromFactory2 = factory2.Create(\"scoped4\").Id; Assert.Equal(singletonFromFactory, singletonFromFactory2); Assert.NotEqual(transientFromFactory, transientFromFactory2); Assert.Equal(scopedFromFactory, scopedFromFactory2); Assert.Equal(scoped2FromFactory, scoped2FromFactory2); Assert.NotEqual(scoped3FromFactory, scoped3FromFactory2); Assert.NotEqual(scoped3_2FromFactory, scoped3_2FromFactory2); Assert.NotEqual(scoped4FromFactory, scoped4FromFactory2);","title":"Abstract factory"},{"location":"Rystem.DependencyInjection/#decorator","text":"You may add a decoration for your services, based on the abstract factory integration. The decorator service replaces the previous version and receives it during the injection. Setup services .AddService<ITestWithoutFactoryService, TestWithoutFactoryService>(lifetime); services .AddDecoration<ITestWithoutFactoryService, TestWithoutFactoryServiceDecorator>(null, lifetime); Usage var decorator = provider.GetRequiredService<ITestWithoutFactoryService>(); var previousService = provider.GetRequiredService<IDecoratedService<ITestWithoutFactoryService>>(); In decorator you may find the previousService in the method SetDecoratedService which runs in injection public class TestWithoutFactoryServiceDecorator : ITestWithoutFactoryService, IDecoratorService<ITestWithoutFactoryService> { public string Id { get; } = Guid.NewGuid().ToString(); public ITestWithoutFactoryService Test { get; private set; } public void SetDecoratedService(ITestWithoutFactoryService service) { Test = service; } public void SetFactoryName(string name) { return; } }","title":"Decorator"},{"location":"Rystem.DependencyInjection/#decorator-with-abstract-factory-integration","text":"You may add a decoration only for one service of your factory integration. Setup services.AddFactory<ITestService, TestService, TestOptions>(x => { x.ClassicName = classicName; }, factoryName, lifetime); services .AddDecoration<ITestService, DecoratorTestService>(factoryName, lifetime); Usage var decoratorFactory = provider.GetRequiredService<IFactory<ITestService>>(); var decorator = decoratorFactory.Create(factoryName); var previousService = decoratorFactory.CreateWithoutDecoration(factoryName);","title":"Decorator with Abstract Factory integration"},{"location":"Rystem.DependencyInjection/#factory-fallback","text":"You may add a fallback for your factory integration. The fallback service is called when the factory service key is not found. services.AddFactoryFallback<TService, TFactoryFallback>(); where TFactoryFallback is class and an IFactoryFallback You may add a fallback with an action fallback too. services.AddActionAsFallbackWithServiceProvider<TService>(Func<FallbackBuilderForServiceProvider, TService> fallbackBuilder);","title":"Factory Fallback"},{"location":"Rystem.DependencyInjection/#scan-dependency-injection","text":"You may scan your assemblies in search of types you need to add to dependency injection. For instance I have an interface IAnything and I need to add all classes which implements it. public interface IAnything { } internal class ScanModels : IAnything { } and in service collection I can add it. serviceCollection .Scan<IAnything>(ServiceLifetime.Scoped, typeof(IAnything).Assembly); I can add to my class the interface IScannable of T to scan automatically. For instance. public interface IAnything { } internal class ScanModels : IAnything, IScannable<IAnything> { } and in service collection I could add it in this way serviceCollection .Scan(ServiceLifetime.Scoped, typeof(IAnything).Assembly); Furthermore with ISingletonScannable, IScopedScannable and ITransientScannable I can override the service lifetime. For instance. public interface IAnything { } internal class ScanModels : IAnything, IScannable<IAnything>, ISingletonScannable { } serviceCollection .Scan(ServiceLifetime.Scoped, typeof(IAnything).Assembly); ScanModels will be installed as a Singleton service, overwriting the service lifetime from Scan method. You also automatically use different assembly sources. serviceCollection .ScanDependencyContext(ServiceLifetime.Scoped); or serviceCollection .ScanCallingAssembly(ServiceLifetime.Scoped); or serviceCollection .ScanCurrentDomain(ServiceLifetime.Scoped); or serviceCollection .ScanEntryAssembly(ServiceLifetime.Scoped); or serviceCollection .ScanExecutingAssembly(ServiceLifetime.Scoped); or serviceCollection .ScanFromType<T>(ServiceLifetime.Scoped); or serviceCollection .ScanFromTypes<T1, T2>(ServiceLifetime.Scoped); Finally with ScanWithReferences you may call all the assemblies you want plus all referenced assemblies by them.","title":"Scan dependency injection"},{"location":"Rystem.Queue/","text":"Queue You have to configure it in DI BackgroundJobCronFormat is the CRON for background job that checks if Maximum buffer is exceeded or has a retention expired, usually is lesser than or equal of MaximumRetentionCronFormat. MaximumRetentionCronFormat is the CRON for maximum time before to empty the queue and call the IQueueManager . MaximumBuffer is the maximum queue length before to empty the queue and call the IQueueManager . services.AddMemoryQueue<Sample, SampleQueueManager>(x => { x.MaximumBuffer = 1000; x.MaximumRetentionCronFormat = \"*/3 * * * * *\"; x.BackgroundJobCronFormat = \"*/1 * * * * *\"; }); public class SampleQueueManager : IQueueManager<Sample> { public Task ManageAsync(IEnumerable<Sample> items) { return Task.CompletedTask; } } For instance, in the example above you have a maximum queue length of 1000, a background job thatc checks every 1 second if there are 1000 or more items or maximum retention period of 3 seconds is expired. after the build you have to warm up var app = builder.Build(); await app.Services.WarmUpAsync(); and inject to use it var queue = _serviceProvider.GetService<IQueue<Sample>>()!; for (int i = 0; i < 100; i++) await queue.AddAsync(new Sample() { Id = i.ToString() }); In this example, after 1000 elements or 3 seconds the configured actions will be fired and the queue will be emptied. Stack (Last In First Out) services.AddMemoryStackQueue<Sample, SampleQueueManager>(x => { x.MaximumBuffer = 1000; x.MaximumRetentionCronFormat = \"*/3 * * * * *\"; x.BackgroundJobCronFormat = \"*/1 * * * * *\"; }); Custom integration If you want to use a distributed queue like storage queue, or event hub or service bus or event grid, you can write your own integration and configure it. services.AddQueueIntegration<Sample, SampleQueueManager, YourQueueIntegration>(x => { x.MaximumBuffer = 1000; x.MaximumRetentionCronFormat = \"*/3 * * * * *\"; x.BackgroundJobCronFormat = \"*/1 * * * * *\"; });","title":"Rystem.Queue"},{"location":"Rystem.Queue/#queue","text":"You have to configure it in DI BackgroundJobCronFormat is the CRON for background job that checks if Maximum buffer is exceeded or has a retention expired, usually is lesser than or equal of MaximumRetentionCronFormat. MaximumRetentionCronFormat is the CRON for maximum time before to empty the queue and call the IQueueManager . MaximumBuffer is the maximum queue length before to empty the queue and call the IQueueManager . services.AddMemoryQueue<Sample, SampleQueueManager>(x => { x.MaximumBuffer = 1000; x.MaximumRetentionCronFormat = \"*/3 * * * * *\"; x.BackgroundJobCronFormat = \"*/1 * * * * *\"; }); public class SampleQueueManager : IQueueManager<Sample> { public Task ManageAsync(IEnumerable<Sample> items) { return Task.CompletedTask; } } For instance, in the example above you have a maximum queue length of 1000, a background job thatc checks every 1 second if there are 1000 or more items or maximum retention period of 3 seconds is expired. after the build you have to warm up var app = builder.Build(); await app.Services.WarmUpAsync(); and inject to use it var queue = _serviceProvider.GetService<IQueue<Sample>>()!; for (int i = 0; i < 100; i++) await queue.AddAsync(new Sample() { Id = i.ToString() }); In this example, after 1000 elements or 3 seconds the configured actions will be fired and the queue will be emptied.","title":"Queue"},{"location":"Rystem.Queue/#stack-last-in-first-out","text":"services.AddMemoryStackQueue<Sample, SampleQueueManager>(x => { x.MaximumBuffer = 1000; x.MaximumRetentionCronFormat = \"*/3 * * * * *\"; x.BackgroundJobCronFormat = \"*/1 * * * * *\"; });","title":"Stack (Last In First Out)"},{"location":"Rystem.Queue/#custom-integration","text":"If you want to use a distributed queue like storage queue, or event hub or service bus or event grid, you can write your own integration and configure it. services.AddQueueIntegration<Sample, SampleQueueManager, YourQueueIntegration>(x => { x.MaximumBuffer = 1000; x.MaximumRetentionCronFormat = \"*/3 * * * * *\"; x.BackgroundJobCronFormat = \"*/1 * * * * *\"; });","title":"Custom integration"},{"location":"Rystem.RepositoryFramework.Abstractions/","text":"Interfaces Based on CQRS we could split our repository pattern in two main interfaces, one for update (write, delete) and one for read. Command (Write-Delete) public interface ICommandPattern<T, TKey> : ICommandPattern where TKey : notnull { Task<State<T, TKey>> InsertAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> UpdateAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> DeleteAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<BatchResult<T, TKey>> BatchAsync(BatchOperations<T, TKey> operations, CancellationToken cancellationToken = default); } Query (Read) public interface IQueryPattern<T, TKey> : IQueryPattern where TKey : notnull { Task<State<T, TKey>> ExistAsync(TKey key, CancellationToken cancellationToken = default); Task<T?> GetAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<IEntity<T, TKey>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default); ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default); } Repository Pattern (Write-Delete-Read) Repository pattern is a sum of CQRS interfaces. public interface IRepositoryPattern<T, TKey> : ICommandPattern<T, TKey>, IQueryPattern<T, TKey>, IRepositoryPattern, ICommandPattern, IQueryPattern where TKey : notnull { Task<State<T, TKey>> InsertAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> UpdateAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> DeleteAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<BatchResult<T, TKey>> BatchAsync(BatchOperations<T, TKey> operations, CancellationToken cancellationToken = default); Task<State<T, TKey>> ExistAsync(TKey key, CancellationToken cancellationToken = default); Task<T?> GetAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<IEntity<T, TKey>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default); ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default); } Examples Model public class User { public string Id { get; set; } public string Name { get; set; } public string Email { get; set; } } Command Your storage class has to extend ICommand, and use it on injection public class UserWriter : ICommand<User, string> { public Task<State<User, string>> DeleteAsync(string key, CancellationToken cancellationToken = default) { //delete on with DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> InsertAsync(string key, User value, CancellationToken cancellationToken = default) { //insert on DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> UpdateAsync(string key, User value, CancellationToken cancellationToken = default) { //update on DB or storage context throw new NotImplementedException(); } public Task<BatchResults<User, string>> BatchAsync(BatchOperations<User, string> operations, CancellationToken cancellationToken = default) { //insert, update or delete some items on DB or storage context throw new NotImplementedException(); } } Query Your storage class has to extend IQuery, and use it on injection public class UserReader : IQuery<User, string> { public Task<User?> GetAsync(string key, CancellationToken cancellationToken = default) { //get an item by key from DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> ExistAsync(string key, CancellationToken cancellationToken = default) { //check if an item by key exists in DB or storage context throw new NotImplementedException(); } public IAsyncEnumerable<IEntity<User, string>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default) { //get a list of items by a predicate with top and skip from DB or storage context throw new NotImplementedException(); } public ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default) { //get an items count by a predicate with top and skip from DB or storage context or max or min or some other operations throw new NotImplementedException(); } } Alltogether as repository pattern if you don't have CQRS infrastructure (usually it's correct to use CQRS when you have minimum two infrastructures one for write and delete and at least one for read). You may choose to extend IRepository, but when you inject you have to use IRepository public class UserRepository : IRepository<User, string>, IQuery<User, string>, ICommand<User, string> { public Task<State<User, string>> DeleteAsync(string key, CancellationToken cancellationToken = default) { //delete on with DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> InsertAsync(string key, User value, CancellationToken cancellationToken = default) { //insert on DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> UpdateAsync(string key, User value, CancellationToken cancellationToken = default) { //update on DB or storage context throw new NotImplementedException(); } public Task<BatchResults<User, string>> BatchAsync(BatchOperations<User, string> operations, CancellationToken cancellationToken = default) { //insert, update or delete some items on DB or storage context throw new NotImplementedException(); } public Task<User?> GetAsync(string key, CancellationToken cancellationToken = default) { //get an item by key from DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> ExistAsync(string key, CancellationToken cancellationToken = default) { //check if an item by key exists in DB or storage context throw new NotImplementedException(); } public IAsyncEnumerable<IEntity<User, string>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default) { //get a list of items by a predicate with top and skip from DB or storage context throw new NotImplementedException(); } public ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default) { //get an items count by a predicate with top and skip from DB or storage context or max or min or some other operations throw new NotImplementedException(); } } How to use it In DI you install the service. Here an example on how to set a custom storage, prepare a translation (to translate name of your properties for query during filtering), and AddBusiness for your integration. Furthermore you may use the factory integration from Rystem. var factoryName = \"storage\"; services.AddRepository<AppUser, AppUserKey>(builder => { builder.SetStorage<AppUserStorage>(factoryName); builder.Translate<User>() .With(x => x.Id, x => x.Identificativo) .With(x => x.Username, x => x.Nome) .With(x => x.Email, x => x.IndirizzoElettronico); builder .AddBusiness() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness2>(); }); And you may inject the object Please, use IRepository and not IRepositoryPattern IRepository<AppUser, AppUserKey> repository Query and Command In DI you install the services services.AddCommand<AppUser, AppUserKey>(...); services.AddQuery<AppUser, AppUserKey>(...); And you may inject the objects Please, use ICommand, IQuery and not ICommandPattern, IQueryPattern ICommand<AppUser, AppUserKey> command IQuery<AppUser, AppUserKey> query TKey when it's not a primitive You can use a class or record. Record is better in my opinion, for example, if you want to use the Equals operator from key, with record you don't check it by the refence but by the value of the properties in the record. My key: public class MyKey { public int Id { get; set; } public int Id2 { get; set; } } the DI services.AddRepository<User, MyKey>(...); and you may inject (for ICommand and IQuery is the same) IRepository<User, MyKey> repository IKey interface You may implement the IKey interface to decide how to work with your key. Here an example with Parse and AsString method and custom implementation with separator $. public class ClassicKey : IKey { public string A { get; set; } public int B { get; set; } public double C { get; set; } public static IKey Parse(string keyAsString) { var splitted = keyAsString.Split('$'); return new ClassicKey { A = splitted[0], B = int.Parse(splitted[1]), C = double.Parse(splitted[2]) }; } public string AsString() { return $\"{A}${B}${C}\"; } } IDefaultKey You may implement IDefaultKey if you want a simple key preconstructed parser. public class DefaultKey : IDefaultKey { public string A { get; set; } public int B { get; set; } public double C { get; set; } } Automatically you can call AsString to receive a string composed by all properties separated by triple |, for instance {A}|||{B}|||{C}. You can decide during startup the separator in two ways. One with ServiceCollectionExtensions builder.Services.AddDefaultSeparatorForDefaultKeyInterface(\"$$$\"); the other one with a static method offered by IDefaultKey interface IDefaultKey.SetDefaultSeparator(\"$$$\"); Default TKey record You may use the default record key in repository framework namespace. It's not really useful when used with no-primitive or no-struct objects (in terms of memory usage [Heap]). For 1 value (it's not really useful I know, but I liked to create it). new Key<int>(2); or for 2 values (useful) new Key<int, int>(2, 4); or for 3 values (unuseful) new Key<int, int, string>(2, 4, \"312\"); or for 4 values (useful) new Key<int, int, double, Guid>(2, 4, 3, Guid.NewGuid()); or for 5 values (unuseful) new Key<int, int, string, Guid, string>(2, 4, \"312\", Guid.NewGuid(), \"3232\"); the DI services.AddRepository<User, Key<int, int>, UserRepository>(); and you may inject (for ICommand and IQuery is the same) IRepository<User, Key<int, int>> repository Translation In some cases you need to \"translate\" your query for your database context query, for example in case of EF integration. services.AddDbContext<SampleContext>(options => { options.UseSqlServer(configuration[\"ConnectionString:Database\"]); }, ServiceLifetime.Scoped); services.AddRepository<AppUser, AppUserKey>(repositoryBuilder => { repositoryBuilder.SetStorage<AppUserStorage>(); repositoryBuilder.Translate<User>() .With(x => x.Id, x => x.Identificativo) .With(x => x.Username, x => x.Nome) .With(x => x.Email, x => x.IndirizzoElettronico); }); In this case I'm helping the Filter class to understand how to transform itself when used in a different context. Use Filter methods to help to translate and apply to your context the right query. await foreach (var user in filter.ApplyAsAsyncEnumerable(_context.Users)) yield return new AppUser(user.Identificativo, user.Nome, user.IndirizzoElettronico, new()); You may use Filter for queryable, FilterAsEnumerable for Enumerable and FilterAsAsyncEnumerable for async enumerable context. You can add more translations for the same model services.AddDbContext<SampleContext>(options => { options.UseSqlServer(configuration[\"ConnectionString:Database\"]); }, ServiceLifetime.Scoped); services.AddRepository<AppUser, AppUserKey>(repositoryBuilder => { repositoryBuilder.SetStorage<AppUserStorage>(); repositoryBuilder.Translate<User>() .With(x => x.Id, x => x.Identificativo) .With(x => x.Username, x => x.Nome) .With(x => x.Email, x => x.IndirizzoElettronico); repositoryBuilder .AddBusiness() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness2>(); }); Entity framework examples Here you may find the example Repository pattern applied Unit test flow Business Manager You have the chance to write your business methods to execute them before or after a command or query. For instance, you have to check before an update or insert the value of an entity and deny the final insert/update on the database. Example In this example BeforeInsertAsync runs before InsertAsync of IRepository/ICommand and AfterInsertAsync runs after InsertAsync of IRepository/ICommand. .AddRepository<Animal, long>(builder => { builder. WithInMemory(); builder .AddBusiness() .AddBusinessAfterInsert<AnimalBusiness>() .AddBusinessBeforeInsert<AnimalBusiness>(); }); more interesting usage comes to move business in another project, you can add to your infrastructure in the following way .AddBusinessForRepository<Animal, long>(builder => { builder .AddBusiness() .AddBusinessAfterInsert<AnimalBusiness>() .AddBusinessBeforeInsert<AnimalBusiness>(); }); Then, you could have a library for infrastructure (or more than one) and a library for business to separate furthermore the concepts. The animal business to inject will be the following one. public sealed class AnimalBusiness : IRepositoryBusinessBeforeInsert<Animal, long>, IRepositoryBusinessAfterInsert<Animal, long> { public static int After; public Task<State<Animal>> AfterInsertAsync(State<Animal, long> state, Entity<Animal, long> entity, CancellationToken cancellationToken = default) { After++; return Task.FromResult(state); } public static int Before; public Task<State<Animal, long>> BeforeInsertAsync(Entity<Animal, long> entity, CancellationToken cancellationToken = default) { Before++; return Task.FromResult(State.Ok(entity)); } } You have to create the class as public to allow the dependency injection to instastiate it. It's added directly to DI. Factory Integration with factory from rystem is hidden in the framework, and it's ready to be used. For instance here i'm installing two different repositories for the same model and key. var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); Usage var serviceProvider = ....; IFactory<IRepository<SuperUser, string>> superUserFactory = serviceProvider.GetRequiredService<IFactory<IRepository<SuperUser, string>>>(); var firstIntegration = superUserFactory.Create(); var secondIntegration = superUserFactory.Create(\"inmemory\"); By default is injected directly the last one repository integration installed. var serviceProvider = ....; IRepository<SuperUser, string> secondIntegration = serviceProvider.GetRequiredService<IRepository<SuperUser, string>>(); Here you find the \"inmemory\" integration. You can use the decorator pattern offered by Rystem for your integration to decorate an IRepository or ICommand or IQuery .","title":"Rystem.RepositoryFramework.Abstractions"},{"location":"Rystem.RepositoryFramework.Abstractions/#interfaces","text":"Based on CQRS we could split our repository pattern in two main interfaces, one for update (write, delete) and one for read.","title":"Interfaces"},{"location":"Rystem.RepositoryFramework.Abstractions/#command-write-delete","text":"public interface ICommandPattern<T, TKey> : ICommandPattern where TKey : notnull { Task<State<T, TKey>> InsertAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> UpdateAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> DeleteAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<BatchResult<T, TKey>> BatchAsync(BatchOperations<T, TKey> operations, CancellationToken cancellationToken = default); }","title":"Command (Write-Delete)"},{"location":"Rystem.RepositoryFramework.Abstractions/#query-read","text":"public interface IQueryPattern<T, TKey> : IQueryPattern where TKey : notnull { Task<State<T, TKey>> ExistAsync(TKey key, CancellationToken cancellationToken = default); Task<T?> GetAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<IEntity<T, TKey>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default); ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default); }","title":"Query (Read)"},{"location":"Rystem.RepositoryFramework.Abstractions/#repository-pattern-write-delete-read","text":"Repository pattern is a sum of CQRS interfaces. public interface IRepositoryPattern<T, TKey> : ICommandPattern<T, TKey>, IQueryPattern<T, TKey>, IRepositoryPattern, ICommandPattern, IQueryPattern where TKey : notnull { Task<State<T, TKey>> InsertAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> UpdateAsync(TKey key, T value, CancellationToken cancellationToken = default); Task<State<T, TKey>> DeleteAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<BatchResult<T, TKey>> BatchAsync(BatchOperations<T, TKey> operations, CancellationToken cancellationToken = default); Task<State<T, TKey>> ExistAsync(TKey key, CancellationToken cancellationToken = default); Task<T?> GetAsync(TKey key, CancellationToken cancellationToken = default); IAsyncEnumerable<IEntity<T, TKey>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default); ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default); }","title":"Repository Pattern (Write-Delete-Read)"},{"location":"Rystem.RepositoryFramework.Abstractions/#examples","text":"","title":"Examples"},{"location":"Rystem.RepositoryFramework.Abstractions/#model","text":"public class User { public string Id { get; set; } public string Name { get; set; } public string Email { get; set; } }","title":"Model"},{"location":"Rystem.RepositoryFramework.Abstractions/#command","text":"Your storage class has to extend ICommand, and use it on injection public class UserWriter : ICommand<User, string> { public Task<State<User, string>> DeleteAsync(string key, CancellationToken cancellationToken = default) { //delete on with DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> InsertAsync(string key, User value, CancellationToken cancellationToken = default) { //insert on DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> UpdateAsync(string key, User value, CancellationToken cancellationToken = default) { //update on DB or storage context throw new NotImplementedException(); } public Task<BatchResults<User, string>> BatchAsync(BatchOperations<User, string> operations, CancellationToken cancellationToken = default) { //insert, update or delete some items on DB or storage context throw new NotImplementedException(); } }","title":"Command"},{"location":"Rystem.RepositoryFramework.Abstractions/#query","text":"Your storage class has to extend IQuery, and use it on injection public class UserReader : IQuery<User, string> { public Task<User?> GetAsync(string key, CancellationToken cancellationToken = default) { //get an item by key from DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> ExistAsync(string key, CancellationToken cancellationToken = default) { //check if an item by key exists in DB or storage context throw new NotImplementedException(); } public IAsyncEnumerable<IEntity<User, string>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default) { //get a list of items by a predicate with top and skip from DB or storage context throw new NotImplementedException(); } public ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default) { //get an items count by a predicate with top and skip from DB or storage context or max or min or some other operations throw new NotImplementedException(); } }","title":"Query"},{"location":"Rystem.RepositoryFramework.Abstractions/#alltogether-as-repository-pattern","text":"if you don't have CQRS infrastructure (usually it's correct to use CQRS when you have minimum two infrastructures one for write and delete and at least one for read). You may choose to extend IRepository, but when you inject you have to use IRepository public class UserRepository : IRepository<User, string>, IQuery<User, string>, ICommand<User, string> { public Task<State<User, string>> DeleteAsync(string key, CancellationToken cancellationToken = default) { //delete on with DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> InsertAsync(string key, User value, CancellationToken cancellationToken = default) { //insert on DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> UpdateAsync(string key, User value, CancellationToken cancellationToken = default) { //update on DB or storage context throw new NotImplementedException(); } public Task<BatchResults<User, string>> BatchAsync(BatchOperations<User, string> operations, CancellationToken cancellationToken = default) { //insert, update or delete some items on DB or storage context throw new NotImplementedException(); } public Task<User?> GetAsync(string key, CancellationToken cancellationToken = default) { //get an item by key from DB or storage context throw new NotImplementedException(); } public Task<State<User, string>> ExistAsync(string key, CancellationToken cancellationToken = default) { //check if an item by key exists in DB or storage context throw new NotImplementedException(); } public IAsyncEnumerable<IEntity<User, string>> QueryAsync(IFilterExpression filter, CancellationToken cancellationToken = default) { //get a list of items by a predicate with top and skip from DB or storage context throw new NotImplementedException(); } public ValueTask<TProperty> OperationAsync<TProperty>(OperationType<TProperty> operation, IFilterExpression filter, CancellationToken cancellationToken = default) { //get an items count by a predicate with top and skip from DB or storage context or max or min or some other operations throw new NotImplementedException(); } }","title":"Alltogether as repository pattern"},{"location":"Rystem.RepositoryFramework.Abstractions/#how-to-use-it","text":"In DI you install the service. Here an example on how to set a custom storage, prepare a translation (to translate name of your properties for query during filtering), and AddBusiness for your integration. Furthermore you may use the factory integration from Rystem. var factoryName = \"storage\"; services.AddRepository<AppUser, AppUserKey>(builder => { builder.SetStorage<AppUserStorage>(factoryName); builder.Translate<User>() .With(x => x.Id, x => x.Identificativo) .With(x => x.Username, x => x.Nome) .With(x => x.Email, x => x.IndirizzoElettronico); builder .AddBusiness() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness2>(); }); And you may inject the object","title":"How to use it"},{"location":"Rystem.RepositoryFramework.Abstractions/#please-use-irepository-and-not-irepositorypattern","text":"IRepository<AppUser, AppUserKey> repository","title":"Please, use IRepository and not IRepositoryPattern"},{"location":"Rystem.RepositoryFramework.Abstractions/#query-and-command","text":"In DI you install the services services.AddCommand<AppUser, AppUserKey>(...); services.AddQuery<AppUser, AppUserKey>(...); And you may inject the objects","title":"Query and Command"},{"location":"Rystem.RepositoryFramework.Abstractions/#please-use-icommand-iquery-and-not-icommandpattern-iquerypattern","text":"ICommand<AppUser, AppUserKey> command IQuery<AppUser, AppUserKey> query","title":"Please, use ICommand, IQuery and not ICommandPattern, IQueryPattern"},{"location":"Rystem.RepositoryFramework.Abstractions/#tkey-when-its-not-a-primitive","text":"You can use a class or record. Record is better in my opinion, for example, if you want to use the Equals operator from key, with record you don't check it by the refence but by the value of the properties in the record. My key: public class MyKey { public int Id { get; set; } public int Id2 { get; set; } } the DI services.AddRepository<User, MyKey>(...); and you may inject (for ICommand and IQuery is the same) IRepository<User, MyKey> repository","title":"TKey when it's not a primitive"},{"location":"Rystem.RepositoryFramework.Abstractions/#ikey-interface","text":"You may implement the IKey interface to decide how to work with your key. Here an example with Parse and AsString method and custom implementation with separator $. public class ClassicKey : IKey { public string A { get; set; } public int B { get; set; } public double C { get; set; } public static IKey Parse(string keyAsString) { var splitted = keyAsString.Split('$'); return new ClassicKey { A = splitted[0], B = int.Parse(splitted[1]), C = double.Parse(splitted[2]) }; } public string AsString() { return $\"{A}${B}${C}\"; } }","title":"IKey interface"},{"location":"Rystem.RepositoryFramework.Abstractions/#idefaultkey","text":"You may implement IDefaultKey if you want a simple key preconstructed parser. public class DefaultKey : IDefaultKey { public string A { get; set; } public int B { get; set; } public double C { get; set; } } Automatically you can call AsString to receive a string composed by all properties separated by triple |, for instance {A}|||{B}|||{C}. You can decide during startup the separator in two ways. One with ServiceCollectionExtensions builder.Services.AddDefaultSeparatorForDefaultKeyInterface(\"$$$\"); the other one with a static method offered by IDefaultKey interface IDefaultKey.SetDefaultSeparator(\"$$$\");","title":"IDefaultKey"},{"location":"Rystem.RepositoryFramework.Abstractions/#default-tkey-record","text":"You may use the default record key in repository framework namespace. It's not really useful when used with no-primitive or no-struct objects (in terms of memory usage [Heap]). For 1 value (it's not really useful I know, but I liked to create it). new Key<int>(2); or for 2 values (useful) new Key<int, int>(2, 4); or for 3 values (unuseful) new Key<int, int, string>(2, 4, \"312\"); or for 4 values (useful) new Key<int, int, double, Guid>(2, 4, 3, Guid.NewGuid()); or for 5 values (unuseful) new Key<int, int, string, Guid, string>(2, 4, \"312\", Guid.NewGuid(), \"3232\"); the DI services.AddRepository<User, Key<int, int>, UserRepository>(); and you may inject (for ICommand and IQuery is the same) IRepository<User, Key<int, int>> repository","title":"Default TKey record"},{"location":"Rystem.RepositoryFramework.Abstractions/#translation","text":"In some cases you need to \"translate\" your query for your database context query, for example in case of EF integration. services.AddDbContext<SampleContext>(options => { options.UseSqlServer(configuration[\"ConnectionString:Database\"]); }, ServiceLifetime.Scoped); services.AddRepository<AppUser, AppUserKey>(repositoryBuilder => { repositoryBuilder.SetStorage<AppUserStorage>(); repositoryBuilder.Translate<User>() .With(x => x.Id, x => x.Identificativo) .With(x => x.Username, x => x.Nome) .With(x => x.Email, x => x.IndirizzoElettronico); }); In this case I'm helping the Filter class to understand how to transform itself when used in a different context. Use Filter methods to help to translate and apply to your context the right query. await foreach (var user in filter.ApplyAsAsyncEnumerable(_context.Users)) yield return new AppUser(user.Identificativo, user.Nome, user.IndirizzoElettronico, new()); You may use Filter for queryable, FilterAsEnumerable for Enumerable and FilterAsAsyncEnumerable for async enumerable context. You can add more translations for the same model services.AddDbContext<SampleContext>(options => { options.UseSqlServer(configuration[\"ConnectionString:Database\"]); }, ServiceLifetime.Scoped); services.AddRepository<AppUser, AppUserKey>(repositoryBuilder => { repositoryBuilder.SetStorage<AppUserStorage>(); repositoryBuilder.Translate<User>() .With(x => x.Id, x => x.Identificativo) .With(x => x.Username, x => x.Nome) .With(x => x.Email, x => x.IndirizzoElettronico); repositoryBuilder .AddBusiness() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness2>(); });","title":"Translation"},{"location":"Rystem.RepositoryFramework.Abstractions/#entity-framework-examples","text":"Here you may find the example Repository pattern applied Unit test flow","title":"Entity framework examples"},{"location":"Rystem.RepositoryFramework.Abstractions/#business-manager","text":"You have the chance to write your business methods to execute them before or after a command or query. For instance, you have to check before an update or insert the value of an entity and deny the final insert/update on the database.","title":"Business Manager"},{"location":"Rystem.RepositoryFramework.Abstractions/#example","text":"In this example BeforeInsertAsync runs before InsertAsync of IRepository/ICommand and AfterInsertAsync runs after InsertAsync of IRepository/ICommand. .AddRepository<Animal, long>(builder => { builder. WithInMemory(); builder .AddBusiness() .AddBusinessAfterInsert<AnimalBusiness>() .AddBusinessBeforeInsert<AnimalBusiness>(); }); more interesting usage comes to move business in another project, you can add to your infrastructure in the following way .AddBusinessForRepository<Animal, long>(builder => { builder .AddBusiness() .AddBusinessAfterInsert<AnimalBusiness>() .AddBusinessBeforeInsert<AnimalBusiness>(); }); Then, you could have a library for infrastructure (or more than one) and a library for business to separate furthermore the concepts. The animal business to inject will be the following one. public sealed class AnimalBusiness : IRepositoryBusinessBeforeInsert<Animal, long>, IRepositoryBusinessAfterInsert<Animal, long> { public static int After; public Task<State<Animal>> AfterInsertAsync(State<Animal, long> state, Entity<Animal, long> entity, CancellationToken cancellationToken = default) { After++; return Task.FromResult(state); } public static int Before; public Task<State<Animal, long>> BeforeInsertAsync(Entity<Animal, long> entity, CancellationToken cancellationToken = default) { Before++; return Task.FromResult(State.Ok(entity)); } } You have to create the class as public to allow the dependency injection to instastiate it. It's added directly to DI.","title":"Example"},{"location":"Rystem.RepositoryFramework.Abstractions/#factory","text":"Integration with factory from rystem is hidden in the framework, and it's ready to be used. For instance here i'm installing two different repositories for the same model and key. var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); Usage var serviceProvider = ....; IFactory<IRepository<SuperUser, string>> superUserFactory = serviceProvider.GetRequiredService<IFactory<IRepository<SuperUser, string>>>(); var firstIntegration = superUserFactory.Create(); var secondIntegration = superUserFactory.Create(\"inmemory\"); By default is injected directly the last one repository integration installed. var serviceProvider = ....; IRepository<SuperUser, string> secondIntegration = serviceProvider.GetRequiredService<IRepository<SuperUser, string>>(); Here you find the \"inmemory\" integration. You can use the decorator pattern offered by Rystem for your integration to decorate an IRepository or ICommand or IQuery .","title":"Factory"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorServer/","text":"Services extensions HttpClient to use your API (example) You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); Default interceptor for Authentication with JWT You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); }); Remember to add builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme) .AddMicrosoftIdentityWebApp(builder.Configuration.GetSection(\"AzureAdB2C or AzureAd\")) .EnableTokenAcquisitionToCallDownstreamApi(new string[] { \"your_scope/access_as_user\" }) .AddInMemoryTokenCaches(); builder.Services.AddServerSideBlazor() .AddMicrosoftIdentityConsentHandler(); builder.Services.AddControllersWithViews() .AddMicrosoftIdentityUI();","title":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorServer"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorServer/#services-extensions","text":"","title":"Services extensions"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorServer/#httpclient-to-use-your-api-example","text":"You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); });","title":"HttpClient to use your API (example)"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorServer/#default-interceptor-for-authentication-with-jwt","text":"You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); }); Remember to add builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme) .AddMicrosoftIdentityWebApp(builder.Configuration.GetSection(\"AzureAdB2C or AzureAd\")) .EnableTokenAcquisitionToCallDownstreamApi(new string[] { \"your_scope/access_as_user\" }) .AddInMemoryTokenCaches(); builder.Services.AddServerSideBlazor() .AddMicrosoftIdentityConsentHandler(); builder.Services.AddControllersWithViews() .AddMicrosoftIdentityUI();","title":"Default interceptor for Authentication with JWT"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm/","text":"Services extensions HttpClient to use your API (example) You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); Default interceptor for Authentication with JWT You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); });","title":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm/#services-extensions","text":"","title":"Services extensions"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm/#httpclient-to-use-your-api-example","text":"You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); });","title":"HttpClient to use your API (example)"},{"location":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm/#default-interceptor-for-authentication-with-jwt","text":"You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); This line of code inject an interceptor that works with ITokenAcquisition, injected by the framework during OpenId integration (for example AAD integration). Automatically it adds the token to each request. You may use the default identity interceptor not on all repositories, you can specificy them with builder.Services.AddRepository(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .AddDefaultAuthorizationInterceptorForApiHttpClient<T, TKey>(); });","title":"Default interceptor for Authentication with JWT"},{"location":"Rystem.RepositoryFramework.Api.Client/","text":"Services extensions HttpClient to use your API (example) You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); You may add a Polly policy to your api client for example: var retryPolicy = HttpPolicyExtensions .HandleTransientHttpError() .Or<TimeoutRejectedException>() .RetryAsync(3); builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .ClientBuilder .AddPolicyHandler(retryPolicy); }); and use it in DI with IRepository<User, string> repository Query and Command In DI you install the services services.AddCommand<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); services.AddQuery<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); And you may inject the objects Please, use ICommand, IQuery and not ICommandPattern, IQueryPattern ICommand<User, string> command IQuery<User, string> command With a non default key In DI you install the services with a bool key for example. services.AddRepository<User, bool>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); services.AddCommand<User, bool>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); services.AddQuery<User, bool>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); And you may inject the objects Please, use ICommand, IQuery, IRepository and not ICommandPattern, IQueryPattern, IRepositoryPattern IRepository<User, string> repository ICommand<User, string> command IQuery<User, string> command Interceptors You may add a custom interceptor for every request for every model public static IServiceCollection AddApiClientInterceptor<TInterceptor>(this IServiceCollection services, ServiceLifetime serviceLifetime = ServiceLifetime.Scoped) where TInterceptor : class, IRepositoryClientInterceptor or a specific interceptor for each model public static IServiceCollection AddApiClientInterceptor<TInterceptor>(this IServiceCollection services, ServiceLifetime serviceLifetime = ServiceLifetime.Scoped) where TInterceptor : class, IRepositoryClientInterceptor or for a string as default TKey public static RepositorySettings<T, TKey> AddApiClientSpecificInterceptor<T, TKey, TInterceptor>( this RepositorySettings<T, TKey> settings, ServiceLifetime serviceLifetime = ServiceLifetime.Scoped) where TInterceptor : class, IRepositoryClientInterceptor<T> where TKey : notnull Maybe you can use it to add a token as JWT o another pre-request things. Default interceptor for Authentication with JWT You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); with package RepositoryFramework.Api.Client.Authentication.BlazorServer or if you need to use in Wasm blazor use with Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm","title":"Rystem.RepositoryFramework.Api.Client"},{"location":"Rystem.RepositoryFramework.Api.Client/#services-extensions","text":"","title":"Services extensions"},{"location":"Rystem.RepositoryFramework.Api.Client/#httpclient-to-use-your-api-example","text":"You can add a client for a specific url builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); You may add a Polly policy to your api client for example: var retryPolicy = HttpPolicyExtensions .HandleTransientHttpError() .Or<TimeoutRejectedException>() .RetryAsync(3); builder.Services.AddRepository<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\") .ClientBuilder .AddPolicyHandler(retryPolicy); }); and use it in DI with IRepository<User, string> repository","title":"HttpClient to use your API (example)"},{"location":"Rystem.RepositoryFramework.Api.Client/#query-and-command","text":"In DI you install the services services.AddCommand<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); services.AddQuery<User, string>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); And you may inject the objects","title":"Query and Command"},{"location":"Rystem.RepositoryFramework.Api.Client/#please-use-icommand-iquery-and-not-icommandpattern-iquerypattern","text":"ICommand<User, string> command IQuery<User, string> command","title":"Please, use ICommand, IQuery and not ICommandPattern, IQueryPattern"},{"location":"Rystem.RepositoryFramework.Api.Client/#with-a-non-default-key","text":"In DI you install the services with a bool key for example. services.AddRepository<User, bool>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); services.AddCommand<User, bool>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); services.AddQuery<User, bool>(builder => { builder .WithApiClient() .WithHttpClient(\"localhost:7058\"); }); And you may inject the objects","title":"With a non default key"},{"location":"Rystem.RepositoryFramework.Api.Client/#please-use-icommand-iquery-irepository-and-not-icommandpattern-iquerypattern-irepositorypattern","text":"IRepository<User, string> repository ICommand<User, string> command IQuery<User, string> command","title":"Please, use ICommand, IQuery, IRepository and not ICommandPattern, IQueryPattern, IRepositoryPattern"},{"location":"Rystem.RepositoryFramework.Api.Client/#interceptors","text":"You may add a custom interceptor for every request for every model public static IServiceCollection AddApiClientInterceptor<TInterceptor>(this IServiceCollection services, ServiceLifetime serviceLifetime = ServiceLifetime.Scoped) where TInterceptor : class, IRepositoryClientInterceptor or a specific interceptor for each model public static IServiceCollection AddApiClientInterceptor<TInterceptor>(this IServiceCollection services, ServiceLifetime serviceLifetime = ServiceLifetime.Scoped) where TInterceptor : class, IRepositoryClientInterceptor or for a string as default TKey public static RepositorySettings<T, TKey> AddApiClientSpecificInterceptor<T, TKey, TInterceptor>( this RepositorySettings<T, TKey> settings, ServiceLifetime serviceLifetime = ServiceLifetime.Scoped) where TInterceptor : class, IRepositoryClientInterceptor<T> where TKey : notnull Maybe you can use it to add a token as JWT o another pre-request things.","title":"Interceptors"},{"location":"Rystem.RepositoryFramework.Api.Client/#default-interceptor-for-authentication-with-jwt","text":"You may use the default interceptor to deal with the identity manager in .Net DI. builder.Services.AddDefaultAuthorizationInterceptorForApiHttpClient(); with package","title":"Default interceptor for Authentication with JWT"},{"location":"Rystem.RepositoryFramework.Api.Client/#repositoryframeworkapiclientauthenticationblazorserver","text":"or if you need to use in Wasm blazor use with","title":"RepositoryFramework.Api.Client.Authentication.BlazorServer"},{"location":"Rystem.RepositoryFramework.Api.Client/#rystemrepositoryframeworkapiclientauthenticationblazorwasm","text":"","title":"Rystem.RepositoryFramework.Api.Client.Authentication.BlazorWasm"},{"location":"Rystem.RepositoryFramework.Api.Server/","text":"Api auto-generated In your web application you have only to add one row after service build. services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization(); public static ApiAuthorizationBuilder UseApiFromRepositoryFramework<TEndpointRouteBuilder>( this TEndpointRouteBuilder app, string startingPath = \"api\") where TEndpointRouteBuilder : IEndpointRouteBuilder You may add api for each service by public static ApiAuthorizationBuilder UseApiForRepository<T>(this IEndpointRouteBuilder app, string startingPath = \"api\") Startup example In the example below you may find the setup of three populated repositories, two of them are of the same kind (SuperUser). The SuperiorUser will be added to the app but will be not exposed as Api cause the SetNotExposable() method. Futhermore, we are adding a configuration for AAD to implement authentication on api. var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); builder.Services.AddRepository<SuperiorUser, string>(settings => { settings.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\") .WithPattern(x => x.Value!.Port, @\"[1-9]{3,4}\"); }); settings.SetNotExposable(); }); builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); await app.Services.WarmUpAsync(); app.UseHttpsRedirection(); app.UseApiFromRepositoryFramework() .WithDefaultAuthorization(); app.Run(); No Authorization flow - default var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); builder.Services.AddRepository<SuperiorUser, string>(settings => { settings.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\") .WithPattern(x => x.Value!.Port, @\"[1-9]{3,4}\"); }); settings.SetNotExposable(); }); builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); await app.Services.WarmUpAsync(); if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseApiFromRepositoryFramework() .WithNoAuthorization(); app.Run(); Authorization flow - custom policies You may configure the scoper for each method of your repository and for each repository, as you wish. var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); builder.Services.AddRepository<SuperiorUser, string>(settings => { settings.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\") .WithPattern(x => x.Value!.Port, @\"[1-9]{3,4}\"); }); settings.SetNotExposable(); }); builder.Services.AddAuthorization( options => { options.AddPolicy(\"NormalUser\", x => { x.RequireClaim(ClaimTypes.Name); }); options.AddPolicy(\"SuperAdmin\", x => { x.RequireRole(\"SuperAdmin\"); }); }); builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); await app.Services.WarmUpAsync(); if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseEndpoints(endpoints => { endpoints.MapHealthChecks(\"/healthz\"); endpoints.UseApiFromRepository<SuperUser>() .SetPolicyForCommand() .With(\"SuperAdmin\") .Build(); endpoints.UseApiFromRepositoryFramework() .SetPolicyForAll() .With(\"NormalUser\") .And() .SetPolicy(RepositoryMethods.Insert) .With(\"SuperAdmin\") .And() .SetPolicy(RepositoryMethods.Update) .With(\"SuperAdmin\") .Build(); endpoints .MapControllers(); }); app.Run(); In this example, I'm configuring a policy named \"NormalUser\" for all methods and all repositories, and a policy named \"SuperAdmin\" for the methods Insert and Update for all repositories and for the command (Insert, Updated and Delete) of SuperUser repository. You can customize it repository for repository, using UseApiFromRepository () method. Sample of filter usage when you use the api directly All the requests are basic requests, the strangest request is only the query and you must use the Linq query. You may find some examples down below: \u0192 => (((\u0192.X == \"dasda\") AndAlso \u0192.X.Contains(\"dasda\")) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) \u0192 => ((((\u0192.X == \"dasda\") AndAlso \u0192.Sol) AndAlso \u0192.X.Contains(\"dasda\")) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) \u0192 => (((((\u0192.X == \"dasda\") AndAlso \u0192.Sol) AndAlso \u0192.X.Contains(\"dasda\")) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2))) \u0192 => (\u0192.Type == 2) \u0192 => (((((\u0192.X == \"dasda\") AndAlso \u0192.Sol) AndAlso (\u0192.X.Contains(\"dasda\") OrElse \u0192.Sol.Equals(True))) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2))) \u0192 => ((((((\u0192.X == \"dasda\") AndAlso \u0192.Samules.Any(x => (x == \"ccccde\"))) AndAlso \u0192.Sol) AndAlso (\u0192.X.Contains(\"dasda\") OrElse \u0192.Sol.Equals(True))) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2))) \u0192 => (\u0192.ExpirationTime > Convert.ToDateTime(\"7/6/2022 9:48:56 AM\")) \u0192 => (\u0192.TimeSpan > new TimeSpan(1000 as long)) \u0192 => Not(\u0192.Inside.Inside.A.Equals(\"dasdad\")) \u0192 => Not(String.IsNullOrWhiteSpace(\u0192.Inside.Inside.A))","title":"Rystem.RepositoryFramework.Api.Server"},{"location":"Rystem.RepositoryFramework.Api.Server/#api-auto-generated","text":"In your web application you have only to add one row after service build. services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization(); public static ApiAuthorizationBuilder UseApiFromRepositoryFramework<TEndpointRouteBuilder>( this TEndpointRouteBuilder app, string startingPath = \"api\") where TEndpointRouteBuilder : IEndpointRouteBuilder You may add api for each service by public static ApiAuthorizationBuilder UseApiForRepository<T>(this IEndpointRouteBuilder app, string startingPath = \"api\")","title":"Api auto-generated"},{"location":"Rystem.RepositoryFramework.Api.Server/#startup-example","text":"In the example below you may find the setup of three populated repositories, two of them are of the same kind (SuperUser). The SuperiorUser will be added to the app but will be not exposed as Api cause the SetNotExposable() method. Futhermore, we are adding a configuration for AAD to implement authentication on api. var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); builder.Services.AddRepository<SuperiorUser, string>(settings => { settings.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\") .WithPattern(x => x.Value!.Port, @\"[1-9]{3,4}\"); }); settings.SetNotExposable(); }); builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); await app.Services.WarmUpAsync(); app.UseHttpsRedirection(); app.UseApiFromRepositoryFramework() .WithDefaultAuthorization(); app.Run();","title":"Startup example"},{"location":"Rystem.RepositoryFramework.Api.Server/#no-authorization-flow-default","text":"var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); builder.Services.AddRepository<SuperiorUser, string>(settings => { settings.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\") .WithPattern(x => x.Value!.Port, @\"[1-9]{3,4}\"); }); settings.SetNotExposable(); }); builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); await app.Services.WarmUpAsync(); if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseApiFromRepositoryFramework() .WithNoAuthorization(); app.Run();","title":"No Authorization flow - default"},{"location":"Rystem.RepositoryFramework.Api.Server/#authorization-flow-custom-policies","text":"You may configure the scoper for each method of your repository and for each repository, as you wish. var builder = WebApplication.CreateBuilder(args); builder.Services .AddRepository<SuperUser, string>(settins => { settins.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); settins.WithInMemory(builder => { builder .PopulateWithRandomData(2, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\"); }, \"inmemory\"); }); builder.Services.AddRepository<SuperiorUser, string>(settings => { settings.WithInMemory(builder => { builder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value!.Email, @\"[a-z]{5,10}@gmail\\.com\") .WithPattern(x => x.Value!.Port, @\"[1-9]{3,4}\"); }); settings.SetNotExposable(); }); builder.Services.AddAuthorization( options => { options.AddPolicy(\"NormalUser\", x => { x.RequireClaim(ClaimTypes.Name); }); options.AddPolicy(\"SuperAdmin\", x => { x.RequireRole(\"SuperAdmin\"); }); }); builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); await app.Services.WarmUpAsync(); if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseEndpoints(endpoints => { endpoints.MapHealthChecks(\"/healthz\"); endpoints.UseApiFromRepository<SuperUser>() .SetPolicyForCommand() .With(\"SuperAdmin\") .Build(); endpoints.UseApiFromRepositoryFramework() .SetPolicyForAll() .With(\"NormalUser\") .And() .SetPolicy(RepositoryMethods.Insert) .With(\"SuperAdmin\") .And() .SetPolicy(RepositoryMethods.Update) .With(\"SuperAdmin\") .Build(); endpoints .MapControllers(); }); app.Run(); In this example, I'm configuring a policy named \"NormalUser\" for all methods and all repositories, and a policy named \"SuperAdmin\" for the methods Insert and Update for all repositories and for the command (Insert, Updated and Delete) of SuperUser repository. You can customize it repository for repository, using UseApiFromRepository () method.","title":"Authorization flow - custom policies"},{"location":"Rystem.RepositoryFramework.Api.Server/#sample-of-filter-usage-when-you-use-the-api-directly","text":"All the requests are basic requests, the strangest request is only the query and you must use the Linq query. You may find some examples down below: \u0192 => (((\u0192.X == \"dasda\") AndAlso \u0192.X.Contains(\"dasda\")) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) \u0192 => ((((\u0192.X == \"dasda\") AndAlso \u0192.Sol) AndAlso \u0192.X.Contains(\"dasda\")) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) \u0192 => (((((\u0192.X == \"dasda\") AndAlso \u0192.Sol) AndAlso \u0192.X.Contains(\"dasda\")) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2))) \u0192 => (\u0192.Type == 2) \u0192 => (((((\u0192.X == \"dasda\") AndAlso \u0192.Sol) AndAlso (\u0192.X.Contains(\"dasda\") OrElse \u0192.Sol.Equals(True))) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2))) \u0192 => ((((((\u0192.X == \"dasda\") AndAlso \u0192.Samules.Any(x => (x == \"ccccde\"))) AndAlso \u0192.Sol) AndAlso (\u0192.X.Contains(\"dasda\") OrElse \u0192.Sol.Equals(True))) AndAlso ((\u0192.E == Guid.Parse(\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2))) \u0192 => (\u0192.ExpirationTime > Convert.ToDateTime(\"7/6/2022 9:48:56 AM\")) \u0192 => (\u0192.TimeSpan > new TimeSpan(1000 as long)) \u0192 => Not(\u0192.Inside.Inside.A.Equals(\"dasdad\")) \u0192 => Not(String.IsNullOrWhiteSpace(\u0192.Inside.Inside.A))","title":"Sample of filter usage when you use the api directly"},{"location":"Rystem.RepositoryFramework.Cache.Azure.Storage.Blob/","text":"Cache example .AddRepository<User, string>(repositoryBuilder => { repositoryBuilder .WithBlobStorage(storageBuilder => { storageBuilder.Settings.ConnectionString = builder.Configuration[\"ConnectionString:Storage\"]; }); repositoryBuilder .WithInMemoryCache(x => { x.ExpiringTime = TimeSpan.FromSeconds(60); x.Methods = RepositoryMethods.Get | RepositoryMethods.Insert | RepositoryMethods.Update | RepositoryMethods.Delete; }) .WithBlobStorageCache( x => { x.Settings.ConnectionString = builder.Configuration[\"ConnectionString:Storage\"]; } , x => { x.ExpiringTime = TimeSpan.FromSeconds(120); x.Methods = RepositoryMethods.All; }); }); Usage You always will find the same interface. For instance IRepository<User, string> repository or if you added a query pattern or command pattern IQuery<User, string> query ICommand<User, string> command","title":"Rystem.RepositoryFramework.Cache.Azure.Storage.Blob"},{"location":"Rystem.RepositoryFramework.Cache.Azure.Storage.Blob/#cache-example","text":".AddRepository<User, string>(repositoryBuilder => { repositoryBuilder .WithBlobStorage(storageBuilder => { storageBuilder.Settings.ConnectionString = builder.Configuration[\"ConnectionString:Storage\"]; }); repositoryBuilder .WithInMemoryCache(x => { x.ExpiringTime = TimeSpan.FromSeconds(60); x.Methods = RepositoryMethods.Get | RepositoryMethods.Insert | RepositoryMethods.Update | RepositoryMethods.Delete; }) .WithBlobStorageCache( x => { x.Settings.ConnectionString = builder.Configuration[\"ConnectionString:Storage\"]; } , x => { x.ExpiringTime = TimeSpan.FromSeconds(120); x.Methods = RepositoryMethods.All; }); });","title":"Cache example"},{"location":"Rystem.RepositoryFramework.Cache.Azure.Storage.Blob/#usage","text":"You always will find the same interface. For instance IRepository<User, string> repository or if you added a query pattern or command pattern IQuery<User, string> query ICommand<User, string> command","title":"Usage"},{"location":"Rystem.RepositoryFramework.Cache/","text":"Cache Examples You can add a repository (with default blob integration for instance) and after attack an in memory cache for all methods. The RefreshTime is a property that adds an Expiration date to the cached value, in the example below you can see that after 20 seconds the in memory cache requests again to the repository pattern a new value for each key. The Methods is a flag that allows to setup what operations have to be cached. Query -> query will be cached with this key var keyAsString = $\"{nameof(RepositoryMethods.Query)}_{typeof(T).Name}_{FactoryName}_{filter.ToKey()}\"; Operation -> operation will be cached with this key var keyAsString = $\"{nameof(RepositoryMethods.Operation)}_{operation.Name}_{typeof(T).Name}_{FactoryName}_{filter.ToKey()}\"; Get -> query will be cached with this key var keyAsString = $\"{nameof(RepositoryMethods.Get)}_{typeof(T).Name}_{FactoryName}_{key.AsString()}\"; Exist -> query will be cached with this key var keyAsString = $\"{nameof(RepositoryMethod.Exist)}_{typeof(T).Name}_{FactoryName}_{key.AsString()}\"; Now you can understand the special behavior for commands. If you set Insert and/or Update and/or Delete, during any command if you allowed it for each command automatically the framework will update the cache value, with updated or inserted value or removing the deleted value. The code below allows everything x.Methods = RepositoryMethod.All In the example below you're setting up the following behavior: setting up a cache only for Get operation, and update the Get cache when exists a new Insert or an Update, or a removal when Delete operation were perfomed. x.Methods = RepositoryMethod.Get | RepositoryMethod.Insert | RepositoryMethod.Update | RepositoryMethod.Delete Setup in DI services .AddRepository<Plant, int>(settings => { settings .WithInMemory(); settings .WithInMemoryCache(x => { x.ExpiringTime = TimeSpan.FromSeconds(1); x.Methods = RepositoryMethods.All; }); }); Usage You always will find the same interface. For instance IRepository<Plant, int> repository or if you added a query pattern or command pattern IQuery<Plant, int> query ICommand<Plant, int> command Distributed Cache Based on this link you may use the standard interface IDistributedCache instead of create a custom IDistributedCache . For instance you may choose between three libraries: Distributed SQL Server cache, Distributed Redis cache, Distributed NCache cache. You need to add the cache builder.Services.AddStackExchangeRedisCache(options => { options.Configuration = builder.Configuration.GetConnectionString(\"MyRedisConStr\"); options.InstanceName = \"SampleInstance\"; }); then you add the IDistributedCache implementation to your repository patterns or CQRS. .AddRepository<Country, CountryKey>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(NumberOfEntries, NumberOfEntries); }); builder .WithDistributedCache(distributedCacheBuilder => { distributedCacheBuilder.ExpiringTime = TimeSpan.FromSeconds(10); }); }); or a mix of them .AddRepository<Country, CountryKey>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(NumberOfEntries, NumberOfEntries); }); builder .WithInMemoryCache(inMemoryCacheBuilder => { inMemoryCacheBuilder.ExpiringTime = TimeSpan.FromSeconds(10); }) .WithDistributedCache(distributedCacheBuilder => { distributedCacheBuilder.ExpiringTime = TimeSpan.FromSeconds(10); }); }); and as always you will use the standard interface that is automatically integrated in the repository flow. IRepository<User, string> repository; The same is valid for ICommand and IQuery.","title":"Rystem.RepositoryFramework.Cache"},{"location":"Rystem.RepositoryFramework.Cache/#cache","text":"","title":"Cache"},{"location":"Rystem.RepositoryFramework.Cache/#examples","text":"You can add a repository (with default blob integration for instance) and after attack an in memory cache for all methods. The RefreshTime is a property that adds an Expiration date to the cached value, in the example below you can see that after 20 seconds the in memory cache requests again to the repository pattern a new value for each key. The Methods is a flag that allows to setup what operations have to be cached. Query -> query will be cached with this key var keyAsString = $\"{nameof(RepositoryMethods.Query)}_{typeof(T).Name}_{FactoryName}_{filter.ToKey()}\"; Operation -> operation will be cached with this key var keyAsString = $\"{nameof(RepositoryMethods.Operation)}_{operation.Name}_{typeof(T).Name}_{FactoryName}_{filter.ToKey()}\"; Get -> query will be cached with this key var keyAsString = $\"{nameof(RepositoryMethods.Get)}_{typeof(T).Name}_{FactoryName}_{key.AsString()}\"; Exist -> query will be cached with this key var keyAsString = $\"{nameof(RepositoryMethod.Exist)}_{typeof(T).Name}_{FactoryName}_{key.AsString()}\"; Now you can understand the special behavior for commands. If you set Insert and/or Update and/or Delete, during any command if you allowed it for each command automatically the framework will update the cache value, with updated or inserted value or removing the deleted value. The code below allows everything x.Methods = RepositoryMethod.All In the example below you're setting up the following behavior: setting up a cache only for Get operation, and update the Get cache when exists a new Insert or an Update, or a removal when Delete operation were perfomed. x.Methods = RepositoryMethod.Get | RepositoryMethod.Insert | RepositoryMethod.Update | RepositoryMethod.Delete","title":"Examples"},{"location":"Rystem.RepositoryFramework.Cache/#setup-in-di","text":"services .AddRepository<Plant, int>(settings => { settings .WithInMemory(); settings .WithInMemoryCache(x => { x.ExpiringTime = TimeSpan.FromSeconds(1); x.Methods = RepositoryMethods.All; }); });","title":"Setup in DI"},{"location":"Rystem.RepositoryFramework.Cache/#usage","text":"You always will find the same interface. For instance IRepository<Plant, int> repository or if you added a query pattern or command pattern IQuery<Plant, int> query ICommand<Plant, int> command","title":"Usage"},{"location":"Rystem.RepositoryFramework.Cache/#distributed-cache","text":"Based on this link you may use the standard interface IDistributedCache instead of create a custom IDistributedCache . For instance you may choose between three libraries: Distributed SQL Server cache, Distributed Redis cache, Distributed NCache cache. You need to add the cache builder.Services.AddStackExchangeRedisCache(options => { options.Configuration = builder.Configuration.GetConnectionString(\"MyRedisConStr\"); options.InstanceName = \"SampleInstance\"; }); then you add the IDistributedCache implementation to your repository patterns or CQRS. .AddRepository<Country, CountryKey>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(NumberOfEntries, NumberOfEntries); }); builder .WithDistributedCache(distributedCacheBuilder => { distributedCacheBuilder.ExpiringTime = TimeSpan.FromSeconds(10); }); }); or a mix of them .AddRepository<Country, CountryKey>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(NumberOfEntries, NumberOfEntries); }); builder .WithInMemoryCache(inMemoryCacheBuilder => { inMemoryCacheBuilder.ExpiringTime = TimeSpan.FromSeconds(10); }) .WithDistributedCache(distributedCacheBuilder => { distributedCacheBuilder.ExpiringTime = TimeSpan.FromSeconds(10); }); }); and as always you will use the standard interface that is automatically integrated in the repository flow. IRepository<User, string> repository; The same is valid for ICommand and IQuery.","title":"Distributed Cache"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Cosmos.Sql/","text":"Integration with Azure Cosmos Sql and Repository Framework Example from unit test with a business integration too. await services .AddRepositoryAsync<AppUser, AppUserKey>(async builder => { await builder.WithCosmosSqlAsync(x => { x.Settings.ConnectionString = configuration[\"ConnectionString:CosmosSql\"]; x.Settings.DatabaseName = \"unittestdatabase\"; x.WithId(x => new AppUserKey(x.Id)); }).NoContext(); builder .AddBusiness() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness2>(); }).NoContext(); You found the IRepository in DI to play with it. Automated api with Rystem.RepositoryFramework.Api.Server package With automated api, you may have the api implemented with your cosmos sql integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Rystem.RepositoryFramework.Infrastructure.Azure.Cosmos.Sql"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Cosmos.Sql/#integration-with-azure-cosmos-sql-and-repository-framework","text":"Example from unit test with a business integration too. await services .AddRepositoryAsync<AppUser, AppUserKey>(async builder => { await builder.WithCosmosSqlAsync(x => { x.Settings.ConnectionString = configuration[\"ConnectionString:CosmosSql\"]; x.Settings.DatabaseName = \"unittestdatabase\"; x.WithId(x => new AppUserKey(x.Id)); }).NoContext(); builder .AddBusiness() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<AppUserBeforeInsertBusiness2>(); }).NoContext(); You found the IRepository in DI to play with it.","title":"Integration with Azure Cosmos Sql and Repository Framework"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Cosmos.Sql/#automated-api-with-rystemrepositoryframeworkapiserver-package","text":"With automated api, you may have the api implemented with your cosmos sql integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Automated api with Rystem.RepositoryFramework.Api.Server package"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Blob/","text":"Integration with Azure BlobStorage and Repository Framework Example from unit test with a business integration too. services .AddRepository<Car, Guid>(builder => { builder.WithBlobStorage(builder => { builder.Settings.ConnectionString = configuration[\"ConnectionString:Storage\"]; builder.Settings.Prefix = \"MyFolder/\"; }); }); services .AddBusinessForRepository<Car, Guid>() .AddBusinessBeforeInsert<CarBeforeInsertBusiness>() .AddBusinessBeforeInsert<CarBeforeInsertBusiness2>(); You found the IRepository in DI to play with it. Automated api with Rystem.RepositoryFramework.Api.Server package With automated api, you may have the api implemented with your blobstorage integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Blob"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Blob/#integration-with-azure-blobstorage-and-repository-framework","text":"Example from unit test with a business integration too. services .AddRepository<Car, Guid>(builder => { builder.WithBlobStorage(builder => { builder.Settings.ConnectionString = configuration[\"ConnectionString:Storage\"]; builder.Settings.Prefix = \"MyFolder/\"; }); }); services .AddBusinessForRepository<Car, Guid>() .AddBusinessBeforeInsert<CarBeforeInsertBusiness>() .AddBusinessBeforeInsert<CarBeforeInsertBusiness2>(); You found the IRepository in DI to play with it.","title":"Integration with Azure BlobStorage and Repository Framework"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Blob/#automated-api-with-rystemrepositoryframeworkapiserver-package","text":"With automated api, you may have the api implemented with your blobstorage integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Automated api with Rystem.RepositoryFramework.Api.Server package"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Table/","text":"Integration with Azure TableStorage and Repository Framework Example from unit test with a business integration too. Here you may find the chance to use ToResult() in services to avoid the async method. services .AddRepositoryAsync<AppUser, AppUserKey>(async builder => { await builder .WithTableStorageAsync(tableStorageBuilder => { tableStorageBuilder .Settings.ConnectionString = configuration[\"ConnectionString:Storage\"]; tableStorageBuilder .WithTableStorageKeyReader<TableStorageKeyReader>() .WithPartitionKey(x => x.Id, x => x.Id) .WithRowKey(x => x.Username) .WithTimestamp(x => x.CreationTime); }); }).ToResult(); You found the IRepository in DI to play with it. Automated api with Rystem.RepositoryFramework.Api.Server package With automated api, you may have the api implemented with your tablestorage integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Table"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Table/#integration-with-azure-tablestorage-and-repository-framework","text":"Example from unit test with a business integration too. Here you may find the chance to use ToResult() in services to avoid the async method. services .AddRepositoryAsync<AppUser, AppUserKey>(async builder => { await builder .WithTableStorageAsync(tableStorageBuilder => { tableStorageBuilder .Settings.ConnectionString = configuration[\"ConnectionString:Storage\"]; tableStorageBuilder .WithTableStorageKeyReader<TableStorageKeyReader>() .WithPartitionKey(x => x.Id, x => x.Id) .WithRowKey(x => x.Username) .WithTimestamp(x => x.CreationTime); }); }).ToResult(); You found the IRepository in DI to play with it.","title":"Integration with Azure TableStorage and Repository Framework"},{"location":"Rystem.RepositoryFramework.Infrastructure.Azure.Storage.Table/#automated-api-with-rystemrepositoryframeworkapiserver-package","text":"With automated api, you may have the api implemented with your tablestorage integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Automated api with Rystem.RepositoryFramework.Api.Server package"},{"location":"Rystem.RepositoryFramework.Infrastructure.Dynamics.Dataverse/","text":"Integration with Dataverse (Dynamics) and Repository Framework Example from unit test with a business integration too. services. AddRepository<CalamityUniverseUser, string>(builder => { builder.WithDataverse(dataverserBuilder => { dataverserBuilder.Settings.Prefix = \"repo_\"; dataverserBuilder.Settings.SolutionName = \"TestAlessandro\"; if (configuration != null) dataverserBuilder.Settings.SetConnection(configuration[\"ConnectionString:Dataverse:Environment\"], new(configuration[\"ConnectionString:Dataverse:ClientId\"], configuration[\"ConnectionString:Dataverse:ClientSecret\"])); }); builder .AddBusiness() .AddBusinessBeforeInsert<CalamityUniverseUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<CalamityUniverseUserBeforeInsertBusiness2>(); }); You found the IRepository in DI to play with it. Configure database after build You have to run a method after the service collection build during startup. This method creates your tables. var app = builder.Build(); await app.Services.WarmUpAsync(); Automated api with Rystem.RepositoryFramework.Api.Server package With automated api, you may have the api implemented with your dataverse integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Rystem.RepositoryFramework.Infrastructure.Dynamics.Dataverse"},{"location":"Rystem.RepositoryFramework.Infrastructure.Dynamics.Dataverse/#integration-with-dataverse-dynamics-and-repository-framework","text":"Example from unit test with a business integration too. services. AddRepository<CalamityUniverseUser, string>(builder => { builder.WithDataverse(dataverserBuilder => { dataverserBuilder.Settings.Prefix = \"repo_\"; dataverserBuilder.Settings.SolutionName = \"TestAlessandro\"; if (configuration != null) dataverserBuilder.Settings.SetConnection(configuration[\"ConnectionString:Dataverse:Environment\"], new(configuration[\"ConnectionString:Dataverse:ClientId\"], configuration[\"ConnectionString:Dataverse:ClientSecret\"])); }); builder .AddBusiness() .AddBusinessBeforeInsert<CalamityUniverseUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<CalamityUniverseUserBeforeInsertBusiness2>(); }); You found the IRepository in DI to play with it.","title":"Integration with Dataverse (Dynamics) and Repository Framework"},{"location":"Rystem.RepositoryFramework.Infrastructure.Dynamics.Dataverse/#configure-database-after-build","text":"You have to run a method after the service collection build during startup. This method creates your tables. var app = builder.Build(); await app.Services.WarmUpAsync();","title":"Configure database after build"},{"location":"Rystem.RepositoryFramework.Infrastructure.Dynamics.Dataverse/#automated-api-with-rystemrepositoryframeworkapiserver-package","text":"With automated api, you may have the api implemented with your dataverse integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Automated api with Rystem.RepositoryFramework.Api.Server package"},{"location":"Rystem.RepositoryFramework.Infrastructure.EntityFramework/","text":"Integration with Entity Framework and Repository Framework Example from unit test with a business integration too. services.AddDbContext<SampleContext>(options => { options.UseSqlServer(configuration[\"ConnectionString:Database\"]); }, ServiceLifetime.Scoped); services .AddRepository<MappingUser, int>(builder => { builder.WithEntityFramework<MappingUser, int, User, SampleContext>( t => { t.DbSet = x => x.Users; t.References = x => x.Include(x => x.IdGruppos); }); builder.Translate<User>() .With(x => x.Username, x => x.Nome) .With(x => x.Username, x => x.Cognome) .With(x => x.Email, x => x.IndirizzoElettronico) .With(x => x.Groups, x => x.IdGruppos) .With(x => x.Id, x => x.Identificativo) .WithKey(x => x, x => x.Identificativo); builder .AddBusiness() .AddBusinessBeforeInsert<MappingUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<MappingUserBeforeInsertBusiness2>(); }); You found the IRepository in DI to play with it. Automated api with Rystem.RepositoryFramework.Api.Server package With automated api, you may have the api implemented with your dataverse integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Rystem.RepositoryFramework.Infrastructure.EntityFramework"},{"location":"Rystem.RepositoryFramework.Infrastructure.EntityFramework/#integration-with-entity-framework-and-repository-framework","text":"Example from unit test with a business integration too. services.AddDbContext<SampleContext>(options => { options.UseSqlServer(configuration[\"ConnectionString:Database\"]); }, ServiceLifetime.Scoped); services .AddRepository<MappingUser, int>(builder => { builder.WithEntityFramework<MappingUser, int, User, SampleContext>( t => { t.DbSet = x => x.Users; t.References = x => x.Include(x => x.IdGruppos); }); builder.Translate<User>() .With(x => x.Username, x => x.Nome) .With(x => x.Username, x => x.Cognome) .With(x => x.Email, x => x.IndirizzoElettronico) .With(x => x.Groups, x => x.IdGruppos) .With(x => x.Id, x => x.Identificativo) .WithKey(x => x, x => x.Identificativo); builder .AddBusiness() .AddBusinessBeforeInsert<MappingUserBeforeInsertBusiness>() .AddBusinessBeforeInsert<MappingUserBeforeInsertBusiness2>(); }); You found the IRepository in DI to play with it.","title":"Integration with Entity Framework and Repository Framework"},{"location":"Rystem.RepositoryFramework.Infrastructure.EntityFramework/#automated-api-with-rystemrepositoryframeworkapiserver-package","text":"With automated api, you may have the api implemented with your dataverse integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Automated api with Rystem.RepositoryFramework.Api.Server package"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/","text":"In memory integration by default With this library you can add in memory integration with the chance to create random data with random values, random based on regular expressions and delegated methods How to populate with random data? Simple random (example) Populate your in memory storage with 120 users var builder = WebApplication.CreateBuilder(args); builder.Services.AddRepository<IperUser, string>(repositoryBuilder => { repositoryBuilder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); repositoryBuilder .AddBusiness() .AddBusinessBeforeInsert<IperRepositoryBeforeInsertBusiness>(); repositoryBuilder .Translate<IperUser>(); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); Simple random with regex (example) Populate your in memory storage with 100 users and property Email with a random regex @\"[a-z]{4,10}@gmail.com\" .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100) .WithPattern(x => x.Email, @\"[a-z]{4,10}@gmail\\.com\") }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); Where can I use the regex pattern? You can use regex pattern on all primitives type and most used structs. Complete list: int, uint, byte, sbyte, short, ushort, long, ulong, nint, nuint, float, double, decimal, bool, char, Guid, DateTime, TimeSpan, Range, string, int?, uint?, byte?, sbyte?, short?, ushort?, long?, ulong?, nint?, nuint?, float?, double?, decimal?, bool?, char?, Guid?, DateTime?, TimeSpan?, Range?, string? You can use the pattern in Class, IEnumerable, IDictionary, or Array, and in everything that extends IEnumerable or IDictionary Important!! You can override regex service in your DI public static IServiceCollection AddRegexService<T>( this IServiceCollection services) where T : class, IRegexService IEnumerable or Array one-dimension (example) You have your model x (User) that has a property Groups as IEnumerable or something that extends IEnumerable, Groups is a class with a property Id as string. In the code below you are creating a list of class Groups with 8 elements in each 100 User instances, in each element of Groups you randomize based on this regex \"[a-z]{4,5}\". You may take care of use First() linq method to set correctly the Id property. .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 8) .WithPattern(x => x.Groups!.First().Id, \"[a-z]{4,5}\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); IDictionary (example) Similar to IEnumerable population you may populate your Claims property (a dictionary) with random key but with values based on regular expression \"[a-z]{4,5}\". As well as IEnumerable implementation you will have 6 elements (because I choose to create 6 elements in Populate method) .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 6) .WithPattern(x => x.Claims!.First().Value, \"[a-z]{4,5}\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); or if you have in Value an object AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 6) .WithPattern(x => x.Claims!.First().Value.SomeProperty, \"[a-z]{4,5}\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); Populate with delegation Similar to regex pattern, you can use a delegation to populate something. Dictionary (example) Here you can see that all 6 elements in each 100 users are populated in Value with string \"A\" .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 6) .WithPattern(x => x.Claims!.First().Value, () => \"A\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); Populate with Implementation If you have an interface or abstraction in your model, you can specify an implementation type for population. You have two different methods, with typeof .AddRepository<PopulationTest, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 2) .WithImplementation(x => x.I, typeof(MyInnerInterfaceImplementation)); }); }); or generics .AddRepository<PopulationTest, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100) .WithImplementation<IInnerInterface, MyInnerInterfaceImplementation>(x => x.I!); }); }); In Memory, simulate real implementation If you want to test with possible exceptions (for your reliability tests) and waiting time (for your load tests) you may do it with this library and in memory behavior settings. Add random exceptions You can set different custom exceptions and different percentage for each operation: Delete, Get, Insert, Update, Query. In the code below I'm adding three exceptions with a percentage of throwing them, they are the same for each operation. I have a 0.45% for normal Exception, 0.1% for \"Big Exception\" and 0.548% for \"Great Exception\" .AddRepository<Car, string>(settings => { settings.WithInMemory(builder => { var customExceptions = new List<ExceptionOdds> { new ExceptionOdds() { Exception = new Exception(\"Normal Exception\"), Percentage = 10.352 }, new ExceptionOdds() { Exception = new Exception(\"Big Exception\"), Percentage = 49.1 }, new ExceptionOdds() { Exception = new Exception(\"Great Exception\"), Percentage = 40.548 } }; builder.Settings.AddForRepositoryPattern(new MethodBehaviorSetting { ExceptionOdds = customExceptions }); }); }); Add random waiting time You can set different range in milliseconds for each operation to simulate the await of an external integration. In the code below I'm adding a same custom range for all Repository interfaces between 1000ms and 2000ms. .AddRepository<User, string>(builder => { builder.WithInMemory(inMemoryBuilder => { var customRange = new Range(1000, 2000); inMemoryBuilder.Settings.AddForRepositoryPattern(new MethodBehaviorSetting { MillisecondsOfWait = customRange }); }); });","title":"Rystem.RepositoryFramework.Infrastructure.InMemory"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#in-memory-integration-by-default","text":"With this library you can add in memory integration with the chance to create random data with random values, random based on regular expressions and delegated methods","title":"In memory integration by default"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#how-to-populate-with-random-data","text":"","title":"How to populate with random data?"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#simple-random-example","text":"Populate your in memory storage with 120 users var builder = WebApplication.CreateBuilder(args); builder.Services.AddRepository<IperUser, string>(repositoryBuilder => { repositoryBuilder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(120, 5) .WithPattern(x => x.Value.Email, @\"[a-z]{5,10}@gmail\\.com\"); }); repositoryBuilder .AddBusiness() .AddBusinessBeforeInsert<IperRepositoryBeforeInsertBusiness>(); repositoryBuilder .Translate<IperUser>(); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync();","title":"Simple random (example)"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#simple-random-with-regex-example","text":"Populate your in memory storage with 100 users and property Email with a random regex @\"[a-z]{4,10}@gmail.com\" .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100) .WithPattern(x => x.Email, @\"[a-z]{4,10}@gmail\\.com\") }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync();","title":"Simple random with regex (example)"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#where-can-i-use-the-regex-pattern","text":"You can use regex pattern on all primitives type and most used structs.","title":"Where can I use the regex pattern?"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#complete-list","text":"","title":"Complete list:"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#int-uint-byte-sbyte-short-ushort-long-ulong-nint-nuint-float-double-decimal-bool-char-guid-datetime-timespan-range-string-int-uint-byte-sbyte-short-ushort-long-ulong-nint-nuint-float-double-decimal-bool-char-guid-datetime-timespan-range-string","text":"You can use the pattern in Class, IEnumerable, IDictionary, or Array, and in everything that extends IEnumerable or IDictionary Important!! You can override regex service in your DI public static IServiceCollection AddRegexService<T>( this IServiceCollection services) where T : class, IRegexService","title":"int, uint, byte, sbyte, short, ushort, long, ulong, nint, nuint, float, double, decimal, bool, char, Guid, DateTime, TimeSpan, Range, string, int?, uint?, byte?, sbyte?, short?, ushort?, long?, ulong?, nint?, nuint?, float?, double?, decimal?, bool?, char?, Guid?, DateTime?, TimeSpan?, Range?, string?"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#ienumerable-or-array-one-dimension-example","text":"You have your model x (User) that has a property Groups as IEnumerable or something that extends IEnumerable, Groups is a class with a property Id as string. In the code below you are creating a list of class Groups with 8 elements in each 100 User instances, in each element of Groups you randomize based on this regex \"[a-z]{4,5}\". You may take care of use First() linq method to set correctly the Id property. .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 8) .WithPattern(x => x.Groups!.First().Id, \"[a-z]{4,5}\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync();","title":"IEnumerable or Array one-dimension (example)"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#idictionary-example","text":"Similar to IEnumerable population you may populate your Claims property (a dictionary) with random key but with values based on regular expression \"[a-z]{4,5}\". As well as IEnumerable implementation you will have 6 elements (because I choose to create 6 elements in Populate method) .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 6) .WithPattern(x => x.Claims!.First().Value, \"[a-z]{4,5}\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync(); or if you have in Value an object AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 6) .WithPattern(x => x.Claims!.First().Value.SomeProperty, \"[a-z]{4,5}\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync();","title":"IDictionary (example)"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#populate-with-delegation","text":"Similar to regex pattern, you can use a delegation to populate something.","title":"Populate with delegation"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#dictionary-example","text":"Here you can see that all 6 elements in each 100 users are populated in Value with string \"A\" .AddRepository<User, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 6) .WithPattern(x => x.Claims!.First().Value, () => \"A\"); }); }); and in app after build during startup of your application var app = builder.Build(); await app.Services.WarmUpAsync();","title":"Dictionary (example)"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#populate-with-implementation","text":"If you have an interface or abstraction in your model, you can specify an implementation type for population. You have two different methods, with typeof .AddRepository<PopulationTest, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100, 2) .WithImplementation(x => x.I, typeof(MyInnerInterfaceImplementation)); }); }); or generics .AddRepository<PopulationTest, string>(builder => { builder .WithInMemory(inMemoryBuilder => { inMemoryBuilder .PopulateWithRandomData(100) .WithImplementation<IInnerInterface, MyInnerInterfaceImplementation>(x => x.I!); }); });","title":"Populate with Implementation"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#in-memory-simulate-real-implementation","text":"If you want to test with possible exceptions (for your reliability tests) and waiting time (for your load tests) you may do it with this library and in memory behavior settings.","title":"In Memory, simulate real implementation"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#add-random-exceptions","text":"You can set different custom exceptions and different percentage for each operation: Delete, Get, Insert, Update, Query. In the code below I'm adding three exceptions with a percentage of throwing them, they are the same for each operation. I have a 0.45% for normal Exception, 0.1% for \"Big Exception\" and 0.548% for \"Great Exception\" .AddRepository<Car, string>(settings => { settings.WithInMemory(builder => { var customExceptions = new List<ExceptionOdds> { new ExceptionOdds() { Exception = new Exception(\"Normal Exception\"), Percentage = 10.352 }, new ExceptionOdds() { Exception = new Exception(\"Big Exception\"), Percentage = 49.1 }, new ExceptionOdds() { Exception = new Exception(\"Great Exception\"), Percentage = 40.548 } }; builder.Settings.AddForRepositoryPattern(new MethodBehaviorSetting { ExceptionOdds = customExceptions }); }); });","title":"Add random exceptions"},{"location":"Rystem.RepositoryFramework.Infrastructure.InMemory/#add-random-waiting-time","text":"You can set different range in milliseconds for each operation to simulate the await of an external integration. In the code below I'm adding a same custom range for all Repository interfaces between 1000ms and 2000ms. .AddRepository<User, string>(builder => { builder.WithInMemory(inMemoryBuilder => { var customRange = new Range(1000, 2000); inMemoryBuilder.Settings.AddForRepositoryPattern(new MethodBehaviorSetting { MillisecondsOfWait = customRange }); }); });","title":"Add random waiting time"},{"location":"Rystem.RepositoryFramework.Infrastructure.MsSql/","text":"Integration with MsSql and Repository Framework Example from unit test with a business integration too. services. AddRepository<Cat, Guid>(settings => { settings .WithMsSql(builder => { builder.Schema = \"repo\"; builder.ConnectionString = configuration[\"ConnectionString:Database\"]; builder.WithPrimaryKey(x => x.Id, x => { x.ColumnName = \"Key\"; }) .WithColumn(x => x.Paws, x => { x.ColumnName = \"Zampe\"; x.IsNullable = true; }); }); }); You found the IRepository in DI to play with it. Configure database after build You have to run a method after the service collection build during startup. This method creates your tables. var app = builder.Build(); await app.Services.WarmUpAsync(); Automated api with Rystem.RepositoryFramework.Api.Server package With automated api, you may have the api implemented with your dataverse integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Rystem.RepositoryFramework.Infrastructure.MsSql"},{"location":"Rystem.RepositoryFramework.Infrastructure.MsSql/#integration-with-mssql-and-repository-framework","text":"Example from unit test with a business integration too. services. AddRepository<Cat, Guid>(settings => { settings .WithMsSql(builder => { builder.Schema = \"repo\"; builder.ConnectionString = configuration[\"ConnectionString:Database\"]; builder.WithPrimaryKey(x => x.Id, x => { x.ColumnName = \"Key\"; }) .WithColumn(x => x.Paws, x => { x.ColumnName = \"Zampe\"; x.IsNullable = true; }); }); }); You found the IRepository in DI to play with it.","title":"Integration with MsSql and Repository Framework"},{"location":"Rystem.RepositoryFramework.Infrastructure.MsSql/#configure-database-after-build","text":"You have to run a method after the service collection build during startup. This method creates your tables. var app = builder.Build(); await app.Services.WarmUpAsync();","title":"Configure database after build"},{"location":"Rystem.RepositoryFramework.Infrastructure.MsSql/#automated-api-with-rystemrepositoryframeworkapiserver-package","text":"With automated api, you may have the api implemented with your dataverse integration. You need only to add the AddApiFromRepositoryFramework and UseApiForRepositoryFramework builder.Services.AddApiFromRepositoryFramework() .WithDescriptiveName(\"Repository Api\") .WithPath(Path) .WithSwagger() .WithVersion(Version) .WithDocumentation() .WithDefaultCors(\"http://example.com\"); var app = builder.Build(); app.UseApiFromRepositoryFramework() .WithNoAuthorization();","title":"Automated api with Rystem.RepositoryFramework.Api.Server package"},{"location":"Rystem.RepositoryFramework.MigrationTools/","text":"Migration Tools You need to create a base model as a bridge for your migration. After that you can use the two repositories with repository pattern to help yourself with the migration from a old storage to a brand new storage. Sample with in memory integration (From UnitTest) For instance you can create two repositories, one as source and one as target. In the example we use an easy test integration with two in memory integrations. .AddRepository<SuperMigrationUser, string>(builder => { builder.WithInMemory(builder => { builder .PopulateWithRandomData(NumberOfItems); }, \"source\"); }) .AddRepository<SuperMigrationUser, string>(builder => { builder.WithInMemory(builder => { builder .PopulateWithRandomData(NumberOfItems); }, \"target\"); }) .AddMigrationManager<SuperMigrationUser, string>(settings => { settings.SourceFactoryName = \"source\"; settings.DestinationFactoryName = \"target\"; settings.NumberOfConcurrentInserts = 10; }) Now you may use the interface in DI IMigrationManager<SuperMigrationUser, string> migrationService and let the sorcery happens var migrationResult = await _migrationService.MigrateAsync(x => x.Id!, true); Parameters Name Description Expression > navigationKey Explain how to create the TKey from the TValue bool checkIfExists = false check existence on target before download from source bool deleteEverythingBeforeStart = false delete all items before starting the migration from target","title":"Rystem.RepositoryFramework.MigrationTools"},{"location":"Rystem.RepositoryFramework.MigrationTools/#migration-tools","text":"You need to create a base model as a bridge for your migration. After that you can use the two repositories with repository pattern to help yourself with the migration from a old storage to a brand new storage.","title":"Migration Tools"},{"location":"Rystem.RepositoryFramework.MigrationTools/#sample-with-in-memory-integration-from-unittest","text":"For instance you can create two repositories, one as source and one as target. In the example we use an easy test integration with two in memory integrations. .AddRepository<SuperMigrationUser, string>(builder => { builder.WithInMemory(builder => { builder .PopulateWithRandomData(NumberOfItems); }, \"source\"); }) .AddRepository<SuperMigrationUser, string>(builder => { builder.WithInMemory(builder => { builder .PopulateWithRandomData(NumberOfItems); }, \"target\"); }) .AddMigrationManager<SuperMigrationUser, string>(settings => { settings.SourceFactoryName = \"source\"; settings.DestinationFactoryName = \"target\"; settings.NumberOfConcurrentInserts = 10; }) Now you may use the interface in DI IMigrationManager<SuperMigrationUser, string> migrationService and let the sorcery happens var migrationResult = await _migrationService.MigrateAsync(x => x.Id!, true);","title":"Sample with in memory integration (From UnitTest)"},{"location":"Rystem.RepositoryFramework.MigrationTools/#parameters","text":"Name Description Expression > navigationKey Explain how to create the TKey from the TValue bool checkIfExists = false check existence on target before download from source bool deleteEverythingBeforeStart = false delete all items before starting the migration from target","title":"Parameters"},{"location":"Rystem.RepositoryFramework.Web.Components/","text":"Add to service collection the UI service in your blazor DI You have to add a service for UI builder.Services .AddRepositoryUI(); and add the endpoint for your repository app .AddDefaultRepositoryEndpoints(); Demand everything to the framework In the Host.cshtml you have to add style, javascript files and the RepositoryApp. <html> <head> <!-- inside of head section --> <partial name=\"RepositoryStyle\" /> </head> <body> <component type=\"typeof(RepositoryApp<App>)\" render-mode=\"ServerPrerendered\" /> <!-- inside of body section and after the div/app tag --> <partial name=\"RepositoryScript\" /> </body> </html> Instead of \"App\" class you can use every class in your DLL, but remember the class needs to be inside your blazor/razor application. Demand everything to the framework with authentication In the Host.cshtml you have to add style, javascript files and the RepositoryAuthenticatedApp. <html> <head> <!-- inside of head section --> <partial name=\"RepositoryStyle\" /> </head> <body> <component type=\"typeof(RepositoryAuthenticatedApp<App>)\" render-mode=\"ServerPrerendered\" /> <!-- inside of body section and after the div/app tag --> <partial name=\"RepositoryScript\" /> </body> </html> Instead of \"App\" class you can use every class in your DLL, but remember the class needs to be inside your blazor/razor application. Use razor component instead to build your mixed custom repository UI In the Host.cshtml you have to add style, javascript files <html> <head> <!-- inside of head section --> <partial name=\"RepositoryStyle\" /> </head> <body> <component type=\"typeof(App)\" render-mode=\"ServerPrerendered\" /> <!-- inside of body section and after the div/app tag --> <partial name=\"RepositoryScript\" /> </body> </html> In your app you can use Component Usage RepositoryManager A component to manage your repository in one page","title":"Rystem.RepositoryFramework.Web.Components"},{"location":"Rystem.RepositoryFramework.Web.Components/#add-to-service-collection-the-ui-service-in-your-blazor-di","text":"You have to add a service for UI builder.Services .AddRepositoryUI(); and add the endpoint for your repository app .AddDefaultRepositoryEndpoints();","title":"Add to service collection the UI service in your blazor DI"},{"location":"Rystem.RepositoryFramework.Web.Components/#demand-everything-to-the-framework","text":"In the Host.cshtml you have to add style, javascript files and the RepositoryApp. <html> <head> <!-- inside of head section --> <partial name=\"RepositoryStyle\" /> </head> <body> <component type=\"typeof(RepositoryApp<App>)\" render-mode=\"ServerPrerendered\" /> <!-- inside of body section and after the div/app tag --> <partial name=\"RepositoryScript\" /> </body> </html> Instead of \"App\" class you can use every class in your DLL, but remember the class needs to be inside your blazor/razor application.","title":"Demand everything to the framework"},{"location":"Rystem.RepositoryFramework.Web.Components/#demand-everything-to-the-framework-with-authentication","text":"In the Host.cshtml you have to add style, javascript files and the RepositoryAuthenticatedApp. <html> <head> <!-- inside of head section --> <partial name=\"RepositoryStyle\" /> </head> <body> <component type=\"typeof(RepositoryAuthenticatedApp<App>)\" render-mode=\"ServerPrerendered\" /> <!-- inside of body section and after the div/app tag --> <partial name=\"RepositoryScript\" /> </body> </html> Instead of \"App\" class you can use every class in your DLL, but remember the class needs to be inside your blazor/razor application.","title":"Demand everything to the framework with authentication"},{"location":"Rystem.RepositoryFramework.Web.Components/#use-razor-component-instead-to-build-your-mixed-custom-repository-ui","text":"In the Host.cshtml you have to add style, javascript files <html> <head> <!-- inside of head section --> <partial name=\"RepositoryStyle\" /> </head> <body> <component type=\"typeof(App)\" render-mode=\"ServerPrerendered\" /> <!-- inside of body section and after the div/app tag --> <partial name=\"RepositoryScript\" /> </body> </html> In your app you can use Component Usage RepositoryManager A component to manage your repository in one page","title":"Use razor component instead to build your mixed custom repository UI"},{"location":"Rystem.Test.XUnit/","text":"You have to add a startup class in your test project to initialize the Rystem XUnit helpers. public class Startup : StartupHelper { protected override string? AppSettingsFileName => \"appsettings.test.json\"; protected override bool HasTestHost => true; protected override Type? TypeToChooseTheRightAssemblyToRetrieveSecretsForConfiguration => typeof(Startup); protected override Type? TypeToChooseTheRightAssemblyWithControllersToMap => typeof(ServiceController); protected override IServiceCollection ConfigureCientServices(IServiceCollection services) { services.AddHttpClient(\"client\", x => { x.BaseAddress = new Uri(\"http://localhost\"); }); return services; } protected override ValueTask ConfigureServerMiddlewaresAsync(IApplicationBuilder applicationBuilder, IServiceProvider serviceProvider) { applicationBuilder.UseTestApplication(); return ValueTask.CompletedTask; } protected override ValueTask ConfigureServerServicesAsync(IServiceCollection services, IConfiguration configuration) { services.AddTestServices(); return ValueTask.CompletedTask; } } TypeToChooseTheRightAssemblyToRetrieveSecretsForConfiguration This property is the Type to discover the right assembly to retrieve secrets.\\ TypeToChooseTheRightAssemblyWithControllersToMap This property is the Type to discover the right assembly to map controllers automatically.\\ AppSettingsFileName This property is the name of the appsettings file to load the configuration. HasTestHost This property allows the Test server to start. You have to override ConfigureServerMiddlewaresAsync and ConfigureServerServicesAsync . applicationBuilder.UseTestApplication() is an example of your middlewares from your api project. public static IApplicationBuilder UseTestApplication(this IApplicationBuilder app) { app.UseRuntimeServiceProvider(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(x => { x.MapControllers(); }); return app; } and with the same behavior services.AddTestServices(); adds the services from your api project. public static IServiceCollection AddTestServices(this IServiceCollection services) { services.AddRuntimeServiceProvider(); services.AddControllers(); services.AddEndpointsApiExplorer(); services.AddSingleton<SingletonService>(); services.AddSingleton<Singleton2Service>(); services.AddScoped<ScopedService>(); services.AddScoped<Scoped2Service>(); services.AddTransient<TransientService>(); services.AddTransient<Transient2Service>(); return services; } ConfigureCientServices This method configure the DI in your XUnit test project. Usually you need to inject the http client to test your api if you need the test server. services.AddHttpClient(\"client\", x => { x.BaseAddress = new Uri(\"http://localhost\"); });","title":"Rystem.Test.XUnit"},{"location":"Rystem.Test.XUnit/#typetochoosetherightassemblytoretrievesecretsforconfiguration","text":"This property is the Type to discover the right assembly to retrieve secrets.\\","title":"TypeToChooseTheRightAssemblyToRetrieveSecretsForConfiguration"},{"location":"Rystem.Test.XUnit/#typetochoosetherightassemblywithcontrollerstomap","text":"This property is the Type to discover the right assembly to map controllers automatically.\\","title":"TypeToChooseTheRightAssemblyWithControllersToMap"},{"location":"Rystem.Test.XUnit/#appsettingsfilename","text":"This property is the name of the appsettings file to load the configuration.","title":"AppSettingsFileName"},{"location":"Rystem.Test.XUnit/#hastesthost","text":"This property allows the Test server to start. You have to override ConfigureServerMiddlewaresAsync and ConfigureServerServicesAsync . applicationBuilder.UseTestApplication() is an example of your middlewares from your api project. public static IApplicationBuilder UseTestApplication(this IApplicationBuilder app) { app.UseRuntimeServiceProvider(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(x => { x.MapControllers(); }); return app; } and with the same behavior services.AddTestServices(); adds the services from your api project. public static IServiceCollection AddTestServices(this IServiceCollection services) { services.AddRuntimeServiceProvider(); services.AddControllers(); services.AddEndpointsApiExplorer(); services.AddSingleton<SingletonService>(); services.AddSingleton<Singleton2Service>(); services.AddScoped<ScopedService>(); services.AddScoped<Scoped2Service>(); services.AddTransient<TransientService>(); services.AddTransient<Transient2Service>(); return services; }","title":"HasTestHost"},{"location":"Rystem.Test.XUnit/#configurecientservices","text":"This method configure the DI in your XUnit test project. Usually you need to inject the http client to test your api if you need the test server. services.AddHttpClient(\"client\", x => { x.BaseAddress = new Uri(\"http://localhost\"); });","title":"ConfigureCientServices"},{"location":"Rystem/","text":"Extension methods Stopwatch You can monitor the time spent on an action, task or in a method. Some examples from Unit test. var started = Stopwatch.Start(); //do something await Task.Delay(2000); var result = started.Stop(); or var result = await Stopwatch.MonitorAsync(async () => { await Task.Delay(2000); }); or with a return value var result = await Stopwatch.MonitorAsync(async () => { await Task.Delay(2000); return 3; }); Linq expression serializer Usually a linq expression is not serializable as string. With this method you can serialize your expression with some limits. Only primitives are allowed in the expression body. An example from Unit test. Expression<Func<MakeIt, bool>> expression = \u0192 => \u0192.X == q && \u0192.Samules.Any(x => x == k) && \u0192.Sol && (\u0192.X.Contains(q) || \u0192.Sol.Equals(IsOk)) && (\u0192.E == id | \u0192.Id == V) && (\u0192.Type == MakeType.Yes || \u0192.Type == qq); var serialized = expression.Serialize(); with result \"\u0192 => ((((((\u0192.X == \\\"dasda\\\") AndAlso \u0192.Samules.Any(x => (x == \\\"ccccde\\\"))) AndAlso \u0192.Sol) AndAlso (\u0192.X.Contains(\\\"dasda\\\") OrElse \u0192.Sol.Equals(True))) AndAlso ((\u0192.E == Guid.Parse(\\\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\\\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2)))\" with deserialization var newExpression = expressionAsString.Deserialize<MakeIt, bool>(); and usage, for instance, with Linq var result = makes.Where(newExpression.Compile()).ToList(); you can deserialize and compile at the same time with var newExpression = expressionAsString.DeserializeAndCompile<MakeIt, bool>(); you can deserialize as dynamic and use the linq dynamic methods Expression<Func<MakeIt, int>> expression = x => x.Id; string value = expression.Serialize(); LambdaExpression newLambda = value.DeserializeAsDynamic<MakeIt>(); var got = makes.AsQueryable(); var cut = got.OrderByDescending(newLambda).ThenByDescending(newLambda).ToList(); please see the unit test here to understand better how it works You may deal with return type of your lambda expression: LambdaExpression newLambda = value.DeserializeAsDynamic<MakeIt>(); newLambda = newLambda.ChangeReturnType<bool>(); or newLambda = newLambda.ChangeReturnType(typeof(bool)); Reflection helper Name of calling class You can find the name of the calling class from your method, with deep = 1 the calling class of your method, with deep = 2 the calling class that calls the class that calls your method, and so on, with fullName set to true you obtain the complete name of the discovered class. ReflectionHelper.NameOfCallingClass(deep, fullName); Extensions for Type class You can get the properties, fields and constructors for your class (and singleton them to save time during new requests) Type.FetchProperties(); Type.FecthConstructors(); Type.FetchFields(); You can check if a Type is a son or a father or both of other type (in the example Zalo and Folli are Sulo). You may find more information in unit test here Zalo zalo = new(); Zalo zalo2 = new(); Folli folli = new(); Sulo sulo = new(); object quo = new(); int x = 2; decimal y = 3; Assert.True(zalo.IsTheSameTypeOrASon(sulo)); Assert.True(folli.IsTheSameTypeOrASon(sulo)); Assert.True(zalo.IsTheSameTypeOrASon(zalo2)); Assert.True(zalo.IsTheSameTypeOrASon(quo)); Assert.False(sulo.IsTheSameTypeOrASon(zalo)); Assert.True(sulo.IsTheSameTypeOrAParent(zalo)); Assert.False(y.IsTheSameTypeOrAParent(x)); Mock a Type If you need to create a type over an abstract class or interface you may use the mocking system of Rystem. For example, if you have an abstract class like this one down below. public abstract class Alzio { private protected string X { get; } public string O => X; public string A { get; set; } public Alzio(string x) { X = x; } } you can create an instace of it or simply mock it with var mocked = typeof(Alzio).CreateInstance(\"AAA\") as Alzio; mocked.A = \"rrrr\"; and you can use the class like a real class. You also may do it with Alzio alzio = null!; var mocked = alzio.CreateInstance(\"AAA\"); mocked.A = \"rrrr\"; or Mocking.CreateInstance<Alzio>(\"AAA\"); you may see \"AAA\" as argument for your constructor in abstract class. Check nullability for properties, fields and parameters. Following an example from unit test. private sealed class InModel { public string? A { get; set; } public string B { get; set; } public string? C; public string D; public InModel(string? b, string c) { A = b; B = c; } public void SetSomething(string? b, string c) { A = b; B = c; } } [Fact] public void Test1() { var type = typeof(InModel); var constructorParameters = type.GetConstructors().First().GetParameters().ToList(); Assert.True(constructorParameters[0].IsNullable()); Assert.False(constructorParameters[1].IsNullable()); var methodParameters = type.GetMethod(nameof(InModel.SetSomething)).GetParameters().ToList(); Assert.True(methodParameters[0].IsNullable()); Assert.False(methodParameters[1].IsNullable()); var properties = type.GetProperties().ToList(); Assert.True(properties[0].IsNullable()); Assert.False(properties[1].IsNullable()); var fields = type.GetFields().ToList(); Assert.True(fields[0].IsNullable()); Assert.False(fields[1].IsNullable()); } Text extensions You may convert as fast as possible byte[] to string or stream to byte[] or byte[] to stream or stream to string or string to stream. For example, string to byte array and viceversa. string olfa = \"daskemnlandxioasndslam dasmdpoasmdnasndaslkdmlasmv asmdsa\"; var bytes = olfa.ToByteArray(); string value = bytes.ConvertToString(); For example, string to stream and viceversa. string olfa = \"daskemnlandxioasndslam dasmdpoasmdnasndaslkdmlasmv asmdsa\"; var stream = olfa.ToStream(); string value = stream.ConvertToString(); You may read a string with break lines as an enumerable of string string olfa = \"daskemnlandxioasndslam\\ndasmdpoasmdnasndaslkdmlasmv\\nasmdsa\"; var stream = olfa.ToStream(); var strings = new List<string>(); await foreach (var x in stream.ReadLinesAsync()) { strings.Add(x); } A simple method to make uppercase the first character. string olfa = \"dasda\"; var olfa2 = olfa.ToUpperCaseFirst(); A simple method to check if a char is contained at least X times. string value = \"abcderfa\"; bool containsAtLeastTwoAChar = value.ContainsAtLeast(2, 'a'); Character separated-value (CSV) Transform any kind of IEnumerable data in a CSV string. string value = _models.ToCsv(); Minimization of a model (based on CSV concept) It's a brand new idea to serialize any kind of objects (with lesser occupied space of json), the idea comes from Command separated-value standard. To serialize string value = _models.ToMinimize(); To deserialize (for instance in a List of a class named CsvModel) value.FromMinimization<List<CsvModel>>(); Extensions for json I don't know if you are fed up to write JsonSerializer.Serialize, I do, and so, you may use the extension method to serialize faster. To serialize var text = value.ToJson(); To deserialize in a class (for instance a class named User) var value = text.FromJson<User>(); Extensions for Task I don't know if you still are fed up to write .ConfigureAwait(false) to eliminate the context waiting for a task. I do. Why should I set the configure await to false? To set configure await to false await {your async task}.NoContext(); Instead, to get the result as synchronous result but with a configure await set to false. {your async task}.ToResult(); You may change the behavior of your NoContext() or ToResult(), setting (in the bootstrap of your application for example) RystemTask.WaitYourStartingThread = true; When do I need a true? In windows application for example you have to return after a button clicked to the same thread that started the request. TaskManager When you need to run a list of tasks concurrently you may use this static method. In the next example with TaskManager.WhenAll you may run a method ExecuteAsync {times} times with {concurrentTasks} times in concurrency, and running them when a time slot is free. For example if you run this function with 8 times and 3 concurrentsTasks and true in runEverytimeASlotIsFree You will have this behavior: first 3 tasks starts and since the fourth the implementation waits the end of one of the 3 started before. As soon as one of the 3 started is finished the implementation starts to run the fourth. var bag = new ConcurrentBag<int>(); await TaskManager.WhenAll(ExecuteAsync, times, concurrentTasks, runEverytimeASlotIsFree).NoContext(); Assert.Equal(times, bag.Count); async Task ExecuteAsync(int i, CancellationToken cancellationToken) { await Task.Delay(i * 20, cancellationToken).NoContext(); bag.Add(i); } You may run a {atLeast} times of tasks and stopping to wait the remaining tasks with TaskManager.WhenAtLeast var bag = new ConcurrentBag<int>(); await TaskManager.WhenAtLeast(ExecuteAsync, times, atLeast, concurrentTasks).NoContext(); Assert.True(bag.Count < times); Assert.True(bag.Count >= atLeast); async Task ExecuteAsync(int i, CancellationToken cancellationToken) { await Task.Delay(i * 20, cancellationToken).NoContext(); bag.Add(i); } Concurrency ConcurrentList You can use the ConcurrentList implementation to have the List behavior with lock operations. var items = new ConcurrentList<ItemClass>();","title":"Rystem"},{"location":"Rystem/#extension-methods","text":"","title":"Extension methods"},{"location":"Rystem/#stopwatch","text":"You can monitor the time spent on an action, task or in a method. Some examples from Unit test. var started = Stopwatch.Start(); //do something await Task.Delay(2000); var result = started.Stop(); or var result = await Stopwatch.MonitorAsync(async () => { await Task.Delay(2000); }); or with a return value var result = await Stopwatch.MonitorAsync(async () => { await Task.Delay(2000); return 3; });","title":"Stopwatch"},{"location":"Rystem/#linq-expression-serializer","text":"Usually a linq expression is not serializable as string. With this method you can serialize your expression with some limits. Only primitives are allowed in the expression body. An example from Unit test. Expression<Func<MakeIt, bool>> expression = \u0192 => \u0192.X == q && \u0192.Samules.Any(x => x == k) && \u0192.Sol && (\u0192.X.Contains(q) || \u0192.Sol.Equals(IsOk)) && (\u0192.E == id | \u0192.Id == V) && (\u0192.Type == MakeType.Yes || \u0192.Type == qq); var serialized = expression.Serialize(); with result \"\u0192 => ((((((\u0192.X == \\\"dasda\\\") AndAlso \u0192.Samules.Any(x => (x == \\\"ccccde\\\"))) AndAlso \u0192.Sol) AndAlso (\u0192.X.Contains(\\\"dasda\\\") OrElse \u0192.Sol.Equals(True))) AndAlso ((\u0192.E == Guid.Parse(\\\"bf46510b-b7e6-4ba2-88da-cef208aa81f2\\\")) Or (\u0192.Id == 32))) AndAlso ((\u0192.Type == 1) OrElse (\u0192.Type == 2)))\" with deserialization var newExpression = expressionAsString.Deserialize<MakeIt, bool>(); and usage, for instance, with Linq var result = makes.Where(newExpression.Compile()).ToList(); you can deserialize and compile at the same time with var newExpression = expressionAsString.DeserializeAndCompile<MakeIt, bool>(); you can deserialize as dynamic and use the linq dynamic methods Expression<Func<MakeIt, int>> expression = x => x.Id; string value = expression.Serialize(); LambdaExpression newLambda = value.DeserializeAsDynamic<MakeIt>(); var got = makes.AsQueryable(); var cut = got.OrderByDescending(newLambda).ThenByDescending(newLambda).ToList(); please see the unit test here to understand better how it works You may deal with return type of your lambda expression: LambdaExpression newLambda = value.DeserializeAsDynamic<MakeIt>(); newLambda = newLambda.ChangeReturnType<bool>(); or newLambda = newLambda.ChangeReturnType(typeof(bool));","title":"Linq expression serializer"},{"location":"Rystem/#reflection-helper","text":"","title":"Reflection helper"},{"location":"Rystem/#name-of-calling-class","text":"You can find the name of the calling class from your method, with deep = 1 the calling class of your method, with deep = 2 the calling class that calls the class that calls your method, and so on, with fullName set to true you obtain the complete name of the discovered class. ReflectionHelper.NameOfCallingClass(deep, fullName);","title":"Name of calling class"},{"location":"Rystem/#extensions-for-type-class","text":"You can get the properties, fields and constructors for your class (and singleton them to save time during new requests) Type.FetchProperties(); Type.FecthConstructors(); Type.FetchFields(); You can check if a Type is a son or a father or both of other type (in the example Zalo and Folli are Sulo). You may find more information in unit test here Zalo zalo = new(); Zalo zalo2 = new(); Folli folli = new(); Sulo sulo = new(); object quo = new(); int x = 2; decimal y = 3; Assert.True(zalo.IsTheSameTypeOrASon(sulo)); Assert.True(folli.IsTheSameTypeOrASon(sulo)); Assert.True(zalo.IsTheSameTypeOrASon(zalo2)); Assert.True(zalo.IsTheSameTypeOrASon(quo)); Assert.False(sulo.IsTheSameTypeOrASon(zalo)); Assert.True(sulo.IsTheSameTypeOrAParent(zalo)); Assert.False(y.IsTheSameTypeOrAParent(x));","title":"Extensions for Type class"},{"location":"Rystem/#mock-a-type","text":"If you need to create a type over an abstract class or interface you may use the mocking system of Rystem. For example, if you have an abstract class like this one down below. public abstract class Alzio { private protected string X { get; } public string O => X; public string A { get; set; } public Alzio(string x) { X = x; } } you can create an instace of it or simply mock it with var mocked = typeof(Alzio).CreateInstance(\"AAA\") as Alzio; mocked.A = \"rrrr\"; and you can use the class like a real class. You also may do it with Alzio alzio = null!; var mocked = alzio.CreateInstance(\"AAA\"); mocked.A = \"rrrr\"; or Mocking.CreateInstance<Alzio>(\"AAA\"); you may see \"AAA\" as argument for your constructor in abstract class.","title":"Mock a Type"},{"location":"Rystem/#check-nullability-for-properties-fields-and-parameters","text":"Following an example from unit test. private sealed class InModel { public string? A { get; set; } public string B { get; set; } public string? C; public string D; public InModel(string? b, string c) { A = b; B = c; } public void SetSomething(string? b, string c) { A = b; B = c; } } [Fact] public void Test1() { var type = typeof(InModel); var constructorParameters = type.GetConstructors().First().GetParameters().ToList(); Assert.True(constructorParameters[0].IsNullable()); Assert.False(constructorParameters[1].IsNullable()); var methodParameters = type.GetMethod(nameof(InModel.SetSomething)).GetParameters().ToList(); Assert.True(methodParameters[0].IsNullable()); Assert.False(methodParameters[1].IsNullable()); var properties = type.GetProperties().ToList(); Assert.True(properties[0].IsNullable()); Assert.False(properties[1].IsNullable()); var fields = type.GetFields().ToList(); Assert.True(fields[0].IsNullable()); Assert.False(fields[1].IsNullable()); }","title":"Check nullability for properties, fields and parameters."},{"location":"Rystem/#text-extensions","text":"You may convert as fast as possible byte[] to string or stream to byte[] or byte[] to stream or stream to string or string to stream. For example, string to byte array and viceversa. string olfa = \"daskemnlandxioasndslam dasmdpoasmdnasndaslkdmlasmv asmdsa\"; var bytes = olfa.ToByteArray(); string value = bytes.ConvertToString(); For example, string to stream and viceversa. string olfa = \"daskemnlandxioasndslam dasmdpoasmdnasndaslkdmlasmv asmdsa\"; var stream = olfa.ToStream(); string value = stream.ConvertToString(); You may read a string with break lines as an enumerable of string string olfa = \"daskemnlandxioasndslam\\ndasmdpoasmdnasndaslkdmlasmv\\nasmdsa\"; var stream = olfa.ToStream(); var strings = new List<string>(); await foreach (var x in stream.ReadLinesAsync()) { strings.Add(x); } A simple method to make uppercase the first character. string olfa = \"dasda\"; var olfa2 = olfa.ToUpperCaseFirst(); A simple method to check if a char is contained at least X times. string value = \"abcderfa\"; bool containsAtLeastTwoAChar = value.ContainsAtLeast(2, 'a');","title":"Text extensions"},{"location":"Rystem/#character-separated-value-csv","text":"Transform any kind of IEnumerable data in a CSV string. string value = _models.ToCsv();","title":"Character separated-value (CSV)"},{"location":"Rystem/#minimization-of-a-model-based-on-csv-concept","text":"It's a brand new idea to serialize any kind of objects (with lesser occupied space of json), the idea comes from Command separated-value standard. To serialize string value = _models.ToMinimize(); To deserialize (for instance in a List of a class named CsvModel) value.FromMinimization<List<CsvModel>>();","title":"Minimization of a model (based on CSV concept)"},{"location":"Rystem/#extensions-for-json","text":"I don't know if you are fed up to write JsonSerializer.Serialize, I do, and so, you may use the extension method to serialize faster. To serialize var text = value.ToJson(); To deserialize in a class (for instance a class named User) var value = text.FromJson<User>();","title":"Extensions for json"},{"location":"Rystem/#extensions-for-task","text":"I don't know if you still are fed up to write .ConfigureAwait(false) to eliminate the context waiting for a task. I do. Why should I set the configure await to false? To set configure await to false await {your async task}.NoContext(); Instead, to get the result as synchronous result but with a configure await set to false. {your async task}.ToResult(); You may change the behavior of your NoContext() or ToResult(), setting (in the bootstrap of your application for example) RystemTask.WaitYourStartingThread = true; When do I need a true? In windows application for example you have to return after a button clicked to the same thread that started the request.","title":"Extensions for Task"},{"location":"Rystem/#taskmanager","text":"When you need to run a list of tasks concurrently you may use this static method. In the next example with TaskManager.WhenAll you may run a method ExecuteAsync {times} times with {concurrentTasks} times in concurrency, and running them when a time slot is free. For example if you run this function with 8 times and 3 concurrentsTasks and true in runEverytimeASlotIsFree You will have this behavior: first 3 tasks starts and since the fourth the implementation waits the end of one of the 3 started before. As soon as one of the 3 started is finished the implementation starts to run the fourth. var bag = new ConcurrentBag<int>(); await TaskManager.WhenAll(ExecuteAsync, times, concurrentTasks, runEverytimeASlotIsFree).NoContext(); Assert.Equal(times, bag.Count); async Task ExecuteAsync(int i, CancellationToken cancellationToken) { await Task.Delay(i * 20, cancellationToken).NoContext(); bag.Add(i); } You may run a {atLeast} times of tasks and stopping to wait the remaining tasks with TaskManager.WhenAtLeast var bag = new ConcurrentBag<int>(); await TaskManager.WhenAtLeast(ExecuteAsync, times, atLeast, concurrentTasks).NoContext(); Assert.True(bag.Count < times); Assert.True(bag.Count >= atLeast); async Task ExecuteAsync(int i, CancellationToken cancellationToken) { await Task.Delay(i * 20, cancellationToken).NoContext(); bag.Add(i); }","title":"TaskManager"},{"location":"Rystem/#concurrency","text":"","title":"Concurrency"},{"location":"Rystem/#concurrentlist","text":"You can use the ConcurrentList implementation to have the List behavior with lock operations. var items = new ConcurrentList<ItemClass>();","title":"ConcurrentList"},{"location":"repository/","text":"Repository Framework Help the project Reach out us on Discord Contribute: https://www.buymeacoffee.com/keyserdsoze Showcase (youtube) Showcase (code) Rystem.RepositoryFramework allows you to use correctly concepts like repository pattern, CQRS, DDD and automated REPR (Request-Endpoint-Response) Pattern. You have interfaces for your domains, auto-generated api, auto-generated HttpClient to simplify connection \"api to front-end\", a functionality for auto-population in memory of your models, caching, a functionality to simulate exceptions and waiting time from external sources to improve your implementation/business test and load test. Document to read before using this library: - Repository pattern, useful links: - Microsoft docs - Repository pattern explained - CQRS, useful links: - Microsoft docs - Martin Fowler - DDD, useful links: - Wikipedia - Microsoft docs - REPR (Request-Endpoint-Response) Pattern - MVC as Dinasours Basic knowledge CQRS and Repository are two sides of the same coin. Design and nuget map Logic design and flow The same flow is valid for ICommand/ICommandPattern and IQuery/IQueryPattern Important!!! Extends and use IRepository<T, TKey> and not IRepositoryPattern<T> Extends and use IQuery<T, TKey> and not IQueryPattern<T> Extends and use ICommand<T, TKey> and not ICommandPattern<T> Abstractions (Domain) You may find the documentation at this link In memory integration (Infrastructure for test purpose, load tests or functionality tests) You may find the documentation at this link Migration tools (Tool to help during a data migration) You may find the documentation at this link Api.Server (Application for automatic integration of api endpoint for your repository or CQRS) You may find the documentation at this link Api.Client (Application for http client integration of api endpoint for your repository or CQRS) You may find the documentation at this link Azure TableStorage integration (default integration) You may find the documentation at this link Azure CosmosDB SQL integration (default integration) You may find the documentation at this link Azure BlobStorage integration (default integration) You may find the documentation at this link Dynamics Dataverse integration (default integration) You may find the documentation at this link Entity Framework integration (default integration) You may find the documentation at this link MsSql integration (default integration) You may find the documentation at this link Cache integration (with in memory default integration) You may find the documentation at this link Cache with Azure BlobStorage integration (default integration) You may find the documentation at this link Web UI for dashboard You may find the documentation at this link Client Api for Typescript/Javascript solutions You may find the documentation at this link","title":"Repository"},{"location":"repository/#repository-framework","text":"","title":"Repository Framework"},{"location":"repository/#help-the-project","text":"Reach out us on Discord","title":"Help the project"},{"location":"repository/#contribute-httpswwwbuymeacoffeecomkeyserdsoze","text":"","title":"Contribute: https://www.buymeacoffee.com/keyserdsoze"},{"location":"repository/#showcase-youtube","text":"","title":"Showcase (youtube)"},{"location":"repository/#showcase-code","text":"Rystem.RepositoryFramework allows you to use correctly concepts like repository pattern, CQRS, DDD and automated REPR (Request-Endpoint-Response) Pattern. You have interfaces for your domains, auto-generated api, auto-generated HttpClient to simplify connection \"api to front-end\", a functionality for auto-population in memory of your models, caching, a functionality to simulate exceptions and waiting time from external sources to improve your implementation/business test and load test. Document to read before using this library: - Repository pattern, useful links: - Microsoft docs - Repository pattern explained - CQRS, useful links: - Microsoft docs - Martin Fowler - DDD, useful links: - Wikipedia - Microsoft docs - REPR (Request-Endpoint-Response) Pattern - MVC as Dinasours","title":"Showcase (code)"},{"location":"repository/#basic-knowledge","text":"","title":"Basic knowledge"},{"location":"repository/#cqrs-and-repository-are-two-sides-of-the-same-coin","text":"","title":"CQRS and Repository are two sides of the same coin."},{"location":"repository/#design-and-nuget-map","text":"","title":"Design and nuget map"},{"location":"repository/#logic-design-and-flow","text":"The same flow is valid for ICommand/ICommandPattern and IQuery/IQueryPattern","title":"Logic design and flow"},{"location":"repository/#important","text":"Extends and use IRepository<T, TKey> and not IRepositoryPattern<T> Extends and use IQuery<T, TKey> and not IQueryPattern<T> Extends and use ICommand<T, TKey> and not ICommandPattern<T>","title":"Important!!!"},{"location":"repository/#abstractions-domain","text":"You may find the documentation at this link","title":"Abstractions (Domain)"},{"location":"repository/#in-memory-integration-infrastructure-for-test-purpose-load-tests-or-functionality-tests","text":"You may find the documentation at this link","title":"In memory integration (Infrastructure for test purpose, load tests or functionality tests)"},{"location":"repository/#migration-tools-tool-to-help-during-a-data-migration","text":"You may find the documentation at this link","title":"Migration tools (Tool to help during a data migration)"},{"location":"repository/#apiserver-application-for-automatic-integration-of-api-endpoint-for-your-repository-or-cqrs","text":"You may find the documentation at this link","title":"Api.Server (Application for automatic integration of api endpoint for your repository or CQRS)"},{"location":"repository/#apiclient-application-for-http-client-integration-of-api-endpoint-for-your-repository-or-cqrs","text":"You may find the documentation at this link","title":"Api.Client (Application for http client integration of api endpoint for your repository or CQRS)"},{"location":"repository/#azure-tablestorage-integration-default-integration","text":"You may find the documentation at this link","title":"Azure TableStorage integration (default integration)"},{"location":"repository/#azure-cosmosdb-sql-integration-default-integration","text":"You may find the documentation at this link","title":"Azure CosmosDB SQL integration (default integration)"},{"location":"repository/#azure-blobstorage-integration-default-integration","text":"You may find the documentation at this link","title":"Azure BlobStorage integration (default integration)"},{"location":"repository/#dynamics-dataverse-integration-default-integration","text":"You may find the documentation at this link","title":"Dynamics Dataverse integration (default integration)"},{"location":"repository/#entity-framework-integration-default-integration","text":"You may find the documentation at this link","title":"Entity Framework integration (default integration)"},{"location":"repository/#mssql-integration-default-integration","text":"You may find the documentation at this link","title":"MsSql integration (default integration)"},{"location":"repository/#cache-integration-with-in-memory-default-integration","text":"You may find the documentation at this link","title":"Cache integration (with in memory default integration)"},{"location":"repository/#cache-with-azure-blobstorage-integration-default-integration","text":"You may find the documentation at this link","title":"Cache with Azure BlobStorage integration (default integration)"},{"location":"repository/#web-ui-for-dashboard","text":"You may find the documentation at this link","title":"Web UI for dashboard"},{"location":"repository/#client-api-for-typescriptjavascript-solutions","text":"You may find the documentation at this link","title":"Client Api for Typescript/Javascript solutions"},{"location":"Rystem/Rystem.Reflection/","text":"Documentation: ReflectionHelper Class in Rystem.Reflection Namespace The Rystem.Reflection namespace contains helper methods related to Reflection in .NET. One of the classes found within this namespace is ReflectionHelper . This static class contains a method to fetch the class name for a given stack frame at a specified depth. Method Details NameOfCallingClass Method Method Name : NameOfCallingClass Description : Determines the name of the class that invoked a method. It does so by examining the method execution's stack trace. The search starts from the given depth and continues upwards until a class name is found that is not from the core mscorlib.dll . Parameters : - int deep : The initial depth from which the search for the calling class begins. Default value is 1. - bool full : Flag defining whether to return the full name of the class (with namespace) or just the class name. For true , it returns the full class name including namespace. For false (default value), it returns just the class name. Return Value : string name of the calling class. If no calling class is found, the method returns the name of the method at the examined stack depth. Usage Example : string className = ReflectionHelper.NameOfCallingClass(2, true); Console.WriteLine(className); // Outputs the full name of the class that is two frames up in the stack. This method is helpful when you want to identify the class that called a particular operation, especially useful in logging or debugging scenarios. The ability to control the depth allows flexibility in terms of call stack examination. Including the invoking class name in your application logs can give you a clearer picture of the execution flow and help speed up the troubleshooting process. As such, NameOfCallingClass might be frequently used within your exception handling or logging infrastructure. Remember that, due to potential performance implications, use reflection judiciously and only when required. Always validate the stack depth you pass to avoid potential StackOverflowExceptions or arguments outside the stack trace range.","title":"Documentation: ReflectionHelper Class in Rystem.Reflection Namespace"},{"location":"Rystem/Rystem.Reflection/#documentation-reflectionhelper-class-in-rystemreflection-namespace","text":"The Rystem.Reflection namespace contains helper methods related to Reflection in .NET. One of the classes found within this namespace is ReflectionHelper . This static class contains a method to fetch the class name for a given stack frame at a specified depth.","title":"Documentation: ReflectionHelper Class in Rystem.Reflection Namespace"},{"location":"Rystem/Rystem.Reflection/#method-details","text":"","title":"Method Details"},{"location":"Rystem/Rystem.Reflection/#nameofcallingclass-method","text":"Method Name : NameOfCallingClass Description : Determines the name of the class that invoked a method. It does so by examining the method execution's stack trace. The search starts from the given depth and continues upwards until a class name is found that is not from the core mscorlib.dll . Parameters : - int deep : The initial depth from which the search for the calling class begins. Default value is 1. - bool full : Flag defining whether to return the full name of the class (with namespace) or just the class name. For true , it returns the full class name including namespace. For false (default value), it returns just the class name. Return Value : string name of the calling class. If no calling class is found, the method returns the name of the method at the examined stack depth. Usage Example : string className = ReflectionHelper.NameOfCallingClass(2, true); Console.WriteLine(className); // Outputs the full name of the class that is two frames up in the stack. This method is helpful when you want to identify the class that called a particular operation, especially useful in logging or debugging scenarios. The ability to control the depth allows flexibility in terms of call stack examination. Including the invoking class name in your application logs can give you a clearer picture of the execution flow and help speed up the troubleshooting process. As such, NameOfCallingClass might be frequently used within your exception handling or logging infrastructure. Remember that, due to potential performance implications, use reflection judiciously and only when required. Always validate the stack depth you pass to avoid potential StackOverflowExceptions or arguments outside the stack trace range.","title":"NameOfCallingClass Method"},{"location":"Rystem/System.Collection.Generics/","text":"Rystem NuGet Package - System.Collection.Generics Namespace Documentation Class: AsyncEnumerable This class is a part of the System.Collection.Generics namespace in the Rystem libraries, and is responsible for handling the creation of async enumerables. Method: Empty Method Name: Empty Description : This is a predefined readonly property that creates an empty IAsyncEnumerable<T> . Parameters : This method does not accept any parameters. Return Value : This method returns an IAsyncEnumerable<T> that is empty. Type T is the type of elements in the enumerable. Usage Example: Given that this property returns an empty IAsyncEnumerable , it can be used when we need to return an empty version of a list in an asynchronous operation, which may be useful when no data is available to populate the list. However, this is a static property so while demonstrating the usage, we would just show accessing this property, like so: var emptyAsyncList = AsyncEnumerable<string>.Empty; Method: GetEmpty Method Name: GetEmpty Description : This method is a private async enumerator function that was specifically created to initialize the Empty property. Parameters : This method does not accept any parameters. Return Value : This is a private method that doesn't return anything directly. Instead, it initializes the Empty property with an empty IAsyncEnumerable<T> . Usage Example: Since this is a private method, it typically wouldn't be used directly by the end user. The purpose of this method is to create an empty enumerable for the above Empty method.","title":"Rystem NuGet Package - System.Collection.Generics Namespace Documentation"},{"location":"Rystem/System.Collection.Generics/#rystem-nuget-package-systemcollectiongenerics-namespace-documentation","text":"","title":"Rystem NuGet Package - System.Collection.Generics Namespace Documentation"},{"location":"Rystem/System.Collection.Generics/#class-asyncenumerable","text":"This class is a part of the System.Collection.Generics namespace in the Rystem libraries, and is responsible for handling the creation of async enumerables.","title":"Class: AsyncEnumerable"},{"location":"Rystem/System.Collection.Generics/#method-empty","text":"Method Name: Empty Description : This is a predefined readonly property that creates an empty IAsyncEnumerable<T> . Parameters : This method does not accept any parameters. Return Value : This method returns an IAsyncEnumerable<T> that is empty. Type T is the type of elements in the enumerable. Usage Example: Given that this property returns an empty IAsyncEnumerable , it can be used when we need to return an empty version of a list in an asynchronous operation, which may be useful when no data is available to populate the list. However, this is a static property so while demonstrating the usage, we would just show accessing this property, like so: var emptyAsyncList = AsyncEnumerable<string>.Empty;","title":"Method: Empty"},{"location":"Rystem/System.Collection.Generics/#method-getempty","text":"Method Name: GetEmpty Description : This method is a private async enumerator function that was specifically created to initialize the Empty property. Parameters : This method does not accept any parameters. Return Value : This is a private method that doesn't return anything directly. Instead, it initializes the Empty property with an empty IAsyncEnumerable<T> . Usage Example: Since this is a private method, it typically wouldn't be used directly by the end user. The purpose of this method is to create an empty enumerable for the above Empty method.","title":"Method: GetEmpty"},{"location":"Rystem/System.Collections.Concurrent/","text":"ConcurrentList<T> Class The ConcurrentList<T> is a thread-safe implementation of the IList<T> interface. This class wraps all actions on the underlying list, with each method locking on the _trafficLight object to avoid race conditions and maintain thread safety. Add(T item) Method Purpose : Adds an item to the ConcurrentList<T> . Parameters : - T item : The item of type T that should be added to the list. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(); concurrentList.Add(5); Clear() Method Purpose : Removes all items from the ConcurrentList<T> . Parameters : This method doesn't need any parameters. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(); concurrentList.Add(5); concurrentList.Clear(); Contains(T item) Method Purpose : Determines whether the ConcurrentList<T> contains a specific item. Parameters : - T item : The item to locate in the ConcurrentList<T> . Return Value : A boolean value indicating whether the item is found in the ConcurrentList<T> . Usage Example : var concurrentList = new ConcurrentList<int>(); concurrentList.Add(5); bool contains = concurrentList.Contains(5); // true CopyTo(T[] array, int arrayIndex) Method Purpose : Copies the elements of the ConcurrentList<T> to an array, starting at a specific array index. Parameters : - T[] array : The one-dimensional array that is the destination of the elements copied from ConcurrentList<T> . - int arrayIndex : The zero-based index in array at which copying begins. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; var targetArray = new int[5]; concurrentList.CopyTo(targetArray, 0); GetEnumerator() Method Purpose : Returns an enumerator that iterates through the ConcurrentList<T> . Parameters : This method doesn't need any parameters. Return Value : An IEnumerator<T> that can be used to iterate through the collection. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; var enumerator = concurrentList.GetEnumerator(); while(enumerator.MoveNext()){ Console.WriteLine(enumerator.Current); } IndexOf(T item) Method Purpose : Determines the index of a specific item in the ConcurrentList<T> . Parameters : - T item : The object to locate in the ConcurrentList<T> . Return Value : The index of item if found in the list; otherwise, -1. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; int index = concurrentList.IndexOf(3); // 2 Insert(int index, T item) Method Purpose : Inserts an item to the ConcurrentList<T> at the specified index. Parameters : - int index : The zero-based index at which item should be inserted. - T item : The object to insert into the ConcurrentList<T> . Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; concurrentList.Insert(0, 0); // 0, 1, 2, 3, 4, 5 Remove(T item) Method Purpose : Removes the first occurrence of a specific object from the ConcurrentList<T> . Parameters : - T item : The object to remove from the ConcurrentList<T> . Return Value : A boolean value indicating if the operation was successful. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; bool isRemoved = concurrentList.Remove(3); // true if 3 was successfully removed RemoveAt(int index) Method Purpose : Removes the ConcurrentList<T> element at the specified index. Parameters : - int index : The zero-based index of the element to remove. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; concurrentList.RemoveAt(2); // Removes 3 from the list Using the test cases provided, it's clear to see how these methods are used to safely manipulate and manage data concurrently, avoiding potential issues with regular Lists and arrays in a multi-threaded environment.","title":"ConcurrentList&lt;T&gt; Class"},{"location":"Rystem/System.Collections.Concurrent/#concurrentlistt-class","text":"The ConcurrentList<T> is a thread-safe implementation of the IList<T> interface. This class wraps all actions on the underlying list, with each method locking on the _trafficLight object to avoid race conditions and maintain thread safety.","title":"ConcurrentList&lt;T&gt; Class"},{"location":"Rystem/System.Collections.Concurrent/#addt-item-method","text":"Purpose : Adds an item to the ConcurrentList<T> . Parameters : - T item : The item of type T that should be added to the list. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(); concurrentList.Add(5);","title":"Add(T item) Method"},{"location":"Rystem/System.Collections.Concurrent/#clear-method","text":"Purpose : Removes all items from the ConcurrentList<T> . Parameters : This method doesn't need any parameters. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(); concurrentList.Add(5); concurrentList.Clear();","title":"Clear() Method"},{"location":"Rystem/System.Collections.Concurrent/#containst-item-method","text":"Purpose : Determines whether the ConcurrentList<T> contains a specific item. Parameters : - T item : The item to locate in the ConcurrentList<T> . Return Value : A boolean value indicating whether the item is found in the ConcurrentList<T> . Usage Example : var concurrentList = new ConcurrentList<int>(); concurrentList.Add(5); bool contains = concurrentList.Contains(5); // true","title":"Contains(T item) Method"},{"location":"Rystem/System.Collections.Concurrent/#copytot-array-int-arrayindex-method","text":"Purpose : Copies the elements of the ConcurrentList<T> to an array, starting at a specific array index. Parameters : - T[] array : The one-dimensional array that is the destination of the elements copied from ConcurrentList<T> . - int arrayIndex : The zero-based index in array at which copying begins. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; var targetArray = new int[5]; concurrentList.CopyTo(targetArray, 0);","title":"CopyTo(T[] array, int arrayIndex) Method"},{"location":"Rystem/System.Collections.Concurrent/#getenumerator-method","text":"Purpose : Returns an enumerator that iterates through the ConcurrentList<T> . Parameters : This method doesn't need any parameters. Return Value : An IEnumerator<T> that can be used to iterate through the collection. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; var enumerator = concurrentList.GetEnumerator(); while(enumerator.MoveNext()){ Console.WriteLine(enumerator.Current); }","title":"GetEnumerator() Method"},{"location":"Rystem/System.Collections.Concurrent/#indexoft-item-method","text":"Purpose : Determines the index of a specific item in the ConcurrentList<T> . Parameters : - T item : The object to locate in the ConcurrentList<T> . Return Value : The index of item if found in the list; otherwise, -1. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; int index = concurrentList.IndexOf(3); // 2","title":"IndexOf(T item) Method"},{"location":"Rystem/System.Collections.Concurrent/#insertint-index-t-item-method","text":"Purpose : Inserts an item to the ConcurrentList<T> at the specified index. Parameters : - int index : The zero-based index at which item should be inserted. - T item : The object to insert into the ConcurrentList<T> . Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; concurrentList.Insert(0, 0); // 0, 1, 2, 3, 4, 5","title":"Insert(int index, T item) Method"},{"location":"Rystem/System.Collections.Concurrent/#removet-item-method","text":"Purpose : Removes the first occurrence of a specific object from the ConcurrentList<T> . Parameters : - T item : The object to remove from the ConcurrentList<T> . Return Value : A boolean value indicating if the operation was successful. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; bool isRemoved = concurrentList.Remove(3); // true if 3 was successfully removed","title":"Remove(T item) Method"},{"location":"Rystem/System.Collections.Concurrent/#removeatint-index-method","text":"Purpose : Removes the ConcurrentList<T> element at the specified index. Parameters : - int index : The zero-based index of the element to remove. Return Value : This method doesn't return a value. Usage Example : var concurrentList = new ConcurrentList<int>(){1, 2, 3, 4, 5}; concurrentList.RemoveAt(2); // Removes 3 from the list Using the test cases provided, it's clear to see how these methods are used to safely manipulate and manage data concurrently, avoiding potential issues with regular Lists and arrays in a multi-threaded environment.","title":"RemoveAt(int index) Method"},{"location":"Rystem/System.Collections/","text":"Rystem Nuget Package: EnumerableExtensions Class Documentation This document provides a comprehensive guide on the usage and functionality of the methods in the EnumerableExtensions class under Rystem Nuget package. These extension methods provide additional functionality to the standard IEnumerable interface in C#. Class: EnumerableExtensions Location: System.Collections This is a static class, meaning you do not need to instantiate objects from it, and you can directly call its methods. The class contains the following public methods: ElementAt SetElementAt RemoveElementAt Method: ElementAt This method retrieves an element at a specific index from an IEnumerable object. Parameters entities (IEnumerable): The collection from where an element will be retrieved. index (int): The position of the element to be retrieved from the collection. Return Value Returns an object ( object? ) which is the element at the specified index. If the index is out of range, it returns null. Usage Example IEnumerable list = new List<int> {1, 2, 3, 4, 5}; var element = list.ElementAt(2); //element now contains the value 3 Method: SetElementAt Replaces an element at a specific index from an IEnumerable object. Parameters entities (IEnumerable): The collection where an element will be replaced. index (int): The position of the element to be replaced in the collection. value (object?): The new value that will replace the current value at the specified index. Return Value Returns a boolean. If the element is successfully replaced it returns true, else false. Usage Example IEnumerable list = new List<int> {1, 2, 3, 4, 5}; bool isReplaced = list.SetElementAt(2, 9); //List value will be {1, 2, 9, 4, 5} Method: RemoveElementAt Removes an element at a specific index from an IEnumerable object. Parameters entities (IEnumerable): The collection from where an element will be removed. index (int): The position of the element to be removed from the collection. newEntities (out IEnumerable): Output parameter that contains the list after the removal. value (out object?): Output parameter that contains the removed element. Return Value Returns a boolean ( bool ). If the element is successfully removed it returns true, else false. Usage Example IEnumerable list = new List<int> {1, 2, 3, 4, 5}; list.RemoveElementAt(2, out IEnumerable newList, out object removedValue); // newList will be {1, 2, 4, 5} // removedValue will be 3 These methods provide more flexibility and control when dealing with collections in your projects.","title":"Rystem Nuget Package: EnumerableExtensions Class Documentation"},{"location":"Rystem/System.Collections/#rystem-nuget-package-enumerableextensions-class-documentation","text":"This document provides a comprehensive guide on the usage and functionality of the methods in the EnumerableExtensions class under Rystem Nuget package. These extension methods provide additional functionality to the standard IEnumerable interface in C#.","title":"Rystem Nuget Package: EnumerableExtensions Class Documentation"},{"location":"Rystem/System.Collections/#class-enumerableextensions","text":"Location: System.Collections This is a static class, meaning you do not need to instantiate objects from it, and you can directly call its methods. The class contains the following public methods: ElementAt SetElementAt RemoveElementAt","title":"Class: EnumerableExtensions"},{"location":"Rystem/System.Collections/#method-elementat","text":"This method retrieves an element at a specific index from an IEnumerable object. Parameters entities (IEnumerable): The collection from where an element will be retrieved. index (int): The position of the element to be retrieved from the collection. Return Value Returns an object ( object? ) which is the element at the specified index. If the index is out of range, it returns null. Usage Example IEnumerable list = new List<int> {1, 2, 3, 4, 5}; var element = list.ElementAt(2); //element now contains the value 3","title":"Method: ElementAt"},{"location":"Rystem/System.Collections/#method-setelementat","text":"Replaces an element at a specific index from an IEnumerable object. Parameters entities (IEnumerable): The collection where an element will be replaced. index (int): The position of the element to be replaced in the collection. value (object?): The new value that will replace the current value at the specified index. Return Value Returns a boolean. If the element is successfully replaced it returns true, else false. Usage Example IEnumerable list = new List<int> {1, 2, 3, 4, 5}; bool isReplaced = list.SetElementAt(2, 9); //List value will be {1, 2, 9, 4, 5}","title":"Method: SetElementAt"},{"location":"Rystem/System.Collections/#method-removeelementat","text":"Removes an element at a specific index from an IEnumerable object. Parameters entities (IEnumerable): The collection from where an element will be removed. index (int): The position of the element to be removed from the collection. newEntities (out IEnumerable): Output parameter that contains the list after the removal. value (out object?): Output parameter that contains the removed element. Return Value Returns a boolean ( bool ). If the element is successfully removed it returns true, else false. Usage Example IEnumerable list = new List<int> {1, 2, 3, 4, 5}; list.RemoveElementAt(2, out IEnumerable newList, out object removedValue); // newList will be {1, 2, 4, 5} // removedValue will be 3 These methods provide more flexibility and control when dealing with collections in your projects.","title":"Method: RemoveElementAt"},{"location":"Rystem/System.IO/","text":"Documentation Class: StreamExtensions Located under the System.IO namespace, the StreamExtensions class provides utility methods that extend the capabilities of streams and byte arrays. This class is static, meaning all its methods are also static. - Method Name: ToStream Description : This method converts byte arrays to their stream equivalent. Parameters : 1. byte[] bytes : This parameter is a byte array to be converted into a stream. Return Value : A stream derived from the input byte array ( Stream ). Usage Example : byte[] myBytes = new byte[] { 0, 1, 2, 3 }; Stream myStream = myBytes.ToStream(); - Method Name: ToArray Description : Converts a stream to a byte array. Parameters : 1. Stream stream : The input stream to be converted into a byte array. Return Value : A byte array ( byte[] ) that represents the input stream. Usage Example : Stream myStream = new MemoryStream(); byte[] myBytes = myStream.ToArray(); - Method Name: ToArrayAsync Description : Asynchronously converts a stream to a byte array. Parameters : 1. Stream stream : The input stream to be converted into a byte array. Return Value : An asynchronous task that yields a byte array ( Task<byte[]> ), representing the input stream. Usage Example : Stream myStream = new MemoryStream(); byte[] myBytes = await myStream.ToArrayAsync(); The StreamExtensions class is particularly useful when dealing with I/O operations where conversion between byte arrays and streams are frequently required. For instance, reading and writing to files or network streams frequently requires such conversions.","title":"Documentation"},{"location":"Rystem/System.IO/#documentation","text":"","title":"Documentation"},{"location":"Rystem/System.IO/#class-streamextensions","text":"Located under the System.IO namespace, the StreamExtensions class provides utility methods that extend the capabilities of streams and byte arrays. This class is static, meaning all its methods are also static.","title":"Class: StreamExtensions"},{"location":"Rystem/System.IO/#-method-name-tostream","text":"Description : This method converts byte arrays to their stream equivalent. Parameters : 1. byte[] bytes : This parameter is a byte array to be converted into a stream. Return Value : A stream derived from the input byte array ( Stream ). Usage Example : byte[] myBytes = new byte[] { 0, 1, 2, 3 }; Stream myStream = myBytes.ToStream();","title":"- Method Name: ToStream"},{"location":"Rystem/System.IO/#-method-name-toarray","text":"Description : Converts a stream to a byte array. Parameters : 1. Stream stream : The input stream to be converted into a byte array. Return Value : A byte array ( byte[] ) that represents the input stream. Usage Example : Stream myStream = new MemoryStream(); byte[] myBytes = myStream.ToArray();","title":"- Method Name: ToArray"},{"location":"Rystem/System.IO/#-method-name-toarrayasync","text":"Description : Asynchronously converts a stream to a byte array. Parameters : 1. Stream stream : The input stream to be converted into a byte array. Return Value : An asynchronous task that yields a byte array ( Task<byte[]> ), representing the input stream. Usage Example : Stream myStream = new MemoryStream(); byte[] myBytes = await myStream.ToArrayAsync(); The StreamExtensions class is particularly useful when dealing with I/O operations where conversion between byte arrays and streams are frequently required. For instance, reading and writing to files or network streams frequently requires such conversions.","title":"- Method Name: ToArrayAsync"},{"location":"Rystem/System.Linq.Expressions/","text":"Rystem Library Documentation - System.Linq.Expressions Namespace This section contains detailed documentation of the System.Linq.Expressions namespace classes and their associated public methods included in the Rystem library. 1. ExpressionExtensions The ExpressionExtensions class provides a set of methods for extending the functionality of expressions. Methods 1.1. Serialize Description : This method serializes the given expression, converting it into a string format. Parameters : - expression : The expression object you want to serialize. Return Value : Returns a string representation of the given expression. Usage Example : var serializedExpression = someExpression.Serialize(); 1.2. Deserialize Description : This method deserializes the given string expression into an Expression of the specified type. Parameters : - expressionAsString : The serialized expression to be deserialized. Return Value : Returns a deserialized Expression of given type and result type. Usage Example : var deserializedExpression = serializedExpression.Deserialize<DataType, ResultType>(); 1.3. DeserializeAndCompile Description : This method deserializes the given string expression into an Expression of the specified type and compiles it. Parameters : - expressionAsString : The expression you want to deserialize and compile. Return Value : Returns a compiled delegate of the deserialized Expression of given type and result type. Usage Example : var compiledExpression = serializedExpression.DeserializeAndCompile<DataType, ResultType>(); This class contains a variety of other methods that allow further functionality, such as Async Invocation and transformation, changing an Expression's return type, and retrieving a property from an Expression. 2. ExpressionSerializer The ExpressionSerializer class serializes and deserializes Expression objects. 2.1. Serialize Description : This method serializes the provided expression. Parameters : - expression : The expression object you want to serialize. Return Value : This method a string representation of the provided expression. Usage Example : var serializedExpression = ExpressionSerializer.Serialize(someExpression); 2.2. Deserialize Description : This method deserializes the given string expression into an Expression of the specified type. Parameters : - expressionAsString : The serialized expression to be deserialized. Return Value : Returns a deserialized Expression of given type and return type. Usage Example : var deserializedExpression = ExpressionSerializer.Deserialize<DataType, ResultType>(serializedExpression); 3. LambdaExpressionExtensions The LambdaExpressionExtensions class contains methods for working with Lambda Expressions, such as changing the return type and transforming a generic Lambda Expression into a strongly typed one. 3.1. ChangeReturnType Description : This method changes the return type of the given Lambda expression. Parameters : - expression : The Lambda Expression whose return type needs to be changed. - toChange : The new return type. Return Value : Returns a new Lambda Expression with the updated return type. Usage Example : var updatedExpression = originalExpression.ChangeReturnType(newType); The other methods in this class provide functionalities for casting a Lambda Expression to a specific return type, as well as transforming the same. 4. BinaryExpressionInterpreter The BinaryExpressionInterpreter class is used to interpret Binary Expressions. Primarily it reads a given Expression and returns a list of sub-expressions. 5. ConstantExpressionInterpreter The ConstantExpressionInterpreter class is used to interpret Constant Expressions. If the expression is a Constant Expression, it replaces the value in the context with the actual value. This interpretation and reading of Expressions helps in performing operations and transformations with the Expressions. Conclusion The System.Linq.Expressions namespace in the Rystem library provides a set of functionality to work with different types of expressions. It offers features like serialization, deserialization, modification, invocation and interpretation of expressions. This functionality can be useful in various use cases where managing and manipulating expressions is required.","title":"Rystem Library Documentation - System.Linq.Expressions Namespace"},{"location":"Rystem/System.Linq.Expressions/#rystem-library-documentation-systemlinqexpressions-namespace","text":"This section contains detailed documentation of the System.Linq.Expressions namespace classes and their associated public methods included in the Rystem library.","title":"Rystem Library Documentation - System.Linq.Expressions Namespace"},{"location":"Rystem/System.Linq.Expressions/#1-expressionextensions","text":"The ExpressionExtensions class provides a set of methods for extending the functionality of expressions.","title":"1. ExpressionExtensions"},{"location":"Rystem/System.Linq.Expressions/#methods","text":"","title":"Methods"},{"location":"Rystem/System.Linq.Expressions/#11-serialize","text":"Description : This method serializes the given expression, converting it into a string format. Parameters : - expression : The expression object you want to serialize. Return Value : Returns a string representation of the given expression. Usage Example : var serializedExpression = someExpression.Serialize();","title":"1.1. Serialize"},{"location":"Rystem/System.Linq.Expressions/#12-deserialize","text":"Description : This method deserializes the given string expression into an Expression of the specified type. Parameters : - expressionAsString : The serialized expression to be deserialized. Return Value : Returns a deserialized Expression of given type and result type. Usage Example : var deserializedExpression = serializedExpression.Deserialize<DataType, ResultType>();","title":"1.2. Deserialize"},{"location":"Rystem/System.Linq.Expressions/#13-deserializeandcompile","text":"Description : This method deserializes the given string expression into an Expression of the specified type and compiles it. Parameters : - expressionAsString : The expression you want to deserialize and compile. Return Value : Returns a compiled delegate of the deserialized Expression of given type and result type. Usage Example : var compiledExpression = serializedExpression.DeserializeAndCompile<DataType, ResultType>(); This class contains a variety of other methods that allow further functionality, such as Async Invocation and transformation, changing an Expression's return type, and retrieving a property from an Expression.","title":"1.3. DeserializeAndCompile"},{"location":"Rystem/System.Linq.Expressions/#2-expressionserializer","text":"The ExpressionSerializer class serializes and deserializes Expression objects.","title":"2. ExpressionSerializer"},{"location":"Rystem/System.Linq.Expressions/#21-serialize","text":"Description : This method serializes the provided expression. Parameters : - expression : The expression object you want to serialize. Return Value : This method a string representation of the provided expression. Usage Example : var serializedExpression = ExpressionSerializer.Serialize(someExpression);","title":"2.1. Serialize"},{"location":"Rystem/System.Linq.Expressions/#22-deserialize","text":"Description : This method deserializes the given string expression into an Expression of the specified type. Parameters : - expressionAsString : The serialized expression to be deserialized. Return Value : Returns a deserialized Expression of given type and return type. Usage Example : var deserializedExpression = ExpressionSerializer.Deserialize<DataType, ResultType>(serializedExpression);","title":"2.2. Deserialize"},{"location":"Rystem/System.Linq.Expressions/#3-lambdaexpressionextensions","text":"The LambdaExpressionExtensions class contains methods for working with Lambda Expressions, such as changing the return type and transforming a generic Lambda Expression into a strongly typed one.","title":"3. LambdaExpressionExtensions"},{"location":"Rystem/System.Linq.Expressions/#31-changereturntype","text":"Description : This method changes the return type of the given Lambda expression. Parameters : - expression : The Lambda Expression whose return type needs to be changed. - toChange : The new return type. Return Value : Returns a new Lambda Expression with the updated return type. Usage Example : var updatedExpression = originalExpression.ChangeReturnType(newType); The other methods in this class provide functionalities for casting a Lambda Expression to a specific return type, as well as transforming the same.","title":"3.1. ChangeReturnType"},{"location":"Rystem/System.Linq.Expressions/#4-binaryexpressioninterpreter","text":"The BinaryExpressionInterpreter class is used to interpret Binary Expressions. Primarily it reads a given Expression and returns a list of sub-expressions.","title":"4. BinaryExpressionInterpreter"},{"location":"Rystem/System.Linq.Expressions/#5-constantexpressioninterpreter","text":"The ConstantExpressionInterpreter class is used to interpret Constant Expressions. If the expression is a Constant Expression, it replaces the value in the context with the actual value. This interpretation and reading of Expressions helps in performing operations and transformations with the Expressions.","title":"5. ConstantExpressionInterpreter"},{"location":"Rystem/System.Linq.Expressions/#conclusion","text":"The System.Linq.Expressions namespace in the Rystem library provides a set of functionality to work with different types of expressions. It offers features like serialization, deserialization, modification, invocation and interpretation of expressions. This functionality can be useful in various use cases where managing and manipulating expressions is required.","title":"Conclusion"},{"location":"Rystem/System.Linq/","text":"Class Documentation System.Linq.LinqAsyncExtensions 1. Method: AllAsync<TSource> What it does: Evaluates all elements in an IEnumerable<TSource> collection based on a given condition specified by a Expression<Func<TSource, ValueTask<bool>>> (a predicate). Parameters: - source : A collection of type TSource . It serves as the input data. - expression : An expression that defines the condition for each item in the source collection. Return value: Returns ValueTask<bool> . If all elements satisfy the condition, the method returns true . Otherwise, it returns false . Usage Example: IEnumerable<int> collection = new List<int>() { 1, 2, 3, 4, 5 }; Expression<Func<int, ValueTask<bool>>> expression = num => new ValueTask<bool>(num > 0); bool result = await collection.AllAsync(expression); 2. Method: AnyAsync<TSource> What it does: Evaluates if any element in a collection satisfies a condition defined by a Expression<Func<TSource, ValueTask<bool>>> . Parameters: - source : A collection of type TSource . It serves as the input data. - expression : An expression that defines the condition for each item in the source collection. Return value: Returns a ValueTask<bool> . If any element satisfy the condition, the method returns true . Otherwise, it returns false . Usage Example: IEnumerable<int> collection = new List<int>() { 1, 2, 3, 4, 5 }; Expression<Func<int, ValueTask<bool>>> expression = num => new ValueTask<bool>(num > 5); bool result = await collection.AnyAsync(expression); System.Linq.QueryableLinqExtensions The QueryableLinqExtensions class provides extension methods for IQueryable data types, such as entities in a database query. These methods inherently support asynchronous operation. 3. Method: CallMethod<TSource, TResult> What it does: Invokes a generic version of a method for a query with a given name, based on the provided LambdaExpression . Parameters: * query : An IQueryable<TSource> where the method will be applied. * methodName : A string that specifies the name of the method to be invoked. * expression : A LambdaExpression to be passed to the method. * typeWhereToSearchTheMethod : A Type , which specifies where to find the method; by default, it examines System.Linq.Queryable . Return value: Returns an object of type TResult , which is the result of the method invocation. Usage Example: IQueryable<int> query = new List<int>() { 1, 2, 3, 4, 5 }.AsQueryable(); string methodName = \"Average\"; LambdaExpression expression = Expression.Lambda<Func<int, int>>(Expression.Constant(1), Expression.Parameter(typeof(int))); var result = query.CallMethod<int, decimal>(methodName, expression); 4. Method: GroupBy<TSource, TKey> What it does: Groups items in an IQueryable<TSource> according to a specified LambdaExpression . Parameters: * source : An IQueryable<TSource> to be grouped. * keySelector : A LambdaExpression that defines the selector function. Return value: Returns an IQueryable<IGrouping<TKey, TSource>> where each IGrouping<TKey,TSource> object contains a collection of TSource objects and a key. Usage Example: IQueryable<int> source = new List<int>() { 1, 1, 2, 3, 4, 5 }.AsQueryable(); LambdaExpression keySelector = Expression.Lambda<Func<int, int>>(Expression.Constant(1), Expression.Parameter(typeof(int))); var result = source.GroupBy<int, int>(keySelector); And many other methods available in the QueryableLinqExtensions follow similar patterns, extending the IQueryable<TSource> , and can be used in similar ways as illustrated above.","title":"Class Documentation"},{"location":"Rystem/System.Linq/#class-documentation","text":"","title":"Class Documentation"},{"location":"Rystem/System.Linq/#systemlinqlinqasyncextensions","text":"","title":"System.Linq.LinqAsyncExtensions"},{"location":"Rystem/System.Linq/#1-method-allasynctsource","text":"What it does: Evaluates all elements in an IEnumerable<TSource> collection based on a given condition specified by a Expression<Func<TSource, ValueTask<bool>>> (a predicate). Parameters: - source : A collection of type TSource . It serves as the input data. - expression : An expression that defines the condition for each item in the source collection. Return value: Returns ValueTask<bool> . If all elements satisfy the condition, the method returns true . Otherwise, it returns false . Usage Example: IEnumerable<int> collection = new List<int>() { 1, 2, 3, 4, 5 }; Expression<Func<int, ValueTask<bool>>> expression = num => new ValueTask<bool>(num > 0); bool result = await collection.AllAsync(expression);","title":"1. Method: AllAsync&lt;TSource&gt;"},{"location":"Rystem/System.Linq/#2-method-anyasynctsource","text":"What it does: Evaluates if any element in a collection satisfies a condition defined by a Expression<Func<TSource, ValueTask<bool>>> . Parameters: - source : A collection of type TSource . It serves as the input data. - expression : An expression that defines the condition for each item in the source collection. Return value: Returns a ValueTask<bool> . If any element satisfy the condition, the method returns true . Otherwise, it returns false . Usage Example: IEnumerable<int> collection = new List<int>() { 1, 2, 3, 4, 5 }; Expression<Func<int, ValueTask<bool>>> expression = num => new ValueTask<bool>(num > 5); bool result = await collection.AnyAsync(expression);","title":"2. Method: AnyAsync&lt;TSource&gt;"},{"location":"Rystem/System.Linq/#systemlinqqueryablelinqextensions","text":"The QueryableLinqExtensions class provides extension methods for IQueryable data types, such as entities in a database query. These methods inherently support asynchronous operation.","title":"System.Linq.QueryableLinqExtensions"},{"location":"Rystem/System.Linq/#3-method-callmethodtsource-tresult","text":"What it does: Invokes a generic version of a method for a query with a given name, based on the provided LambdaExpression . Parameters: * query : An IQueryable<TSource> where the method will be applied. * methodName : A string that specifies the name of the method to be invoked. * expression : A LambdaExpression to be passed to the method. * typeWhereToSearchTheMethod : A Type , which specifies where to find the method; by default, it examines System.Linq.Queryable . Return value: Returns an object of type TResult , which is the result of the method invocation. Usage Example: IQueryable<int> query = new List<int>() { 1, 2, 3, 4, 5 }.AsQueryable(); string methodName = \"Average\"; LambdaExpression expression = Expression.Lambda<Func<int, int>>(Expression.Constant(1), Expression.Parameter(typeof(int))); var result = query.CallMethod<int, decimal>(methodName, expression);","title":"3. Method: CallMethod&lt;TSource, TResult&gt;"},{"location":"Rystem/System.Linq/#4-method-groupbytsource-tkey","text":"What it does: Groups items in an IQueryable<TSource> according to a specified LambdaExpression . Parameters: * source : An IQueryable<TSource> to be grouped. * keySelector : A LambdaExpression that defines the selector function. Return value: Returns an IQueryable<IGrouping<TKey, TSource>> where each IGrouping<TKey,TSource> object contains a collection of TSource objects and a key. Usage Example: IQueryable<int> source = new List<int>() { 1, 1, 2, 3, 4, 5 }.AsQueryable(); LambdaExpression keySelector = Expression.Lambda<Func<int, int>>(Expression.Constant(1), Expression.Parameter(typeof(int))); var result = source.GroupBy<int, int>(keySelector); And many other methods available in the QueryableLinqExtensions follow similar patterns, extending the IQueryable<TSource> , and can be used in similar ways as illustrated above.","title":"4. Method: GroupBy&lt;TSource, TKey&gt;"},{"location":"Rystem/System.ProgrammingLanguage/","text":"Documentation Class: IProgrammingLanguage Provides an interface to define methods that are to be implemented by different programming languages. Each method in the interface defines a part of transforming a given Type to a string representation that fits a specific programming language. Methods: Start(Type type, string name) Purpose : Generate the initiation string of a type definition in a specific programming language. The type becomes the name of the entity being defined in the language. Parameters : - type (Type) : The .NET Type that is being converted. - name (string) : The name of the entity being defined. Return Value : The initiation string of type definition for the specific programming language. GetMimeType() Purpose : Retrieve the MIME type of the programming language. Return Value : The MIME type of the specific programming language. SetProperty(string name, string type) Purpose : Generate a string presenting a property in the specific programming language. Parameters : - name (string) : The name of the property. - type (string) : The type of the property. Return Value : A string showing how to declare a property with the name and type in a specific programming language. GetPrimitiveType(Type) Purpose : Prepare the string representation of a primitive type in a particular programming language. Parameters : - type (Type) : The primitive .NET Type that is being converted. Return Value : The representation of the primitive Type in the specific programming language. GetNonPrimitiveType(Type) Purpose : Prepare the string representation of a non-primitive type (like: List , Array , Map , etc.) in a particular programming Parameters : - type (Type) : The non-primitive .NET Type that is being converted. Return Value : The representation of the non-primitive Type in the specific programming language. End() Purpose : Generate the string ending a type definition in a specific programming language. Return Value : The string ending the type definition for the specific programming language. ConvertEnum(string name, Type type) Purpose : Generate the string representation of an Enum type in the specific programming language. Parameters : - name (string) : The name of the Enum. - type (Type) : The Enum type that is being converted. Return Value : The representation of the Enum in the specific programming language. Class: ProgrammingLanguageExtensions Provides some extension methods to convert a Type or a collection of Types to their representation in a specific programming language. Methods: ConvertAs(this IEnumerable<Type> types, ProgrammingLanguageType programmingLanguage) Purpose : Convert a collection of types to their representation in a specific programming language in a bulk operation. Parameters : - types (IEnumerable<Type>) : The collection of .NET types that are being converted. - programmingLanguage (ProgrammingLanguageType) : The programming language to convert to. Return Value : An object of type ProgrammingLanguangeResponse that stores the text of all the types' representation and the MIME type of the programming language. Usage Example : csharp List<Type> types = new List<Type> {typeof(int), typeof(string)}; var response = types.ConvertAs(ProgrammingLanguageType.Typescript); ConvertAs(this Type type, ProgrammingLanguageType programmingLanguage, string? name = null) Purpose : Convert a type to its representation in a specific programming language. Parameters : - types (Type) : The .NET type that is being converted. - programmingLanguage (ProgrammingLanguageType) : The programming language to convert to. - name (string?) : Optional parameter for the name of the entity. If not provided, the type Name will be used. Return Value : An object of type ProgrammingLanguangeResponse that stores the text of the type's representation and the MIME type of the programming language. Usage Example : csharp var response = typeof(int).ConvertAs(ProgrammingLanguageType.Typescript, \"MyInt\"); Class: ProgrammingLanguangeResponse Simple container that stores the result of a conversion to a different programming language. It includes the text of the new representation and the MIME type of the programing language. Properties: Text (string) : The text representation of the converted type. MimeType (string) : The MIME type of the specific programming language. Class: TypeScript This class implements the IProgrammingLanguage interface to provide functionality specific to the TypeScript language. Note : The method's documentation is the same as the one defined in the IProgrammingLanguage , but specific to TypeScript. Usage Example string name = \"MyClass\"; Type type = typeof(MyClass); IProgrammingLanguage ts = new TypeScript(); var start = ts.Start(type, name); Note : You will hardly need to call the TypeScript methods directly; this class is mainly used by calling the methods of the ProgrammingLanguageExtensions class.","title":"Documentation"},{"location":"Rystem/System.ProgrammingLanguage/#documentation","text":"","title":"Documentation"},{"location":"Rystem/System.ProgrammingLanguage/#class-iprogramminglanguage","text":"Provides an interface to define methods that are to be implemented by different programming languages. Each method in the interface defines a part of transforming a given Type to a string representation that fits a specific programming language.","title":"Class: IProgrammingLanguage"},{"location":"Rystem/System.ProgrammingLanguage/#methods","text":"Start(Type type, string name) Purpose : Generate the initiation string of a type definition in a specific programming language. The type becomes the name of the entity being defined in the language. Parameters : - type (Type) : The .NET Type that is being converted. - name (string) : The name of the entity being defined. Return Value : The initiation string of type definition for the specific programming language. GetMimeType() Purpose : Retrieve the MIME type of the programming language. Return Value : The MIME type of the specific programming language. SetProperty(string name, string type) Purpose : Generate a string presenting a property in the specific programming language. Parameters : - name (string) : The name of the property. - type (string) : The type of the property. Return Value : A string showing how to declare a property with the name and type in a specific programming language. GetPrimitiveType(Type) Purpose : Prepare the string representation of a primitive type in a particular programming language. Parameters : - type (Type) : The primitive .NET Type that is being converted. Return Value : The representation of the primitive Type in the specific programming language. GetNonPrimitiveType(Type) Purpose : Prepare the string representation of a non-primitive type (like: List , Array , Map , etc.) in a particular programming Parameters : - type (Type) : The non-primitive .NET Type that is being converted. Return Value : The representation of the non-primitive Type in the specific programming language. End() Purpose : Generate the string ending a type definition in a specific programming language. Return Value : The string ending the type definition for the specific programming language. ConvertEnum(string name, Type type) Purpose : Generate the string representation of an Enum type in the specific programming language. Parameters : - name (string) : The name of the Enum. - type (Type) : The Enum type that is being converted. Return Value : The representation of the Enum in the specific programming language.","title":"Methods:"},{"location":"Rystem/System.ProgrammingLanguage/#class-programminglanguageextensions","text":"Provides some extension methods to convert a Type or a collection of Types to their representation in a specific programming language.","title":"Class: ProgrammingLanguageExtensions"},{"location":"Rystem/System.ProgrammingLanguage/#methods_1","text":"ConvertAs(this IEnumerable<Type> types, ProgrammingLanguageType programmingLanguage) Purpose : Convert a collection of types to their representation in a specific programming language in a bulk operation. Parameters : - types (IEnumerable<Type>) : The collection of .NET types that are being converted. - programmingLanguage (ProgrammingLanguageType) : The programming language to convert to. Return Value : An object of type ProgrammingLanguangeResponse that stores the text of all the types' representation and the MIME type of the programming language. Usage Example : csharp List<Type> types = new List<Type> {typeof(int), typeof(string)}; var response = types.ConvertAs(ProgrammingLanguageType.Typescript); ConvertAs(this Type type, ProgrammingLanguageType programmingLanguage, string? name = null) Purpose : Convert a type to its representation in a specific programming language. Parameters : - types (Type) : The .NET type that is being converted. - programmingLanguage (ProgrammingLanguageType) : The programming language to convert to. - name (string?) : Optional parameter for the name of the entity. If not provided, the type Name will be used. Return Value : An object of type ProgrammingLanguangeResponse that stores the text of the type's representation and the MIME type of the programming language. Usage Example : csharp var response = typeof(int).ConvertAs(ProgrammingLanguageType.Typescript, \"MyInt\");","title":"Methods:"},{"location":"Rystem/System.ProgrammingLanguage/#class-programminglanguangeresponse","text":"Simple container that stores the result of a conversion to a different programming language. It includes the text of the new representation and the MIME type of the programing language.","title":"Class: ProgrammingLanguangeResponse"},{"location":"Rystem/System.ProgrammingLanguage/#properties","text":"Text (string) : The text representation of the converted type. MimeType (string) : The MIME type of the specific programming language.","title":"Properties:"},{"location":"Rystem/System.ProgrammingLanguage/#class-typescript","text":"This class implements the IProgrammingLanguage interface to provide functionality specific to the TypeScript language. Note : The method's documentation is the same as the one defined in the IProgrammingLanguage , but specific to TypeScript.","title":"Class: TypeScript"},{"location":"Rystem/System.ProgrammingLanguage/#usage-example","text":"string name = \"MyClass\"; Type type = typeof(MyClass); IProgrammingLanguage ts = new TypeScript(); var start = ts.Start(type, name); Note : You will hardly need to call the TypeScript methods directly; this class is mainly used by calling the methods of the ProgrammingLanguageExtensions class.","title":"Usage Example"},{"location":"Rystem/System.Reflection/","text":"Documentation Rystem is a library consisting of several classes that work primarily with reflection for dynamic object management, interpreting bytecodes, and mocking elements. Constructor Class This class contains static methods for dealing with object constructors. Method Name: InvokeWithBestDynamicFit Description: Invokes the most suitable dynamic constructor to initialize object of type T . Parameters: object[] args : Array of arguments to pass to constructor. Their types should match some constructor for T . Return Value: Returns a new instance of type T , or default if instantiation fails. Usage Example: csharp var objectInstance = Constructor.InvokeWithBestDynamicFit<MyClass>(arg1, arg2); Method Name: ConstructWithBestDynamicFit Description: Constructs an object dynamically using the best possible fit constructor. Parameters: Type type : The type of object to be created. object[] args : The constructor arguments. Return Value: Returns a new instance of type T , or default if instantiation fails. Usage Example: csharp var objectInstance = Constructor.ConstructWithBestDynamicFit(typeof(MyClass), arg1, arg2); MethodInfoExtensions Class Method Name: GetBodyAsString Description: Gets the body of the method as a string. Parameters: None Return Value: Returns the method body as a string. Usage Example: csharp var method = typeof(MyClass).GetMethod(\"MyMethod\"); string bodyString = method.GetBodyAsString(); Method Name: GetInstructions Description: Retrieves the list of instructions related to the method. Parameters: None Return Value: Returns a list of ILInstruction objects. Usage Example: csharp var method = typeof(MyClass).GetMethod(\"MyMethod\"); var instructions = method.GetInstructions(); PrimitiveExtensions Class This class includes static extension methods to check the specifics of a given type. Method Name: IsPrimitive Description: It checks whether the type T is a primitive. Parameters: None Return Value: Returns a bool value based on whether the entity type is a primitive. Usage Example: csharp int i = 5; bool isPrimitive = i.IsPrimitive(); ReflectionExtensions Class Provides extension methods for Type objects to perform common reflection tasks, like checking if a type has an interface, checking for inheritance or field existence, and creating instances. Generics Class This class includes various methods for working with generic methods and type parameters. MethodInfoWrapper Class This class wraps a MethodInfo object, allowing access to the method's attributes and the ability to invoke the method. PrimitiveExtensions Class Contains methods to help determine the more complex details of a given type, such as whether it is numeric, Boolean, an Enum, ReflectionExtensions Class Defines extension methods to allow for easier and cleaner reflection code. This includes shortcuts to check for inheritance, fetch properties, and more. Generics Class This class offers static methods to work with MethodInfo objects that represent generic methods. MethodBodyReader Class This class is responsible for reading the IL code of a method body and translating it into objects that can be analyzed. Note This is just a partial list of available classes. The detailed documentation will contain in-depth descriptions, edge cases, and usage examples for each function, class, property, and other elements of the real code. This task is pretty challenging to do for such large input as the sample given. The AI does not have a deep understanding of code and may overlook important parts or misinterpret certain sections.","title":"Documentation"},{"location":"Rystem/System.Reflection/#documentation","text":"Rystem is a library consisting of several classes that work primarily with reflection for dynamic object management, interpreting bytecodes, and mocking elements.","title":"Documentation"},{"location":"Rystem/System.Reflection/#constructor-class","text":"This class contains static methods for dealing with object constructors. Method Name: InvokeWithBestDynamicFit Description: Invokes the most suitable dynamic constructor to initialize object of type T . Parameters: object[] args : Array of arguments to pass to constructor. Their types should match some constructor for T . Return Value: Returns a new instance of type T , or default if instantiation fails. Usage Example: csharp var objectInstance = Constructor.InvokeWithBestDynamicFit<MyClass>(arg1, arg2); Method Name: ConstructWithBestDynamicFit Description: Constructs an object dynamically using the best possible fit constructor. Parameters: Type type : The type of object to be created. object[] args : The constructor arguments. Return Value: Returns a new instance of type T , or default if instantiation fails. Usage Example: csharp var objectInstance = Constructor.ConstructWithBestDynamicFit(typeof(MyClass), arg1, arg2);","title":"Constructor Class"},{"location":"Rystem/System.Reflection/#methodinfoextensions-class","text":"Method Name: GetBodyAsString Description: Gets the body of the method as a string. Parameters: None Return Value: Returns the method body as a string. Usage Example: csharp var method = typeof(MyClass).GetMethod(\"MyMethod\"); string bodyString = method.GetBodyAsString(); Method Name: GetInstructions Description: Retrieves the list of instructions related to the method. Parameters: None Return Value: Returns a list of ILInstruction objects. Usage Example: csharp var method = typeof(MyClass).GetMethod(\"MyMethod\"); var instructions = method.GetInstructions();","title":"MethodInfoExtensions Class"},{"location":"Rystem/System.Reflection/#primitiveextensions-class","text":"This class includes static extension methods to check the specifics of a given type. Method Name: IsPrimitive Description: It checks whether the type T is a primitive. Parameters: None Return Value: Returns a bool value based on whether the entity type is a primitive. Usage Example: csharp int i = 5; bool isPrimitive = i.IsPrimitive();","title":"PrimitiveExtensions Class"},{"location":"Rystem/System.Reflection/#reflectionextensions-class","text":"Provides extension methods for Type objects to perform common reflection tasks, like checking if a type has an interface, checking for inheritance or field existence, and creating instances.","title":"ReflectionExtensions Class"},{"location":"Rystem/System.Reflection/#generics-class","text":"This class includes various methods for working with generic methods and type parameters.","title":"Generics Class"},{"location":"Rystem/System.Reflection/#methodinfowrapper-class","text":"This class wraps a MethodInfo object, allowing access to the method's attributes and the ability to invoke the method.","title":"MethodInfoWrapper Class"},{"location":"Rystem/System.Reflection/#primitiveextensions-class_1","text":"Contains methods to help determine the more complex details of a given type, such as whether it is numeric, Boolean, an Enum,","title":"PrimitiveExtensions Class"},{"location":"Rystem/System.Reflection/#reflectionextensions-class_1","text":"Defines extension methods to allow for easier and cleaner reflection code. This includes shortcuts to check for inheritance, fetch properties, and more.","title":"ReflectionExtensions Class"},{"location":"Rystem/System.Reflection/#generics-class_1","text":"This class offers static methods to work with MethodInfo objects that represent generic methods.","title":"Generics Class"},{"location":"Rystem/System.Reflection/#methodbodyreader-class","text":"This class is responsible for reading the IL code of a method body and translating it into objects that can be analyzed.","title":"MethodBodyReader Class"},{"location":"Rystem/System.Reflection/#note","text":"This is just a partial list of available classes. The detailed documentation will contain in-depth descriptions, edge cases, and usage examples for each function, class, property, and other elements of the real code. This task is pretty challenging to do for such large input as the sample given. The AI does not have a deep understanding of code and may overlook important parts or misinterpret certain sections.","title":"Note"},{"location":"Rystem/System.Security.Cryptography/","text":"CryptoExtensions Class The CryptoExtensions class is a utility class that provides methods for hashing strings and objects. Method: ToHash(this string message) This method computes the SHA512 hash of the provided string message. Parameters: message : The string that needs to be hashed. Return Value: A hexadecimal string representing the hash value of the given string. The return type is string . Usage Example: string originalString = \"This is a string to hash\"; string hashedString = originalString.ToHash(); Method: ToHash<T>(this T message) This method computes the SHA512 hash of the JSON representation of the provided object. Parameters: message : The object that needs to be hashed. Return Value: A hexadecimal string representing the hash value of the JSON string representation of the given object. The return type is string . Usage Example: Foo objectToHash = new Foo{Values = new List<string> {\"aa\", \"bb\", \"cc\"}, X = true}; string hashedObject = objectToHash.ToHash(); This method is useful when you need to hash complex data structures, such as an entire class. Please note that the class should be serializable to JSON in order for this method to work. Above examples show several practical cases. You can hash any string or an object. ToHash() method also uses internally System.Text.Json for JSON representation of the object, so all constraints for that library apply here too. Test Cases Several test cases from the HashTest class provide insight into usage of the ToHash() methods. Comparing the hash of an object to itself: var foo = new Foo() { Values = new List<string>() { \"aa\", \"bb\", \"cc\" }, X = true }; Assert.Equal(foo.ToHash(), foo.ToHash()); Hashing a UUID: var message = Guid.NewGuid(); Assert.Equal(message.ToHash(), message.ToHash()); Hashing a hard-coded UUID: var k = Guid.Parse(\"41e2c840-8ba1-4c0b-8a9b-781747a5de0c\"); Assert.Equal(\"18edf95916c3aa4fd09a754e2e799fce252b0b7a76ffff76962175ad0f9921bc13bbd675954c1121d9177ffc222622c5adecf8544acb7a844117d6b1fab4590a\", k.ToHash()); In the AppUser class ( Rystem.Test.UnitTest.System.Population.Random.Models ), the ToHash() method is used in a computed property HashedMainGroup to provide a hashed representation of MainGroup . Usage in a class field: public string? HashedMainGroup => MainGroup?.ToHash(); In the CsvTest class ( Rystem.Test.UnitTest.Csv ), there is another example where ToHash() method is used to hash the MainGroup field of AppUser class: _users.Add(new AppUser { MainGroup = Guid.NewGuid().ToString() });","title":"CryptoExtensions Class"},{"location":"Rystem/System.Security.Cryptography/#cryptoextensions-class","text":"The CryptoExtensions class is a utility class that provides methods for hashing strings and objects.","title":"CryptoExtensions Class"},{"location":"Rystem/System.Security.Cryptography/#method-tohashthis-string-message","text":"This method computes the SHA512 hash of the provided string message.","title":"Method: ToHash(this string message)"},{"location":"Rystem/System.Security.Cryptography/#parameters","text":"message : The string that needs to be hashed.","title":"Parameters:"},{"location":"Rystem/System.Security.Cryptography/#return-value","text":"A hexadecimal string representing the hash value of the given string. The return type is string .","title":"Return Value:"},{"location":"Rystem/System.Security.Cryptography/#usage-example","text":"string originalString = \"This is a string to hash\"; string hashedString = originalString.ToHash();","title":"Usage Example:"},{"location":"Rystem/System.Security.Cryptography/#method-tohashtthis-t-message","text":"This method computes the SHA512 hash of the JSON representation of the provided object.","title":"Method: ToHash&lt;T&gt;(this T message)"},{"location":"Rystem/System.Security.Cryptography/#parameters_1","text":"message : The object that needs to be hashed.","title":"Parameters:"},{"location":"Rystem/System.Security.Cryptography/#return-value_1","text":"A hexadecimal string representing the hash value of the JSON string representation of the given object. The return type is string .","title":"Return Value:"},{"location":"Rystem/System.Security.Cryptography/#usage-example_1","text":"Foo objectToHash = new Foo{Values = new List<string> {\"aa\", \"bb\", \"cc\"}, X = true}; string hashedObject = objectToHash.ToHash(); This method is useful when you need to hash complex data structures, such as an entire class. Please note that the class should be serializable to JSON in order for this method to work. Above examples show several practical cases. You can hash any string or an object. ToHash() method also uses internally System.Text.Json for JSON representation of the object, so all constraints for that library apply here too.","title":"Usage Example:"},{"location":"Rystem/System.Security.Cryptography/#test-cases","text":"Several test cases from the HashTest class provide insight into usage of the ToHash() methods. Comparing the hash of an object to itself: var foo = new Foo() { Values = new List<string>() { \"aa\", \"bb\", \"cc\" }, X = true }; Assert.Equal(foo.ToHash(), foo.ToHash()); Hashing a UUID: var message = Guid.NewGuid(); Assert.Equal(message.ToHash(), message.ToHash()); Hashing a hard-coded UUID: var k = Guid.Parse(\"41e2c840-8ba1-4c0b-8a9b-781747a5de0c\"); Assert.Equal(\"18edf95916c3aa4fd09a754e2e799fce252b0b7a76ffff76962175ad0f9921bc13bbd675954c1121d9177ffc222622c5adecf8544acb7a844117d6b1fab4590a\", k.ToHash()); In the AppUser class ( Rystem.Test.UnitTest.System.Population.Random.Models ), the ToHash() method is used in a computed property HashedMainGroup to provide a hashed representation of MainGroup . Usage in a class field: public string? HashedMainGroup => MainGroup?.ToHash(); In the CsvTest class ( Rystem.Test.UnitTest.Csv ), there is another example where ToHash() method is used to hash the MainGroup field of AppUser class: _users.Add(new AppUser { MainGroup = Guid.NewGuid().ToString() });","title":"Test Cases"},{"location":"Rystem/System.Text.Csv/","text":"Documentation CsvEngine Class The CsvEngine class is an internal sealed class that helps with converting an IEnumerable<T> object into a string in CSV form. Method: Convert Convert transforms IEnumerable of T into a CSV String. Method Name: Convert<T> - Parameters: 1. values (IEnumerable ) : Sequence of any consumer-provided generic object type. Return Value: This method returns a string which represents the given Enumerable objects in CSV format. Note: \"T\" can be any class that the user wants to convert into CSV. Usage Example: // Assuming T is a class Product with fields Name (string) and Price (int) var products = new List<Product> { new Product {Name = \"Product1\", Price = 50}, new Product {Name = \"Product2\", Price = 60} }; var csv = CsvEngine.Convert(products); CsvEngineExtensions Class The CsvEngineExtensions class is a public static class which extends the functionality of IEnumerable<T> with a function ToCsv . Method: ToCsv The ToCsv method is an extension method for IEnumerable<T> that converts the sequence into a CSV formatted string. Method Name: ToCsv<T> - Parameters: 1. values ( IEnumerable<T> ): This is an extension method parameter representing the sequence of generic objects which need to be converted into CSV format. Return Value: This method returns a string representing the sequence in CSV format. Usage Example: var users = new List<User> { new User {Name = \"John\", Age = 24}, new User {Name = \"Jane\", Age = 20} }; string csvData = users.ToCsv(); Test Case: CsvTest The CsvTest class houses the test cases for the CsvEngine conversion methods. It creates a list of objects of Custom classes such as CsvModel , CsvInnerModel and AppUser . It then validates if the CSV conversion was successful for various types of fields, including nullable and complex types. [Fact] public void Test() { var value = _models.ToCsv(); Assert.NotEmpty(value); value = _users.ToCsv(); Assert.NotEmpty(value); } The test verifies if the CSV conversion works as expected by ensuring the string return from the conversion is not empty.","title":"Documentation"},{"location":"Rystem/System.Text.Csv/#documentation","text":"","title":"Documentation"},{"location":"Rystem/System.Text.Csv/#csvengine-class","text":"The CsvEngine class is an internal sealed class that helps with converting an IEnumerable<T> object into a string in CSV form.","title":"CsvEngine Class"},{"location":"Rystem/System.Text.Csv/#method-convert","text":"Convert transforms IEnumerable of T into a CSV String. Method Name: Convert<T> - Parameters: 1. values (IEnumerable ) : Sequence of any consumer-provided generic object type. Return Value: This method returns a string which represents the given Enumerable objects in CSV format. Note: \"T\" can be any class that the user wants to convert into CSV. Usage Example: // Assuming T is a class Product with fields Name (string) and Price (int) var products = new List<Product> { new Product {Name = \"Product1\", Price = 50}, new Product {Name = \"Product2\", Price = 60} }; var csv = CsvEngine.Convert(products);","title":"Method: Convert"},{"location":"Rystem/System.Text.Csv/#csvengineextensions-class","text":"The CsvEngineExtensions class is a public static class which extends the functionality of IEnumerable<T> with a function ToCsv .","title":"CsvEngineExtensions Class"},{"location":"Rystem/System.Text.Csv/#method-tocsv","text":"The ToCsv method is an extension method for IEnumerable<T> that converts the sequence into a CSV formatted string. Method Name: ToCsv<T> - Parameters: 1. values ( IEnumerable<T> ): This is an extension method parameter representing the sequence of generic objects which need to be converted into CSV format. Return Value: This method returns a string representing the sequence in CSV format. Usage Example: var users = new List<User> { new User {Name = \"John\", Age = 24}, new User {Name = \"Jane\", Age = 20} }; string csvData = users.ToCsv();","title":"Method: ToCsv"},{"location":"Rystem/System.Text.Csv/#test-case-csvtest","text":"The CsvTest class houses the test cases for the CsvEngine conversion methods. It creates a list of objects of Custom classes such as CsvModel , CsvInnerModel and AppUser . It then validates if the CSV conversion was successful for various types of fields, including nullable and complex types. [Fact] public void Test() { var value = _models.ToCsv(); Assert.NotEmpty(value); value = _users.ToCsv(); Assert.NotEmpty(value); } The test verifies if the CSV conversion works as expected by ensuring the string return from the conversion is not empty.","title":"Test Case: CsvTest"},{"location":"Rystem/System.Text.Json/","text":"Class Documentation Class: JsonExtensions This class is located in the System.Text.Json namespace and provides methods to work with JSON. This includes converting an entity to JSON and extracting an entity from a JSON representation. Method: ToJson Description : This method allows you to convert a provided entity into a JSON representation. The method utilizes the JsonSerializer class that is part of .NET's System.Text.Json library. Parameters : T entity : Specifies the entity input that you are trying to convert to a JSON representation. The entity could be of any type (T). JsonSerializerOptions? options = default : This optional parameter allows you to specify settings that configure parsing behavior when using JsonSerializer . Return Value : This method returns a string that represents the JSON representation of the input entity. Usage Example : var student = new Student(){ Name = \"John\", Age = 22 }; string studentJson = student.ToJson(); Method: FromJson (Overload 1) Description : This method allows you to convert a JSON string into a specified entity type. Parameters : string entity : The JSON string that you want to convert to an entity. JsonSerializerOptions? options = default : This optional parameter lets you specify settings for parsing JSON when using JsonSerializer . Return Value : This method returns an entity of the type (T), which was extracted from its JSON representation. Usage Example : string studentJson = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\"; Student student = studentJson.FromJson<Student>(); Method: FromJson (Overload 2) Description : This method converts a byte array into a specified entity type. Parameters : byte[] entity : The byte array of a JSON string that you want to convert to an entity. JsonSerializerOptions? options = default : Optional settings for parsing JSON data with JsonSerializer . Return Value : The method returns a deserialized entity of type (T) represented by the byte array. Usage Example : byte[] studentJsonBytes = Encoding.Default.GetBytes(\"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\"); Student student = studentJsonBytes.FromJson<Student>(); Method: FromJson (Overload 3) Description : This method converts a JSON string into a specific entity type known at runtime. Parameters : string entity : The JSON string to convert to an object. Type type : The System.Type of the object to convert the JSON string to. JsonSerializerOptions? options = default : Optional settings to use when parsing JSON data. Return Value : The method returns a deserialized object of the given Type . Usage Example : string studentJson = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\"; object student = studentJson.FromJson(typeof(Student)); Method: FromJsonAsync Description : This method asynchronously converts a Stream to a specific entity type. Parameters : Stream entity : The stream containing the JSON text to convert to an entity. JsonSerializerOptions? options = default : The Deserialize options. Return Value : The method returns an awaitable Task<T> that will result in a deserialized entity of specified type (T) upon completion. Usage Example : Stream studentJsonStream = new MemoryStream(Encoding.UTF8.GetBytes(\"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\")); Student student = await studentJsonStream.FromJsonAsync<Student>();","title":"Class Documentation"},{"location":"Rystem/System.Text.Json/#class-documentation","text":"","title":"Class Documentation"},{"location":"Rystem/System.Text.Json/#class-jsonextensions","text":"This class is located in the System.Text.Json namespace and provides methods to work with JSON. This includes converting an entity to JSON and extracting an entity from a JSON representation.","title":"Class: JsonExtensions"},{"location":"Rystem/System.Text.Json/#method-tojson","text":"Description : This method allows you to convert a provided entity into a JSON representation. The method utilizes the JsonSerializer class that is part of .NET's System.Text.Json library. Parameters : T entity : Specifies the entity input that you are trying to convert to a JSON representation. The entity could be of any type (T). JsonSerializerOptions? options = default : This optional parameter allows you to specify settings that configure parsing behavior when using JsonSerializer . Return Value : This method returns a string that represents the JSON representation of the input entity. Usage Example : var student = new Student(){ Name = \"John\", Age = 22 }; string studentJson = student.ToJson();","title":"Method: ToJson"},{"location":"Rystem/System.Text.Json/#method-fromjson-overload-1","text":"Description : This method allows you to convert a JSON string into a specified entity type. Parameters : string entity : The JSON string that you want to convert to an entity. JsonSerializerOptions? options = default : This optional parameter lets you specify settings for parsing JSON when using JsonSerializer . Return Value : This method returns an entity of the type (T), which was extracted from its JSON representation. Usage Example : string studentJson = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\"; Student student = studentJson.FromJson<Student>();","title":"Method: FromJson (Overload 1)"},{"location":"Rystem/System.Text.Json/#method-fromjson-overload-2","text":"Description : This method converts a byte array into a specified entity type. Parameters : byte[] entity : The byte array of a JSON string that you want to convert to an entity. JsonSerializerOptions? options = default : Optional settings for parsing JSON data with JsonSerializer . Return Value : The method returns a deserialized entity of type (T) represented by the byte array. Usage Example : byte[] studentJsonBytes = Encoding.Default.GetBytes(\"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\"); Student student = studentJsonBytes.FromJson<Student>();","title":"Method: FromJson (Overload 2)"},{"location":"Rystem/System.Text.Json/#method-fromjson-overload-3","text":"Description : This method converts a JSON string into a specific entity type known at runtime. Parameters : string entity : The JSON string to convert to an object. Type type : The System.Type of the object to convert the JSON string to. JsonSerializerOptions? options = default : Optional settings to use when parsing JSON data. Return Value : The method returns a deserialized object of the given Type . Usage Example : string studentJson = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\"; object student = studentJson.FromJson(typeof(Student));","title":"Method: FromJson (Overload 3)"},{"location":"Rystem/System.Text.Json/#method-fromjsonasync","text":"Description : This method asynchronously converts a Stream to a specific entity type. Parameters : Stream entity : The stream containing the JSON text to convert to an entity. JsonSerializerOptions? options = default : The Deserialize options. Return Value : The method returns an awaitable Task<T> that will result in a deserialized entity of specified type (T) upon completion. Usage Example : Stream studentJsonStream = new MemoryStream(Encoding.UTF8.GetBytes(\"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":22}\")); Student student = await studentJsonStream.FromJsonAsync<Student>();","title":"Method: FromJsonAsync"},{"location":"Rystem/System.Text.Minimization/","text":"System.Text.Minimization This namespace consists of several classes and interfaces that principally help in the process of optimizing (minimizing) the data in certain ways, such as serialization and deserialization. Here, we will provide detailed documentation for each class and its public methods. 1. MinimizationConvertExtensions Method: ToMinimize This method minimizes the given data of generic type. Parameters : data (T) : Data of any type that needs to be minimized. startSeparator (char?) : An optional character to use as the starting separator. the default value is null. Return Value : It returns a string which is the minimized version of the input data. Usage Example : csharp var data = new List<int> {1, 2, 3}; var minimizedData = data.ToMinimize(); Method: FromMinimization This method converts a minimized string back to its original form. Parameters : value (string) : The minimized string value. startSeparator (char?) : An optional character that was used as the starting separator during minimization. the default value is null. Return Value : It returns the original form of the minimized data of type T. Usage Example : csharp var minimizedData = \"1,2,3\"; var originalData = minimizedData.FromMinimization<List<int>>(); 2. MinimizationIgnore Used to mark certain parameters to be ignored during the Minimization process. This class doesn't have any public methods defined, it's an attribute used to define how other methods behave. It's used like this: [MinimizationIgnore] public int PropertyName { get; set; } In this example, the attribute would exclude PropertyName from being minimized. 3. MinimizationPropertyAttribute Represents an attribute to mark certain properties for the Minimization process. Properties: Column The order of the column in the minimization process. Usage Example : [MinimizationPropertyAttribute(1)] public int PropertyName { get; set; } In this example, the property PropertyName would take the 1st position in the process of minimization. The internal classes ( ArraySerializer , DictionarySerializer , EnumerableSerializer , ObjectSerializer , PrimitiveSerializer , Serializer , and IMinimizationInterpreter interface) are utilized internally to perform serialization and deserialization of different data types and structures during the process of minimization. These classes are not designed for direct use outside the library. Note: The namespace also includes important attributes like MinimizationIgnore and MinimizationPropertyAttribute which are used to control how objects are minimized, down to the parameter level. Test class: MinimizationTest The test class includes two test methods Test1 and Test2 , each of which sequentially uses the extention methods ToMinimize and FromMinimization to make sure the minimized string can be correctly converted back to its original form. The tests assert that the Minimization procedures are working correctly. Usage examples from test cases: var value = s_models.ToMinimize('&'); var models2 = value.FromMinimization<List<CsvModel>>('&'); In this example, ToMinimize is used with the & character as the start separator to minimize a list of CsvModel , and FromMinimization is utilized to convert it back. var value = s_models.ToMinimize(); var models2 = value.FromMinimization<List<CsvModel>>(); In this example, ToMinimize and FromMinimization are used without specifying a start separator and the library handles the choice of separator character.","title":"System.Text.Minimization"},{"location":"Rystem/System.Text.Minimization/#systemtextminimization","text":"This namespace consists of several classes and interfaces that principally help in the process of optimizing (minimizing) the data in certain ways, such as serialization and deserialization. Here, we will provide detailed documentation for each class and its public methods.","title":"System.Text.Minimization"},{"location":"Rystem/System.Text.Minimization/#1-minimizationconvertextensions","text":"","title":"1. MinimizationConvertExtensions"},{"location":"Rystem/System.Text.Minimization/#method-tominimize","text":"This method minimizes the given data of generic type. Parameters : data (T) : Data of any type that needs to be minimized. startSeparator (char?) : An optional character to use as the starting separator. the default value is null. Return Value : It returns a string which is the minimized version of the input data. Usage Example : csharp var data = new List<int> {1, 2, 3}; var minimizedData = data.ToMinimize();","title":"Method: ToMinimize"},{"location":"Rystem/System.Text.Minimization/#method-fromminimization","text":"This method converts a minimized string back to its original form. Parameters : value (string) : The minimized string value. startSeparator (char?) : An optional character that was used as the starting separator during minimization. the default value is null. Return Value : It returns the original form of the minimized data of type T. Usage Example : csharp var minimizedData = \"1,2,3\"; var originalData = minimizedData.FromMinimization<List<int>>();","title":"Method: FromMinimization"},{"location":"Rystem/System.Text.Minimization/#2-minimizationignore","text":"Used to mark certain parameters to be ignored during the Minimization process. This class doesn't have any public methods defined, it's an attribute used to define how other methods behave. It's used like this: [MinimizationIgnore] public int PropertyName { get; set; } In this example, the attribute would exclude PropertyName from being minimized.","title":"2. MinimizationIgnore"},{"location":"Rystem/System.Text.Minimization/#3-minimizationpropertyattribute","text":"Represents an attribute to mark certain properties for the Minimization process.","title":"3. MinimizationPropertyAttribute"},{"location":"Rystem/System.Text.Minimization/#properties-column","text":"The order of the column in the minimization process.","title":"Properties: Column"},{"location":"Rystem/System.Text.Minimization/#usage-example","text":"[MinimizationPropertyAttribute(1)] public int PropertyName { get; set; } In this example, the property PropertyName would take the 1st position in the process of minimization. The internal classes ( ArraySerializer , DictionarySerializer , EnumerableSerializer , ObjectSerializer , PrimitiveSerializer , Serializer , and IMinimizationInterpreter interface) are utilized internally to perform serialization and deserialization of different data types and structures during the process of minimization. These classes are not designed for direct use outside the library. Note: The namespace also includes important attributes like MinimizationIgnore and MinimizationPropertyAttribute which are used to control how objects are minimized, down to the parameter level.","title":"Usage Example:"},{"location":"Rystem/System.Text.Minimization/#test-class-minimizationtest","text":"The test class includes two test methods Test1 and Test2 , each of which sequentially uses the extention methods ToMinimize and FromMinimization to make sure the minimized string can be correctly converted back to its original form. The tests assert that the Minimization procedures are working correctly. Usage examples from test cases: var value = s_models.ToMinimize('&'); var models2 = value.FromMinimization<List<CsvModel>>('&'); In this example, ToMinimize is used with the & character as the start separator to minimize a list of CsvModel , and FromMinimization is utilized to convert it back. var value = s_models.ToMinimize(); var models2 = value.FromMinimization<List<CsvModel>>(); In this example, ToMinimize and FromMinimization are used without specifying a start separator and the library handles the choice of separator character.","title":"Test class: MinimizationTest"},{"location":"Rystem/System.Text/","text":"Documentation of the System.Text library This documentation is for the System.Text library from the Rystem Nuget package. The classes described in this document are part of the base encoding logic that uses Fare, System.Linq.Dynamic.Core, System.Interactive and System.Interactive.Async libraries. The library provides extensions for the string type, along with extensions for various encoding and decoding. Base45Extensions Class This class provides extension methods to encode and decode data into and from Base45 format. Method Name: ToBase45 (from string value) Purpose : Converts a UTF-8 string into Base45. Parameters : value ( string ): The string to be converted into Base45. Return Value : The converted string in Base45 format (Type: string ). Usage Example : string base45Encoded = \"Hello World!\".ToBase45(); Method Name: ToBase45 (from T entity) Purpose : Converts a given object into a JSON string, then encodes it into Base45. Parameters : entity ( T ): The object to be converted into Base45. Return Value : The encoded object in Base45 format (Type: string ). Usage Example : Person person = new Person { Name = \"John Doe\", Age = 35 }; string base45Encoded = person.ToBase45(); Method Name: FromBase45 (from string encodedValue) Purpose : Decodes an encoded Base45 string back into a UTF-8 string. Parameters : encodedValue ( string ): The Base45 encoded string. Return Value : The decoded UTF-8 string (Type: string ). Usage Example : string originalValue = base45Encoded.FromBase45(); Method Name: FromBase45 (from T type) Purpose : Decodes an encoded Base45 string into a specific object type. Parameters : encodedValue ( string ): The Base45 encoded string. Return Value : The decoded object of type T (Type: T ). Usage Example : Person originalPerson = base45Encoded.FromBase45<Person>(); Base64Extensions Class This class provides extension methods to encode and decode data into and from Base64 format. Method Name: ToBase64 (from string value) Purpose : Converts a UTF-8 string into Base64. Parameters : value ( string ): The string to be converted into Base64. Return Value : The converted string in Base64 format (Type: string ). Usage Example : string base64Encoded = \"Hello World!\".ToBase64(); Method Name: ToBase64 (from T entity) Purpose : Converts a given object into a JSON string, then encodes it into Base64. Parameters : entity ( T ): The object to be converted into Base64. Return Value : The encoded object in Base64 format (Type: string ). Usage Example : Person person = new Person { Name = \"John Doe\", Age = 35 }; string base64Encoded = person.ToBase64(); Method Name: FromBase64 (from string encodedValue) Purpose : Decodes an encoded Base64 string back into a UTF-8 string. Parameters : encodedValue ( string ): The Base64 encoded string. Return Value : The decoded UTF-8 string (Type: string ). Usage Example : string originalValue = base64Encoded.FromBase64(); Method Name: FromBase64 (from T type) Purpose : Decodes an encoded Base64 string into a specific object type. Parameters : encodedValue ( string ): The Base64 encoded string. Return Value : The decoded object of type T (Type: T ). Usage Example : Person originalPerson = base64Encoded.FromBase64<Person>(); StringExtensions Class This class provides a wide range of extension methods to manipulate and convert strings, byte arrays, and data streams. For brevity, only a few key methods are documented below: Method Name: ToUpperCaseFirst Purpose : Capitalizes the first letter of a string and converts the rest into lowercase. Parameters : value ( string ): The string to be converted. Return Value : The converted string with the first letter in uppercase and the rest in lowercase (Type: string ). Usage Example : string capitalized = \"hello world!\".ToUpperCaseFirst(); Method Name: ConvertToStringAsync (from Stream entity) Purpose : Reads an entire stream asynchronously and returns its content as a UTF-8 encoded string. Parameters : entity ( Stream ): The stream to be read. Return Value : The content of the stream as a UTF-8 encoded string (Type: Task<string> ). Usage Example : string content = await stream.ConvertToStringAsync(); Method Name: ToStream (from string entity) Purpose : Converts a string into a memory stream using the UTF-8 encoding. Parameters : entity ( string ): The string to be converted into a stream. Return Value : The converted string as a memory stream (Type: Stream ). Usage Example : Stream stream = \"Hello World!\".ToStream(); Note: The full list of methods includes additional string manipulations, conversions to/from byte arrays, stream manipulations, and encoder/decoder converters for various encoding types. Refer to the provided class list for the complete method signatures. EncodingType Enum This enumeration is used in all encoding/decoding related functions in this library. It includes all the possible encodings to be used in these functions: - Default, - ASCII, - UTF8, - UTF7, - UTF32, - Latin1, - BigEndianUnicode.","title":"Documentation of the System.Text library"},{"location":"Rystem/System.Text/#documentation-of-the-systemtext-library","text":"This documentation is for the System.Text library from the Rystem Nuget package. The classes described in this document are part of the base encoding logic that uses Fare, System.Linq.Dynamic.Core, System.Interactive and System.Interactive.Async libraries. The library provides extensions for the string type, along with extensions for various encoding and decoding.","title":"Documentation of the System.Text library"},{"location":"Rystem/System.Text/#base45extensions-class","text":"This class provides extension methods to encode and decode data into and from Base45 format.","title":"Base45Extensions Class"},{"location":"Rystem/System.Text/#method-name-tobase45-from-string-value","text":"Purpose : Converts a UTF-8 string into Base45. Parameters : value ( string ): The string to be converted into Base45. Return Value : The converted string in Base45 format (Type: string ). Usage Example : string base45Encoded = \"Hello World!\".ToBase45();","title":"Method Name: ToBase45 (from string value)"},{"location":"Rystem/System.Text/#method-name-tobase45-from-t-entity","text":"Purpose : Converts a given object into a JSON string, then encodes it into Base45. Parameters : entity ( T ): The object to be converted into Base45. Return Value : The encoded object in Base45 format (Type: string ). Usage Example : Person person = new Person { Name = \"John Doe\", Age = 35 }; string base45Encoded = person.ToBase45();","title":"Method Name: ToBase45 (from T entity)"},{"location":"Rystem/System.Text/#method-name-frombase45-from-string-encodedvalue","text":"Purpose : Decodes an encoded Base45 string back into a UTF-8 string. Parameters : encodedValue ( string ): The Base45 encoded string. Return Value : The decoded UTF-8 string (Type: string ). Usage Example : string originalValue = base45Encoded.FromBase45();","title":"Method Name: FromBase45 (from string encodedValue)"},{"location":"Rystem/System.Text/#method-name-frombase45-from-t-type","text":"Purpose : Decodes an encoded Base45 string into a specific object type. Parameters : encodedValue ( string ): The Base45 encoded string. Return Value : The decoded object of type T (Type: T ). Usage Example : Person originalPerson = base45Encoded.FromBase45<Person>();","title":"Method Name: FromBase45 (from T type)"},{"location":"Rystem/System.Text/#base64extensions-class","text":"This class provides extension methods to encode and decode data into and from Base64 format.","title":"Base64Extensions Class"},{"location":"Rystem/System.Text/#method-name-tobase64-from-string-value","text":"Purpose : Converts a UTF-8 string into Base64. Parameters : value ( string ): The string to be converted into Base64. Return Value : The converted string in Base64 format (Type: string ). Usage Example : string base64Encoded = \"Hello World!\".ToBase64();","title":"Method Name: ToBase64 (from string value)"},{"location":"Rystem/System.Text/#method-name-tobase64-from-t-entity","text":"Purpose : Converts a given object into a JSON string, then encodes it into Base64. Parameters : entity ( T ): The object to be converted into Base64. Return Value : The encoded object in Base64 format (Type: string ). Usage Example : Person person = new Person { Name = \"John Doe\", Age = 35 }; string base64Encoded = person.ToBase64();","title":"Method Name: ToBase64 (from T entity)"},{"location":"Rystem/System.Text/#method-name-frombase64-from-string-encodedvalue","text":"Purpose : Decodes an encoded Base64 string back into a UTF-8 string. Parameters : encodedValue ( string ): The Base64 encoded string. Return Value : The decoded UTF-8 string (Type: string ). Usage Example : string originalValue = base64Encoded.FromBase64();","title":"Method Name: FromBase64 (from string encodedValue)"},{"location":"Rystem/System.Text/#method-name-frombase64-from-t-type","text":"Purpose : Decodes an encoded Base64 string into a specific object type. Parameters : encodedValue ( string ): The Base64 encoded string. Return Value : The decoded object of type T (Type: T ). Usage Example : Person originalPerson = base64Encoded.FromBase64<Person>();","title":"Method Name: FromBase64 (from T type)"},{"location":"Rystem/System.Text/#stringextensions-class","text":"This class provides a wide range of extension methods to manipulate and convert strings, byte arrays, and data streams. For brevity, only a few key methods are documented below:","title":"StringExtensions Class"},{"location":"Rystem/System.Text/#method-name-touppercasefirst","text":"Purpose : Capitalizes the first letter of a string and converts the rest into lowercase. Parameters : value ( string ): The string to be converted. Return Value : The converted string with the first letter in uppercase and the rest in lowercase (Type: string ). Usage Example : string capitalized = \"hello world!\".ToUpperCaseFirst();","title":"Method Name: ToUpperCaseFirst"},{"location":"Rystem/System.Text/#method-name-converttostringasync-from-stream-entity","text":"Purpose : Reads an entire stream asynchronously and returns its content as a UTF-8 encoded string. Parameters : entity ( Stream ): The stream to be read. Return Value : The content of the stream as a UTF-8 encoded string (Type: Task<string> ). Usage Example : string content = await stream.ConvertToStringAsync();","title":"Method Name: ConvertToStringAsync (from Stream entity)"},{"location":"Rystem/System.Text/#method-name-tostream-from-string-entity","text":"Purpose : Converts a string into a memory stream using the UTF-8 encoding. Parameters : entity ( string ): The string to be converted into a stream. Return Value : The converted string as a memory stream (Type: Stream ). Usage Example : Stream stream = \"Hello World!\".ToStream(); Note: The full list of methods includes additional string manipulations, conversions to/from byte arrays, stream manipulations, and encoder/decoder converters for various encoding types. Refer to the provided class list for the complete method signatures.","title":"Method Name: ToStream (from string entity)"},{"location":"Rystem/System.Text/#encodingtype-enum","text":"This enumeration is used in all encoding/decoding related functions in this library. It includes all the possible encodings to be used in these functions: - Default, - ASCII, - UTF8, - UTF7, - UTF32, - Latin1, - BigEndianUnicode.","title":"EncodingType Enum"},{"location":"Rystem/System.Threading.Tasks/","text":"RystemTask Class Class Overview: This static class that provides configuration for task execution. Property Description WaitYourStartingThread An option to determine whether the starting thread should wait till the task has finished RystemTaskExtensions Class Class Overview: This static class provides extension methods to Task , Task<T> , ValueTask , ValueTask<T> , and IAsyncEnumerable<T> , providing properties such as NoContext and ToListAsync, amongst others. Methods: NoContext() : Method Name : NoContext Description : Ensures that the task continues on the captured context or not, depending on WaitYourStartingThread value. Parameters : None. Return Value : A ConfiguredTaskAwaitable that represents the configured task. Usage Example : // example task Task exampleTask = Task.Run(() => { ... }); exampleTask.NoContext(); ToListAsync<T>() : Method Name : ToListAsync Description : Converts an IAsyncEnumerable<T> to a ValueTask<List<T>> . Parameters : - items (IAsyncEnumerable<T>) : The async enumerable we want to convert. Return Value : A ValueTask<List<T>> that represents the list of items. Usage Example : IAsyncEnumerable<int> numbers = GetNumbers(); ValueTask<List<int>> numberList = numbers.ToListAsync(); ToResult() : Method Name : ToResult Description : Gets the result of the Task/ValueTask synchronously, and blocks the execution until the task has completed. Parameters : None. Return Value : Returns the result of the Task/ValueTask if it is of type Task<T> or ValueTask<T> , otherwise nothing. Usage Example : Task<int> exampleTask = GetNumberAsync(); int result = exampleTask.ToResult(); TaskManager Class Class Overview: This static class manages various tasks based on a specific function provided, and provides control over cancellation, concurrency and execution frequency. Methods: WhenAll() : Method Name : WhenAll Description : Executes a list of tasks concurrently and waits for all tasks to complete. Parameters : - task (Func<int, CancellationToken, Task>) : Function that generates the tasks. - times (int) : The number of times the task should be executed. - concurrentTask (int) : The max number of tasks that will be run concurrently. - runEverytimeASlotIsFree (bool) : If set to true, a new task will be started immediately when a task finishes. If false, waits till all concurrent tasks finish to start a new round. - cancellationToken (CancellationToken) : A cancellation token to cancel the tasks. Return Value : Returns a Task representing the asynchronous operation of executing all tasks. Usage Example : TaskManager.WhenAll( async (int i, CancellationToken token) => { ... }, //a task-taking function 100, // execute 100 times 10, // at most 10 concurrent tasks true, // don't wait for all tasks to finish to start new ones token // cancellation token ); WhenAtLeast() : Method Name : WhenAtLeast Description : Executes a list of tasks concurrently and waits for a minimum number of tasks to complete. Parameters : - task (Func<int, CancellationToken, Task>) : Function that generates the tasks. - times (int) : The number of times the task should be executed. - atLeast (int) : The min number of tasks that should be completed to finish. - concurrentTask (int) : The max number of tasks that will be run concurrently. - cancellationToken (CancellationToken) : A cancellation token to cancel the tasks. Return Value : Returns a Task representing the asynchronous operation of executing a minimum number of tasks. Usage Example : TaskManager.WhenAtLeast( async (int i, CancellationToken token) => { ... }, //a task-taking function 100, // execute 100 times 70, // wait for at least 70 tasks to complete 10, // at most 10 concurrent tasks token // cancellation token );","title":"RystemTask Class"},{"location":"Rystem/System.Threading.Tasks/#rystemtask-class","text":"","title":"RystemTask Class"},{"location":"Rystem/System.Threading.Tasks/#class-overview","text":"This static class that provides configuration for task execution. Property Description WaitYourStartingThread An option to determine whether the starting thread should wait till the task has finished","title":"Class Overview:"},{"location":"Rystem/System.Threading.Tasks/#rystemtaskextensions-class","text":"","title":"RystemTaskExtensions Class"},{"location":"Rystem/System.Threading.Tasks/#class-overview_1","text":"This static class provides extension methods to Task , Task<T> , ValueTask , ValueTask<T> , and IAsyncEnumerable<T> , providing properties such as NoContext and ToListAsync, amongst others.","title":"Class Overview:"},{"location":"Rystem/System.Threading.Tasks/#methods","text":"","title":"Methods:"},{"location":"Rystem/System.Threading.Tasks/#nocontext","text":"Method Name : NoContext Description : Ensures that the task continues on the captured context or not, depending on WaitYourStartingThread value. Parameters : None. Return Value : A ConfiguredTaskAwaitable that represents the configured task. Usage Example : // example task Task exampleTask = Task.Run(() => { ... }); exampleTask.NoContext();","title":"NoContext():"},{"location":"Rystem/System.Threading.Tasks/#tolistasynct","text":"Method Name : ToListAsync Description : Converts an IAsyncEnumerable<T> to a ValueTask<List<T>> . Parameters : - items (IAsyncEnumerable<T>) : The async enumerable we want to convert. Return Value : A ValueTask<List<T>> that represents the list of items. Usage Example : IAsyncEnumerable<int> numbers = GetNumbers(); ValueTask<List<int>> numberList = numbers.ToListAsync();","title":"ToListAsync&lt;T&gt;():"},{"location":"Rystem/System.Threading.Tasks/#toresult","text":"Method Name : ToResult Description : Gets the result of the Task/ValueTask synchronously, and blocks the execution until the task has completed. Parameters : None. Return Value : Returns the result of the Task/ValueTask if it is of type Task<T> or ValueTask<T> , otherwise nothing. Usage Example : Task<int> exampleTask = GetNumberAsync(); int result = exampleTask.ToResult();","title":"ToResult():"},{"location":"Rystem/System.Threading.Tasks/#taskmanager-class","text":"","title":"TaskManager Class"},{"location":"Rystem/System.Threading.Tasks/#class-overview_2","text":"This static class manages various tasks based on a specific function provided, and provides control over cancellation, concurrency and execution frequency.","title":"Class Overview:"},{"location":"Rystem/System.Threading.Tasks/#methods_1","text":"","title":"Methods:"},{"location":"Rystem/System.Threading.Tasks/#whenall","text":"Method Name : WhenAll Description : Executes a list of tasks concurrently and waits for all tasks to complete. Parameters : - task (Func<int, CancellationToken, Task>) : Function that generates the tasks. - times (int) : The number of times the task should be executed. - concurrentTask (int) : The max number of tasks that will be run concurrently. - runEverytimeASlotIsFree (bool) : If set to true, a new task will be started immediately when a task finishes. If false, waits till all concurrent tasks finish to start a new round. - cancellationToken (CancellationToken) : A cancellation token to cancel the tasks. Return Value : Returns a Task representing the asynchronous operation of executing all tasks. Usage Example : TaskManager.WhenAll( async (int i, CancellationToken token) => { ... }, //a task-taking function 100, // execute 100 times 10, // at most 10 concurrent tasks true, // don't wait for all tasks to finish to start new ones token // cancellation token );","title":"WhenAll():"},{"location":"Rystem/System.Threading.Tasks/#whenatleast","text":"Method Name : WhenAtLeast Description : Executes a list of tasks concurrently and waits for a minimum number of tasks to complete. Parameters : - task (Func<int, CancellationToken, Task>) : Function that generates the tasks. - times (int) : The number of times the task should be executed. - atLeast (int) : The min number of tasks that should be completed to finish. - concurrentTask (int) : The max number of tasks that will be run concurrently. - cancellationToken (CancellationToken) : A cancellation token to cancel the tasks. Return Value : Returns a Task representing the asynchronous operation of executing a minimum number of tasks. Usage Example : TaskManager.WhenAtLeast( async (int i, CancellationToken token) => { ... }, //a task-taking function 100, // execute 100 times 70, // wait for at least 70 tasks to complete 10, // at most 10 concurrent tasks token // cancellation token );","title":"WhenAtLeast():"},{"location":"Rystem/System/","text":"Class: CastExtensions This class contains extension methods for casting a value of any given type to another specified type. The type conversions include the common primitive types and some system types. Method: Cast This method allows you to cast an object to another type. Parameters: - entity (object) : The object that needs to be cast. Return Value: The method returns a value of type T. Returns a default value if the cast isn't successful. Usage Example: string myStr = \"100\"; int myConvertedStr = myStr.Cast<int>(); Console.WriteLine(myConvertedStr); // Output: 100 Method: Cast This method allows you to cast an object to a type specified at runtime. Parameters: - entity (object) : The object that requires casting. - typeToCast (Type) : The type to which the entity needs to be cast. Return Value: The method returns an object that has been cast to typeToCast . Returns a default value if the cast fails. Usage Example: string myStr = \"100\"; Type myType = typeof(int); dynamic myConvertedStr = CastExtensions.Cast(myStr, myType); Console.WriteLine(myConvertedStr); // Output: 100 Class: CopyExtensions This class contains methods that help to deep copy an object or copy properties from one object to another object of the same type. Method: ToDeepCopy This method creates a deep copy of the source object of generic type T. Parameters: - source (T) : The object that needs to be deeply copied. Return Value: The method returns a new object with the cloned values from the provided source . Returns a default value if the object to be copied is null. Usage Example: Student student1 = new Student { Name = \"John\", Age = 20 }; Student student2 = student1.ToDeepCopy(); Method: ToDeepCopy This method creates a deep copy of the source object. Parameters: - source (object) : The object that needs to be deeply copied. Return Value: The method returns a new object with cloned values from the provided source . Returns a default value if the object to be copied is null. Usage Example: object myObject1 = new Student { Name = \"John\", Age = 20 }; object myObject2 = myObject1.ToDeepCopy(); Class: EnumExtensions This class provides extension methods for Enum and string types to convert them to specific Enum type. Method: ToEnum (for Enum types) This method converts a source Enum to another Enum type TEnum. Parameters: - source (Enum) : The source Enum which needs to be converted. Return Value: The method returns an Enum of type TEnum. Usage Example: public enum MyEnum { One = 1, Two = 2 } ... DayOfWeek day = DayOfWeek.Monday; MyEnum myEnum = day.ToEnum<MyEnum>(); // Output: MyEnum.One Class: StringExtensions This class provides methods to manipulate strings, such as replacing occurrences of a substring. Method: Replace This method replaces occurrences times of the substring oldValue with a newValue in the provided value . Parameters: - value (string) : The source string. - oldValue (string) : The substring that needs to be replaced. - newValue (string) : The new substring to replace oldValue . - occurrences (int) : The number of occurrences of oldValue that should be replaced. Return Value: The method returns a modified string with replaced values. Usage Example: string myStr = \"Hello world! Hello world!\"; string newStr = myStr.Replace(\"world\", \"universe\", 1); Console.WriteLine(newStr); // Output: \"Hello universe! Hello world!\" Class: Try This class provides methods that execute other methods and handle exceptions with the option for retry behavior. Method: WithDefaultOnCatch This method executes a function and catches any thrown exceptions. Parameters: - function (Func<T>) : The function to execute. - behavior (Action<TryBehavior>?) : This optional action defines the retry policy. Return Value: The method returns an instance of TryResponse<T> . This includes both the result of function and any exception that might have occurred. Usage Example: TryResponse<int> myTry = Try.WithDefaultOnCatch(() => { // your code that may throw exception. return 1; }); Class: Stopwatch This class provides methods to monitor the execution time of operations. Method: Monitor This method measures the execution time of an action. Parameters: - action (Action) : The action whose execution time needs to be measured. Return Value: The method returns a StopwatchResult which contains information about the start and stop time of the action's execution. Usage Example: StopwatchResult result = Stopwatch.Monitor(() => { // your code here (e.g., a lengthy operation) }); Console.WriteLine(result.Span.TotalSeconds); Class: StopwatchStart Method: Stop This method stops the stopwatch and returns the elapsed time between start and stop as a StopwatchResult instance. Return Value: The method returns an instance of StopwatchResult . Usage Example: StopwatchStart stopwatch = Stopwatch.Start(); Thread.Sleep(2000); StopwatchResult result = stopwatch.Stop(); Console.WriteLine(result.Span.TotalSeconds); // Output: 2","title":"Class: CastExtensions"},{"location":"Rystem/System/#class-castextensions","text":"This class contains extension methods for casting a value of any given type to another specified type. The type conversions include the common primitive types and some system types.","title":"Class: CastExtensions"},{"location":"Rystem/System/#method-cast","text":"This method allows you to cast an object to another type. Parameters: - entity (object) : The object that needs to be cast. Return Value: The method returns a value of type T. Returns a default value if the cast isn't successful. Usage Example: string myStr = \"100\"; int myConvertedStr = myStr.Cast<int>(); Console.WriteLine(myConvertedStr); // Output: 100","title":"Method: Cast"},{"location":"Rystem/System/#method-cast_1","text":"This method allows you to cast an object to a type specified at runtime. Parameters: - entity (object) : The object that requires casting. - typeToCast (Type) : The type to which the entity needs to be cast. Return Value: The method returns an object that has been cast to typeToCast . Returns a default value if the cast fails. Usage Example: string myStr = \"100\"; Type myType = typeof(int); dynamic myConvertedStr = CastExtensions.Cast(myStr, myType); Console.WriteLine(myConvertedStr); // Output: 100","title":"Method: Cast"},{"location":"Rystem/System/#class-copyextensions","text":"This class contains methods that help to deep copy an object or copy properties from one object to another object of the same type.","title":"Class: CopyExtensions"},{"location":"Rystem/System/#method-todeepcopy","text":"This method creates a deep copy of the source object of generic type T. Parameters: - source (T) : The object that needs to be deeply copied. Return Value: The method returns a new object with the cloned values from the provided source . Returns a default value if the object to be copied is null. Usage Example: Student student1 = new Student { Name = \"John\", Age = 20 }; Student student2 = student1.ToDeepCopy();","title":"Method: ToDeepCopy"},{"location":"Rystem/System/#method-todeepcopy_1","text":"This method creates a deep copy of the source object. Parameters: - source (object) : The object that needs to be deeply copied. Return Value: The method returns a new object with cloned values from the provided source . Returns a default value if the object to be copied is null. Usage Example: object myObject1 = new Student { Name = \"John\", Age = 20 }; object myObject2 = myObject1.ToDeepCopy();","title":"Method: ToDeepCopy"},{"location":"Rystem/System/#class-enumextensions","text":"This class provides extension methods for Enum and string types to convert them to specific Enum type.","title":"Class: EnumExtensions"},{"location":"Rystem/System/#method-toenum-for-enum-types","text":"This method converts a source Enum to another Enum type TEnum. Parameters: - source (Enum) : The source Enum which needs to be converted. Return Value: The method returns an Enum of type TEnum. Usage Example: public enum MyEnum { One = 1, Two = 2 } ... DayOfWeek day = DayOfWeek.Monday; MyEnum myEnum = day.ToEnum<MyEnum>(); // Output: MyEnum.One","title":"Method: ToEnum (for Enum types)"},{"location":"Rystem/System/#class-stringextensions","text":"This class provides methods to manipulate strings, such as replacing occurrences of a substring.","title":"Class: StringExtensions"},{"location":"Rystem/System/#method-replace","text":"This method replaces occurrences times of the substring oldValue with a newValue in the provided value . Parameters: - value (string) : The source string. - oldValue (string) : The substring that needs to be replaced. - newValue (string) : The new substring to replace oldValue . - occurrences (int) : The number of occurrences of oldValue that should be replaced. Return Value: The method returns a modified string with replaced values. Usage Example: string myStr = \"Hello world! Hello world!\"; string newStr = myStr.Replace(\"world\", \"universe\", 1); Console.WriteLine(newStr); // Output: \"Hello universe! Hello world!\"","title":"Method: Replace"},{"location":"Rystem/System/#class-try","text":"This class provides methods that execute other methods and handle exceptions with the option for retry behavior.","title":"Class: Try"},{"location":"Rystem/System/#method-withdefaultoncatch","text":"This method executes a function and catches any thrown exceptions. Parameters: - function (Func<T>) : The function to execute. - behavior (Action<TryBehavior>?) : This optional action defines the retry policy. Return Value: The method returns an instance of TryResponse<T> . This includes both the result of function and any exception that might have occurred. Usage Example: TryResponse<int> myTry = Try.WithDefaultOnCatch(() => { // your code that may throw exception. return 1; });","title":"Method: WithDefaultOnCatch"},{"location":"Rystem/System/#class-stopwatch","text":"This class provides methods to monitor the execution time of operations.","title":"Class: Stopwatch"},{"location":"Rystem/System/#method-monitor","text":"This method measures the execution time of an action. Parameters: - action (Action) : The action whose execution time needs to be measured. Return Value: The method returns a StopwatchResult which contains information about the start and stop time of the action's execution. Usage Example: StopwatchResult result = Stopwatch.Monitor(() => { // your code here (e.g., a lengthy operation) }); Console.WriteLine(result.Span.TotalSeconds);","title":"Method: Monitor"},{"location":"Rystem/System/#class-stopwatchstart","text":"","title":"Class: StopwatchStart"},{"location":"Rystem/System/#method-stop","text":"This method stops the stopwatch and returns the elapsed time between start and stop as a StopwatchResult instance. Return Value: The method returns an instance of StopwatchResult . Usage Example: StopwatchStart stopwatch = Stopwatch.Start(); Thread.Sleep(2000); StopwatchResult result = stopwatch.Stop(); Console.WriteLine(result.Span.TotalSeconds); // Output: 2","title":"Method: Stop"},{"location":"Rystem.DependencyInjection/System.Population.Random/","text":"Rystem.DependencyInjection Documentation Class: PopulationSettings This class acts as a collection of settings that influence the generation of random population data for testing or development purposes. Properties: Dictionary RegexForValueCreation : This dictionary is used to create values using regular expressions. The dictionary key corresponds to the name of a specific property on an object, and the array of strings is a set of regular expressions it can match. Dictionary > DelegatedMethodForValueCreation : This dictionary allows you to specify methods to generate values for specific properties. The key of the dictionary is the name of the property, and the value is a delegate function that returns the value for that property. Dictionary >> DelegatedMethodForValueRetrieving : If you need to retrieve a value asynchronously using an IServiceProvider, you can define a method that takes the IServiceProvider as a parameter and returns a Task . The key of this dictionary should be the name of the property for which the value is retrieved. Dictionary >>> DelegatedMethodWithRandomForValueRetrieving : Similar to DelegatedMethodForValueRetrieving , but for methods that return an IEnumerable of dynamic objects. Dictionary AutoIncrementations : This property allows for the automatic increment of certain values. The key corresponds to the property on an object, and the value is the measure of the auto-increment. Dictionary RandomValueFromRystem : This dictionary hooks up the random population generator with specific properties. The key or the dictionary is the property name, and the value is a RandomPopulationFromRystemSettings object. Dictionary ImplementationForValueCreation : This dictionary allows you to map a type to a specific property for creating a value. Dictionary ForcedNumberOfElementsForEnumerable : This dictionary lets you dictate the number of elements for an IEnumerable property. The key is the property name, and the value is the number of elements. int NumberOfElements : General number of elements be created by the population generator. Class: PopulationSettings This class simply inherits from PopulationSettings , allowing the users to define settings that are strongly typed to a specific class. Class: RandomPopulationFromRystemSettings A settings store governing decisions about the random population generated values. Properties: bool UseTheSameRandomValuesForTheSameType : If set to true, this ensures that all properties of the same type get populated with the same random value. Type StartingType : Manually specify the seed type used for generating random values. Func ? Creator : A delegate function that can be utilized to create custom random values. string? ForcedKey : Defines a forced key under which the value can be retrieved.","title":"Rystem.DependencyInjection Documentation"},{"location":"Rystem.DependencyInjection/System.Population.Random/#rystemdependencyinjection-documentation","text":"","title":"Rystem.DependencyInjection Documentation"},{"location":"Rystem.DependencyInjection/System.Population.Random/#class-populationsettings","text":"This class acts as a collection of settings that influence the generation of random population data for testing or development purposes.","title":"Class: PopulationSettings"},{"location":"Rystem.DependencyInjection/System.Population.Random/#properties","text":"Dictionary RegexForValueCreation : This dictionary is used to create values using regular expressions. The dictionary key corresponds to the name of a specific property on an object, and the array of strings is a set of regular expressions it can match. Dictionary > DelegatedMethodForValueCreation : This dictionary allows you to specify methods to generate values for specific properties. The key of the dictionary is the name of the property, and the value is a delegate function that returns the value for that property. Dictionary >> DelegatedMethodForValueRetrieving : If you need to retrieve a value asynchronously using an IServiceProvider, you can define a method that takes the IServiceProvider as a parameter and returns a Task . The key of this dictionary should be the name of the property for which the value is retrieved. Dictionary >>> DelegatedMethodWithRandomForValueRetrieving : Similar to DelegatedMethodForValueRetrieving , but for methods that return an IEnumerable of dynamic objects. Dictionary AutoIncrementations : This property allows for the automatic increment of certain values. The key corresponds to the property on an object, and the value is the measure of the auto-increment. Dictionary RandomValueFromRystem : This dictionary hooks up the random population generator with specific properties. The key or the dictionary is the property name, and the value is a RandomPopulationFromRystemSettings object. Dictionary ImplementationForValueCreation : This dictionary allows you to map a type to a specific property for creating a value. Dictionary ForcedNumberOfElementsForEnumerable : This dictionary lets you dictate the number of elements for an IEnumerable property. The key is the property name, and the value is the number of elements. int NumberOfElements : General number of elements be created by the population generator.","title":"Properties:"},{"location":"Rystem.DependencyInjection/System.Population.Random/#class-populationsettings_1","text":"This class simply inherits from PopulationSettings , allowing the users to define settings that are strongly typed to a specific class.","title":"Class: PopulationSettings"},{"location":"Rystem.DependencyInjection/System.Population.Random/#class-randompopulationfromrystemsettings","text":"A settings store governing decisions about the random population generated values.","title":"Class: RandomPopulationFromRystemSettings"},{"location":"Rystem.DependencyInjection/System.Population.Random/#properties_1","text":"bool UseTheSameRandomValuesForTheSameType : If set to true, this ensures that all properties of the same type get populated with the same random value. Type StartingType : Manually specify the seed type used for generating random values. Func ? Creator : A delegate function that can be utilized to create custom random values. string? ForcedKey : Defines a forced key under which the value can be retrieved.","title":"Properties:"},{"location":"Rystem.RepositoryFramework.Abstractions/Microsoft.Extensions.DependencyInjection/","text":"Class Documentation Namespace: Microsoft.Extensions.DependencyInjection This namespace contains extensions methods for an IServiceCollection to add repositories, commands and queries into the service dependency injection container with various other features. The classes here provide abstraction to functionality encapsulated by RepositoryFramework. ServiceCollectionExtensions This class features methods that add Repositories, Commands, Queries and repository-related business into Microsoft's dependency injection container. These methods also provide the implementation for setting up the repository's settings, builder reference and custom separators for parsing default keys. Method Name: AddDefaultSeparatorForDefaultKeyInterface This method sets the default separator for the IDefaultKey interface. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the service is being added. - separator (string): The separator string that will replace the default separator. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddDefaultSeparatorForDefaultKeyInterface(\"|\"); Method Name: AddRepository This method adds a repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the repository is being added. - builder (Action >): The builder to setup the repository. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddRepository<User, int>((builder) => { builder.SetStorageType(StorageType.Cloud) }); Method Name: AddCommand This method adds a command repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the command is being added. - builder (Action >): The builder to setup the command repository. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddCommand<Order, Guid>((builder) => { builder.SetStorageType(StorageType.Local) }); Method Name: AddQuery This method adds a Query repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the Query repository is being added. - builder (Action >): The builder to set up the Query repository. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddQuery<Order, Guid>((builder) => { builder.SetStorageType(StorageType.Local) }); Method Name: ScanBusinessForRepositoryFramework This method adds all business classes from the specified assemblies for the repository or CQRS pattern to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the classes are being added. - assemblies (Assembly[]): The assemblies where the business classes reside. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.ScanBusinessForRepositoryFramework(typeof(SomeBusiness).Assembly); Method Name: AddBusinessForRepository This method adds a business repository for the specified model to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the business repository is being added. Return Value: It returns a new instance of RepositoryBusinessBuilder for the supplied type and key parameters. Usage Example: services.AddBusinessForRepository<Product, Guid>() Method Name: AddRepositoryAsync This method asynchronously adds a repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the repository is being added. - builder (Func , ValueTask>): The builder to setup the repository asynchronously. Return Value: It returns a Task of IServiceCollection which represents the asynchronous operation. Usage Example: await services.AddRepositoryAsync<User, int>(async (builder) => { await builder.SetStorageTypeAsync(StorageType.Cloud) }); Method Name: AddCommandAsync This method asynchronously adds a command repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the command is being added. - builder (Func , ValueTask>): The builder to setup the command repository asynchronously. Return Value: It returns a Task of IServiceCollection which represents the asynchronous operation. Usage Example: await services.AddCommandAsync<Order, Guid>(async (builder) => { await builder.SetStorageTypeAsync(StorageType.Local) }); Method Name: AddQueryAsync This method asynchronously adds a Query repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the Query repository is being added. - builder (Func , ValueTask>): The builder to setup the Query repository asynchronously. Return Value: It returns a Task of IServiceCollection which represents the asynchronous operation. Usage Example: await services.AddQueryAsync<Order, Guid>(async (builder) => { await builder.SetStorageTypeAsync(StorageType.Local) });","title":"Class Documentation"},{"location":"Rystem.RepositoryFramework.Abstractions/Microsoft.Extensions.DependencyInjection/#class-documentation","text":"","title":"Class Documentation"},{"location":"Rystem.RepositoryFramework.Abstractions/Microsoft.Extensions.DependencyInjection/#namespace-microsoftextensionsdependencyinjection","text":"This namespace contains extensions methods for an IServiceCollection to add repositories, commands and queries into the service dependency injection container with various other features. The classes here provide abstraction to functionality encapsulated by RepositoryFramework.","title":"Namespace: Microsoft.Extensions.DependencyInjection"},{"location":"Rystem.RepositoryFramework.Abstractions/Microsoft.Extensions.DependencyInjection/#servicecollectionextensions","text":"This class features methods that add Repositories, Commands, Queries and repository-related business into Microsoft's dependency injection container. These methods also provide the implementation for setting up the repository's settings, builder reference and custom separators for parsing default keys. Method Name: AddDefaultSeparatorForDefaultKeyInterface This method sets the default separator for the IDefaultKey interface. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the service is being added. - separator (string): The separator string that will replace the default separator. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddDefaultSeparatorForDefaultKeyInterface(\"|\"); Method Name: AddRepository This method adds a repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the repository is being added. - builder (Action >): The builder to setup the repository. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddRepository<User, int>((builder) => { builder.SetStorageType(StorageType.Cloud) }); Method Name: AddCommand This method adds a command repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the command is being added. - builder (Action >): The builder to setup the command repository. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddCommand<Order, Guid>((builder) => { builder.SetStorageType(StorageType.Local) }); Method Name: AddQuery This method adds a Query repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the Query repository is being added. - builder (Action >): The builder to set up the Query repository. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.AddQuery<Order, Guid>((builder) => { builder.SetStorageType(StorageType.Local) }); Method Name: ScanBusinessForRepositoryFramework This method adds all business classes from the specified assemblies for the repository or CQRS pattern to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the classes are being added. - assemblies (Assembly[]): The assemblies where the business classes reside. Return Value: It returns the same IServiceCollection instance which allows for fluent method chaining. Usage Example: services.ScanBusinessForRepositoryFramework(typeof(SomeBusiness).Assembly); Method Name: AddBusinessForRepository This method adds a business repository for the specified model to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the business repository is being added. Return Value: It returns a new instance of RepositoryBusinessBuilder for the supplied type and key parameters. Usage Example: services.AddBusinessForRepository<Product, Guid>() Method Name: AddRepositoryAsync This method asynchronously adds a repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the repository is being added. - builder (Func , ValueTask>): The builder to setup the repository asynchronously. Return Value: It returns a Task of IServiceCollection which represents the asynchronous operation. Usage Example: await services.AddRepositoryAsync<User, int>(async (builder) => { await builder.SetStorageTypeAsync(StorageType.Cloud) }); Method Name: AddCommandAsync This method asynchronously adds a command repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the command is being added. - builder (Func , ValueTask>): The builder to setup the command repository asynchronously. Return Value: It returns a Task of IServiceCollection which represents the asynchronous operation. Usage Example: await services.AddCommandAsync<Order, Guid>(async (builder) => { await builder.SetStorageTypeAsync(StorageType.Local) }); Method Name: AddQueryAsync This method asynchronously adds a Query repository to the IServiceCollection. Parameters: - services (IServiceCollection): The IServiceCollection instance to which the Query repository is being added. - builder (Func , ValueTask>): The builder to setup the Query repository asynchronously. Return Value: It returns a Task of IServiceCollection which represents the asynchronous operation. Usage Example: await services.AddQueryAsync<Order, Guid>(async (builder) => { await builder.SetStorageTypeAsync(StorageType.Local) });","title":"ServiceCollectionExtensions"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/","text":"QueryPatternExtensions Class Documentation This class extends the functionality of the IQueryPattern interface, providing a collection of utility methods to perform common querying operations on repositories. Method Details QueryAsync() Description : This method is used to fetch all elements from a repository. Parameters : entity : This is an instance of IQueryPattern that represents your repository. cancellationToken : This optional parameter is used to optionally cancel the operation. Return Value : This method returns an IAsyncEnumerable object that contains all elements of your repository. Usage Example : // Assuming repository implements IQueryPattern interface var allElements = repository.QueryAsync(); ToListAsEntityAsync() Description : This method is used to fetch all elements from a repository and return them as a list. Parameters : entity : This is an instance of IQueryPattern that represents your repository. cancellationToken : This optional parameter is used to optionally cancel the operation. Return Value : This method returns a ValueTask that results in a List of all elements in your repository. Usage Example : // Assuming repository implements IQueryPattern interface var allElementsList = await repository.ToListAsEntityAsync(); QueryAsEntityAsync() Description : This method is used to fetch all elements from a repository and return them as IAsyncEnumerable . Parameters : entity : This is an instance of IQueryPattern that represents your repository. cancellationToken : This optional parameter is used to optionally cancel the operation. Return Value : This method returns an IAsyncEnumerable object that contains all elements of your repository. Usage Example : // Assuming repository implements IQueryPattern interface var asyncElements = repository.QueryAsEntityAsync(); AsQueryBuilder() Description : This method is used to create a QueryBuilder instance for your repository which can then be used to build complex queries. Parameters : entity : This is an instance of IQueryPattern that represents your repository. Return Value : This method returns a QueryBuilder instance for the specified repository. Usage Example : // Assuming repository implements IQueryPattern interface var queryBuilder = repository.AsQueryBuilder(); For the remaining methods, see the following pattern: Where() , Take() , Skip() , OrderBy() , and OrderByDescending() are used to construct advanced queries. GroupByAsync() , AnyAsync() , FirstOrDefaultAsync() , FirstAsync() , PageAsync() , SumAsync() , AverageAsync() , MaxAsync() , MinAsync() , and ToListAsync() fetch data from the repository based on the query parameters, ranging from counting the total elements to performing aggregate operations like sums and averages. The parameters include the repository entity, an expression representing the query or property to operate on, the number of elements to take or skip, the cancellation token, etc., depending on the method. The methods return an asynchronous task-based result containing the fetched or computed data, which could be a simple boolean, a single element, a list of elements, a count, or an aggregate value. Use them as follows: // Assuming repository implements IQueryPattern interface var selectedElements = await repository.Where(x => x.Property > 100).ToListAsync(); var totalElements = await repository.CountAsync(); var sumOfElementsProperty = await repository.SumAsync(x => x.Property); The above example filters elements based on a property, counts total elements, and calculates a sum. In this way, these methods can be combined to create powerful and flexible queries for data retrieval.","title":"QueryPatternExtensions Class Documentation"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/#querypatternextensions-class-documentation","text":"This class extends the functionality of the IQueryPattern interface, providing a collection of utility methods to perform common querying operations on repositories.","title":"QueryPatternExtensions Class Documentation"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/#method-details","text":"","title":"Method Details"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/#queryasync","text":"Description : This method is used to fetch all elements from a repository. Parameters : entity : This is an instance of IQueryPattern that represents your repository. cancellationToken : This optional parameter is used to optionally cancel the operation. Return Value : This method returns an IAsyncEnumerable object that contains all elements of your repository. Usage Example : // Assuming repository implements IQueryPattern interface var allElements = repository.QueryAsync();","title":"QueryAsync()"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/#tolistasentityasync","text":"Description : This method is used to fetch all elements from a repository and return them as a list. Parameters : entity : This is an instance of IQueryPattern that represents your repository. cancellationToken : This optional parameter is used to optionally cancel the operation. Return Value : This method returns a ValueTask that results in a List of all elements in your repository. Usage Example : // Assuming repository implements IQueryPattern interface var allElementsList = await repository.ToListAsEntityAsync();","title":"ToListAsEntityAsync()"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/#queryasentityasync","text":"Description : This method is used to fetch all elements from a repository and return them as IAsyncEnumerable . Parameters : entity : This is an instance of IQueryPattern that represents your repository. cancellationToken : This optional parameter is used to optionally cancel the operation. Return Value : This method returns an IAsyncEnumerable object that contains all elements of your repository. Usage Example : // Assuming repository implements IQueryPattern interface var asyncElements = repository.QueryAsEntityAsync();","title":"QueryAsEntityAsync()"},{"location":"Rystem.RepositoryFramework.Abstractions/System.Linq/#asquerybuilder","text":"Description : This method is used to create a QueryBuilder instance for your repository which can then be used to build complex queries. Parameters : entity : This is an instance of IQueryPattern that represents your repository. Return Value : This method returns a QueryBuilder instance for the specified repository. Usage Example : // Assuming repository implements IQueryPattern interface var queryBuilder = repository.AsQueryBuilder(); For the remaining methods, see the following pattern: Where() , Take() , Skip() , OrderBy() , and OrderByDescending() are used to construct advanced queries. GroupByAsync() , AnyAsync() , FirstOrDefaultAsync() , FirstAsync() , PageAsync() , SumAsync() , AverageAsync() , MaxAsync() , MinAsync() , and ToListAsync() fetch data from the repository based on the query parameters, ranging from counting the total elements to performing aggregate operations like sums and averages. The parameters include the repository entity, an expression representing the query or property to operate on, the number of elements to take or skip, the cancellation token, etc., depending on the method. The methods return an asynchronous task-based result containing the fetched or computed data, which could be a simple boolean, a single element, a list of elements, a count, or an aggregate value. Use them as follows: // Assuming repository implements IQueryPattern interface var selectedElements = await repository.Where(x => x.Property > 100).ToListAsync(); var totalElements = await repository.CountAsync(); var sumOfElementsProperty = await repository.SumAsync(x => x.Property); The above example filters elements based on a property, counts total elements, and calculates a sum. In this way, these methods can be combined to create powerful and flexible queries for data retrieval.","title":"AsQueryBuilder()"}]}